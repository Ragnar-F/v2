<!DOCTYPE HTML>
<html>
<head>
<title>Bildschirmtastatur</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="robots" content="noindex, nofollow">
<link href="../static/theme.css" rel="stylesheet" type="text/css" />
<script src="../static/content.js" type="text/javascript"></script>
<script src="../static/ga.js" type="text/javascript"></script>
</head>
<body>

<h1>Bildschirmtastatur <span class="headnote">Basierend auf dem v1-Skript von Jon</span></h1>

<p>Dieses Skript erstellt eine nachgebildete Tastatur am unteren Rand des Bildschirms, das die gedrückten Tasten in Echtzeit anzeigt. Das hat mir geholfen, Eingaben zu machen, ohne dabei auf die Tastatur zu schauen. Die Größe der Bildschirmtastatur kann im oberen Bereich des Skripts angepasst werden. Außerdem kann die Tastatur angezeigt oder versteckt werden, wenn das Infobereichssymbol doppelt angeklickt wird.
</p>
<p><a href="KeyboardOnScreen.ahk">Dieses Skript herunterladen</a>  |  <a href="index.htm">Andere Beispiel-Skripte</a>  |  <a href="../AutoHotkey.htm">Home</a></p>

<pre class="NoIndent"><em>;---- Konfigurationsbereich: Die Größe der Bildschirmtastatur und
; andere Optionen anpassen.</em>

<em>; Beim Verändern der Schriftgröße wird die gesamte Bildschirmtastatur
; größer oder kleiner:</em>
k_FontSize := 10
k_FontName := "Verdana"  <em>; Kann leer sein, um die Standardschriftart des Systems zu verwenden.</em>
k_FontStyle := "Bold"    <em>; Alternatives Beispiel: Italic Underline</em>

<em>; Namen der Infobereichsmenüpunkte:</em>
k_MenuItemHide := "&amp;Bildschirmtastatur verstecken"
k_MenuItemShow := "&amp;Bildschirmtastatur anzeigen"

<em>; Um die Tastatur auf einen nicht-primären Anzeigegerät anzuzeigen, verwendet man
; eine Zahl wie z. B. 2 für die folgende Variable. Lasst sie leer, um den
; primären Monitor zu verwenden:</em>
k_Monitor := ""

<em>;---- Ende des Konfigurationsbereichs. Hier danach keine Änderungen durchführen,
; es sei denn, die allgemeine Funktionalität des Skripts soll geändert werden.</em>

<em>;---- Ein GUI-Fenster für die Bildschirmtastatur erstellen:</em>
Gui := GuiCreate("-Caption +ToolWindow +AlwaysOnTop +Disabled")
Gui.SetFont("s" k_FontSize " " k_FontStyle, k_FontName)
Gui.MarginY := 0, Gui.MarginX := 0

<em>;---- Infobereichsmenü ändern:</em>
fn := Func("k_ShowHide").bind(Gui, k_MenuItemHide, k_MenuItemShow)
Menu("Tray", "Add", k_MenuItemHide, fn)
Menu("Tray", "Add", "&amp;Exit", "k_MenuExit")
Menu("Tray", "Default", k_MenuItemHide)
Menu("Tray", "NoStandard")

<em>;---- Für jede Taste einen Button hinzufügen:</em>

<em>; Das Tastaturlayout, das Sie sehen:</em>
k_cL := [ ["``", "1", "2", "3", "4", "5", "6", "7", "8", "9", "0", "-", "=", "Back "]
        , ["Tab", "Q", "W", "E", "R", "T", "Y", "U", "I", "O", "P", "[", "]", "\  "]
        , ["Caps", "A", "S", "D", "F", "G", "H", "J", "K", "L", ";", "'", "Enter"]
        , ["Shift", "Z", "X", "C", "V", "B", "N", "M", ",", ".", "/", "Shift  "]
        , ["Ctrl", "Win", "Alt", "Space ", "Alt", "Win", "Menu", "Ctrl"] ]

<em>; AutoHotkey's offizielle Tastennamen für die Tasten oben (leer lassen wenn identisch):</em>
k_oL := [ [, , , , , , , , , , , , , "Backspace"]
        , []
        , ["CapsLock"]
        , ["LShift", , , , , , , , , , , "RShift"]
        , ["LCtrl", "LWin", "LAlt", , "RAlt", "RWin", "AppsKey", "RCtrl"] ]

<em>; Jede Taste in der Liste mit benutzerdefinierten Tastennamen durchgehen:</em>
For n, k_Row in k_cL
  For i, k_CustomKeyName in k_Row
  {
    k_OfficialKeyName := k_oL[n][i]
    <em>; Objektmaße anhand der ausgewählten Schriftgröße berechnen:</em>
    opt := "h" k_FontSize * 3 " w" k_FontSize * (StrLen(k_CustomKeyName) + 2) " x+m" 
    if i = 1
      opt .= " y+m xm"
    <em>; Wenn der Benutzer eine Taste drückt, klicke den entsprechenden Button auf dem Bildschirm:</em>
    fn := Func("k_KeyPress").bind(Gui.Add("Button", opt, k_CustomKeyName))
    <em>; If the key has an official key name use it:</em>
    if k_OfficialKeyName
      Hotkey("~*" k_OfficialKeyName, fn)
    else
      Hotkey("~*" Trim(k_CustomKeyName), fn)
  }

<em>;---- Tastatur am unteren Rand des Bildschirms positionieren
; (unter Berücksichtigung der Taskleistenposition):</em>
Gui.Show("Hide") <em>; Notwendig, um die berechnete Breite und Höhe des Fensters zu erhalten.
; X-Position des Fensters berechnen:</em>
MonitorGetWorkArea(k_Monitor, WL,, WR, WB)
k_xPos := (WR - WL - Gui.Pos.W) / 2 <em>; Position berechnen, um sie horizontal zu zentrieren.
; Das Folgende wird durchgeführt, falls sich das Fenster nicht auf dem primären Monitor befindet
; oder wenn die Taskleiste auf der linken Seite des Bildschirms verankert ist:</em>
k_xPos += WL
<em>; Y-Position des Fensters berechnen:</em>
k_yPos := WB - Gui.Pos.H

<em>;---- Fenster anzeigen:</em>
Gui.Show("x" k_xPos " y" k_yPos " NA")

<em>;---- Funktionsdefinitionen:</em>
k_KeyPress(BtnCtrl)
{ 
  BtnCtrl.Opt("Default") <em>; Die zuletzt gedrückte Taste hervorheben.</em>
  ControlClick(, "ahk_id " BtnCtrl.Hwnd,,,, "D")
  KeyWait(SubStr(A_ThisHotkey, 3))
  ControlClick(, "ahk_id " BtnCtrl.Hwnd,,,, "U")
}

k_ShowHide(GuiObj, HideText, ShowText)
{
  static isVisible := true
  if isVisible
  {
    GuiObj.Hide
    Menu("Tray", "Rename", HideText, ShowText)
    isVisible := false
  }
  else
  {
    GuiObj.Show
    Menu("Tray", "Rename", ShowText, HideText)
    isVisible := true
  }
}

k_MenuExit()
{
  ExitApp
}
</pre>
</body>
</html>
