<!DOCTYPE HTML>
<html lang="de">
<head>
<title>Objekte - Definition &amp; Verwendung | AutoHotkey v2</title>
<meta name="description" content="Erfahren Sie mehr über die grundlegende Verwendung von Objekten, die erweiterte Verwendung von Objekten, benutzerdefinierte Objekte, Standard-Base-Objekte und die Implementierung von Objekten." />
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="robots" content="noindex, nofollow">
<link href="static/theme.css" rel="stylesheet" type="text/css" />
<script src="static/content.js" type="text/javascript"></script>
<script src="static/ga.js" type="text/javascript"></script>
<style>
ul.list_of_p p { margin: 0.5em 0; }
ul.list_of_p li { margin: 1em 0; }
</style>
</head>
<body>

<h1>Objekte</h1>

<p class="warning"><strong>Hinweis:</strong> Diese Seite ist noch in Bearbeitung.</p>

<p>Ein <i>Objekt</i> ist eine Kombination aus <em>Eigenschaften</em> und <a href="Concepts.htm#methods"><em>Methoden</em></a>.</p>
<p>Verwandte Themen:</p>
<ul>
  <li><a href="Concepts.htm#objects">Objekte</a>: Allgemeine Erklärung zu Objekten.</li>
  <li><a href="Concepts.htm#object-protocol">Objektorientierte Schnittstelle</a>: Einzelheiten darüber, wie ein Skript mit einem Objekt interagiert.</li>
  <li><a href="objects/Functor.htm">Funktionsobjekte</a>: Objekte, die <em>aufgerufen</em> werden können.</li>
</ul>

<p>Mit <b>IsObject</b> kann festgestellt werden, ob ein Wert ein Objekt ist:</p>
<pre>Ergebnis := IsObject(<i>Ausdruck</i>)</pre>

<p>Eine Auflistung der verfügbaren Objekttypen finden Sie unter <em>Objekttypen</em> in der Seitenleiste der Dokumentation. Es gibt zwei grundlegende Typen:</p>
<ul>
  <li><strong>AutoHotkey-Objekte</strong> sind Instanzen der <a href="objects/Object.htm">Object</a>-Klasse. Diese unterstützen Ad-hoc-Eigenschaften und -Methoden, und verfügen über Mittel, um herauszufinden, welche Eigenschaften und Methoden existieren. <a href="objects/Array.htm">Array</a>, <a href="objects/Map.htm">Map</a> und alle benutzerdefinierten und internen Klassen werden von Object abgeleitet.</li>
  <li><strong>COM-Objekte</strong>, wie solche, die via <a href="commands/ComObjCreate.htm">ComObjCreate</a> erstellt werden. Diese sind in externen Bibliotheken implementiert und unterscheiden sich daher von AutoHotkey-Objekten in Bezug auf das Verhalten. ComObject repräsentiert typischerweise ein COM- oder "Automation"-Objekt mit einer implementierten <a href="https://docs.microsoft.com/de-de/windows/desktop/api/oaidl/nn-oaidl-idispatch">IDispatch-Schnittstelle</a>. Es wird auch genutzt, um <a href="commands/ComObject.htm">Werte von spezifischen Typen zu wrappen</a>, damit diese an COM-Objekten und Funktionen übergeben werden können.</li>
</ul>

<h2>Inhaltsverzeichnis</h2>
<ul>
  <li><a href="#Usage">Grundlegende Verwendung</a> - <a href="#Usage_Simple_Arrays">Arrays</a>, <a href="#Usage_Associative_Arrays">Maps (assoziative Arrays)</a>, <a href="#Usage_Objects">Objekte</a>, <a href="#Usage_Freeing_Objects">Freigeben von Objekten</a></li>
  <li><a href="#Extended_Usage">Erweiterte Verwendung</a> - <a href="#Function_References">Funktionsreferenzen</a>, <a href="#Usage_Arrays_of_Arrays">Mehrdimensionale Arrays</a></li>
  <li><a href="#Custom_Objects">Benutzerdefinierte Objekte</a> - <a href="#creating-a-base-object">Erstellen eines Base-Objekts</a>, <a href="#Custom_Classes">Klassen</a>, <a href="#Custom_NewDelete">Konstruktion und Destruktion</a>, <a href="#Meta_Functions">Metafunktionen</a></li>
  <li><a href="#Default_Base_Object">Standard-Base-Objekt</a> - <a href="#Automatic_Var_Init">Automatische Variableninitialisierung</a>, <a href="#Pseudo_Properties">Pseudo-Eigenschaften</a>, <a href="#Default__Warn">Debugging</a></li>
  <li><a href="#Implementation">Implementierung</a> - <a href="#Reference_Counting">Referenzzählung</a>, <a href="#Implementation_Pointers">Objekt-Pointer</a></li>
</ul>

<span id="Syntax"></span><h2 id="Usage">Grundlegende Verwendung</h2>

<h3 id="Usage_Simple_Arrays">Arrays</h3>
<p>Erstellen eines <a href="objects/Array.htm">Arrays</a>:</p>
<pre>MeinArray := [Element1, Element2, ..., ElementN]
MeinArray := Array(Element1, Element2, ..., ElementN)</pre>
<p>Abrufen eines Elements (oder <em>Array-Elements</em>):</p>
<pre>Wert := MeinArray[Index]</pre>
<p>Ändern eines Elementwertes (muss bereits im Array existieren):</p>
<pre>MeinArray[Index] := Wert</pre>
<p>Einfügen eines oder mehrerer Elemente ab einem bestimmten Index mittels <a href="objects/Array.htm#InsertAt">InsertAt</a>-Methode:</p>
<pre>MeinArray.InsertAt(Index, Wert, Wert2, ...)</pre>
<p>Anfügen eines oder mehrerer Elemente mittels <a href="objects/Array.htm#Push">Push</a>-Methode:</p>
<pre>MeinArray.Push(Wert, Wert2, ...)</pre>
<p>Entfernen eines Elements mittels <a href="objects/Array.htm#RemoveAt">RemoveAt</a>-Methode:</p>
<pre>EntfernterWert := MeinArray.RemoveAt(Index)</pre>
<p>Entfernen eines Elements mittels <a href="objects/Array.htm#Pop">Pop</a>-Methode:</p>
<pre>EntfernterWert := MeinArray.Pop()</pre>
<p><a href="objects/Array.htm#Length">Length</a> gibt die Anzahl aller Elemente im Array zurück. Um die Inhalte des Arrays zu durchlaufen, benutzt man entweder den Index oder eine For-Schleife. Zum Beispiel:</p>
<pre>MeinArray := ["eins", "zwei", "drei"]

<em>; Durchläuft das Array von 1 bis zu seinem Ende:</em>
Loop MeinArray.Length
    MsgBox MeinArray[A_Index]

<em>; Enumeriert die Inhalte des Arrays:</em>
For index, wert in MeinArray
    MsgBox "Element " index " ist '" wert "'"
    
<em>; Das Gleiche nochmal:</em>
For wert in MeinArray
    MsgBox "Element " A_Index " ist '" wert "'"
</pre>

<h3 id="Usage_Associative_Arrays">Map-Objekte (Assoziative Arrays)</h3>
<p>Ein <a href="objects/Map.htm">Map</a>-Objekt bzw. assoziatives Array ist ein Objekt, das mehrere eindeutige Keys (Schlüssel) und mehrere Values (Werte) enthält, die jeweils miteinander verbunden sind. Keys können Zeichenketten, Integer oder Objekte sein. Values beliebige Typen. Ein assoziatives Array kann wie folgt erstellt werden:</p>
<pre>MeinMap := Map("KeyA", ValueA, "KeyB", ValueB, ..., "KeyZ", ValueZ)</pre>
<p>Abrufen eines Elements, wo <code>Key</code> eine <a href="Concepts.htm#variables">Variable</a> oder ein <a href="Language.htm#expressions">Ausdruck</a> ist:</p>
<pre>Wert := MeinMap[Key]</pre>
<p>Zuweisen eines Elements:</p>
<pre>MeinMap[Key] := Wert</pre>
<p>Entfernen eines Elements mittels <a href="objects/Array.htm#Delete">Delete</a>-Methode:</p>
<pre>EntfernterWert := MeinMap.Delete(Key)</pre>
<p>Enumerieren von Elementen:</p>
<pre>MeinMap := Map("zehn", 10, "zwanzig", 20, "dreißig", 30)
<a href="commands/For.htm">For</a> key, value in MeinMap
    MsgBox key ' = ' value</pre>

<h3 id="Usage_Objects">Objekte</h3>
<p>Ein Objekt kann <em>Eigenschaften</em>, <em>Methoden</em> und <em>Elemente</em> haben (z. B. Array-Elemente). Der Zugriff auf Elemente erfolgt über <code>[]</code>, wie in den vorherigen Abschnitten gezeigt. Der Zugriff auf Eigenschaften und Methoden erfolgt durch Anfügen eines Punktes und einem Identifikator (einfach ein <a href="Concepts.htm#names">Name</a>).</p>
<p><strong>Beispiele:</strong></p>
<p>Abrufen oder Setzen einer Eigenschaft mit dem direkt geschriebenen Namen <em>Eigenschaft</em>:</p>
<pre>Wert := Objekt.Eigenschaft</pre>
<pre>Objekt.Eigenschaft := Wert</pre>
<p>Abrufen oder Setzen einer Eigenschaft mit einem Namen, der via <a href="Language.htm#expressions">Ausdruck</a> oder <a href="Concepts.htm#variables">Variable</a> ermittelt wird:</p>
<pre>Wert := Objekt.%Ausdruck%</pre>
<pre>Objekt.%Ausdruck% := Wert</pre>
<p>Aufrufen einer Methode mit dem direkt geschriebenen Namen <em>Methode</em>:</p>
<pre>Rückgabewert := Objekt.Methode(Parameter)</pre>
<p>Aufrufen einer Methode mit einem Namen, der via Ausdruck oder Variable ermittelt wird:</p>
<pre>Rückgabewert := Objekt.%Ausdruck%(Parameter)</pre>
<p>Einige Eigenschaften können Parameter akzeptieren:</p>
<pre>Wert := Objekt.Eigenschaft[Parameter]
Objekt.Eigenschaft[Parameter] := Wert</pre>
<p>Tatsächlich ruft die Array-Indexierungssyntax <code>MeinArray[Index]</code> eigentlich die <code>__Item</code>-Eigenschaft von <code>MeinArray</code> auf und übergibt <code>Index</code> als Parameter.</p>

<h3 id="Usage_Freeing_Objects">Freigeben von Objekten</h3>
<p>Skripte geben Objekte nicht explizit frei. Sobald die letzte Referenz zu einem Objekt freigegeben ist, wird das Objekt automatisch freigegeben. Eine Referenz, die in einer Variable gespeichert ist, wird automatisch freigegeben, wenn diese Variable irgendeinen anderen Wert zugewiesen bekommt. Zum Beispiel:</p>
<pre>obj := {}  <em>; Erstellt ein Objekt.</em>
obj := ""  <em>; Gibt die letzte Referenz frei, wodurch das Objekt freigegeben wird.</em></pre>
<p>Außerdem wird eine Referenz, die in einer Eigenschaft oder einem Array-Element gespeichert ist, freigegeben, wenn diese Eigenschaft oder dieses Array-Element irgendeinen anderen Wert zugewiesen bekommt oder aus dem Objekt entfernt wird.</p>
<pre>arr := [{}]  <em>; Erstellt ein Array, das ein Objekt enthält.</em>
arr[1] := {}  <em>; Erstellt ein zweites Objekt, wodurch das erste Objekt indirekt freigegeben wird.</em>
arr.RemoveAt(1)  <em>; Entfernt und gibt das zweite Objekt frei.</em></pre>
<p id="Circular_References">Da alle Referenzen zu einem Objekt freigegeben werden müssen, bevor das Objekt freigegeben werden kann, können Objekte mit Zirkelbezügen nicht automatisch freigegeben werden. Wenn beispielsweise <code>x.child</code> auf <code>y</code> verweist und <code>y.parent</code> auf <code>x</code> verweist, würde es nicht genügen, <code>x</code> und <code>y</code> zu leeren, weil das Parent-Objekt noch eine Referenz zum Child-Objekt enthält, und umgekehrt. Um diese Situation in den Griff zu bekommen, entfernt man den Zirkelbezug.</p>
<pre>
x := {}, y := {}             <em>; Erstellt zwei Objekte.</em>
x.child := y, y.parent := x  <em>; Erstellt ein Zirkelbezug.</em>

y.parent := ""               <em>; Der Zirkelbezug muss entfernt werden, bevor die Objekte freigegeben werden können.</em>
x := "", y := ""             <em>; Wenn die Zeile darüber fehlen würde, könnten die Objekte auf diese Weise nicht freigegeben werden.</em>
</pre>
<p>Für mehr Details, siehe <a href="#Reference_Counting">Referenzzählung</a>.</p>

<h2 id="Extended_Usage">Erweiterte Verwendung</h2>
<h3 id="Function_References">Funktionsreferenzen</h3>
<p>Wenn die Variable <i>funk</i> den Namen einer Funktion enthält, kann die Funktion mit dem Ausdruck  <code><a href="Functions.htm#DynCall">%funk%()</a></code> aufgerufen werden. Allerdings ist dies ineffizient, weil jedes Mal, wenn die Funktion aufgerufen wird, der Funktionsname aufgelöst werden muss. Um die Performance zu verbessern, kann eine Referenz zu der Funktion in eine Variable gespeichert und später wiederverwendet werden:</p>
<pre>RefMeinerFunk := Func("MeineFunk")</pre>
<p>Mit der folgenden Syntax kann eine Funktion via Referenz aufgerufen werden:</p>
<pre>
RückWert := <a href="Functions.htm#DynCall">%MeinFunkVerw%</a>(<i>Parameter</i>)
RückWert := MeinFunkVerw.<a href="objects/Func.htm#Call">Call</a>(<i>Parameter</i>)
</pre>
<p>Weitere Eigenschaften von Funktionsreferenzen finden Sie unter <a href="objects/Func.htm">Func-Objekt</a>.</p>
<p>In den meisten Fällen kann anstelle einer Funktionsreferenz ein beliebiges <a href="objects/Functor.htm">aufrufbares Objekt</a> verwendet werden.</p>

<h3 id="Usage_Arrays_of_Arrays">Mehrdimensionale Arrays</h3>
<p>Obwohl "mehrdimensionale" Arrays nicht unterstützt werden, kann ein Skript mehrere Arrays oder Maps kombinieren. Zum Beispiel:</p>
<pre>
Gitter := [[1,2,3],
         [4,5,6],
         [7,8,9]]
MsgBox Gitter[1][3] <em>; 3</em>
MsgBox Gitter[3][2] <em>; 8</em>
</pre>
<p>Ein benutzerdefiniertes Objekt kann mehrdimensionale Unterstützung implementieren, indem es eine __Item-Eigenschaft definiert. Zum Beispiel:</p>
<pre>
class Array2D extends Array {
    __new(x, y) {
        this.Länge := x * y
        this.Breite := x
        this.Höhe := y
    }
    __Item[x, y] {
        get =&gt; base[this.Breite * (y-1) + x]
        set =&gt; base[this.Breite * (y-1) + x] := value
    }
}

Gitter := Array2D.new(3, 4)
Gitter[1, 4] := "#"
Gitter[2, 3] := "#"
Gitter[2, 2] := "#"
Gitter[3, 1] := "#"
Gittertext := ""
Loop Gitter.Breite {
    x := A_Index
    Loop Gitter.Höhe {
        y := A_Index
        Gittertext .= Gitter[x, y] || "-"
    }
    Gittertext .= "`n"
}
MsgBox Gittertext
</pre>
<p>Ein echtes Skript sollte eine Fehlerprüfung durchführen und andere Methoden wie __Enum überschreiben, um die Enumeration zu unterstützen.</p>

<h2 id="Custom_Objects">Benutzerdefinierte Objekte</h2>
<p>Es gibt zwei verschiedene Möglichkeiten, benutzerdefinierte Objekte zu erstellen:</p>
<ul>
  <li><em>Ad hoc</em>: Ein Objekt erstellen und Eigenschaften und Methoden hinzufügen.</li>
  <li><em>Delegation</em>: Eigenschaften und Methoden in einem <em>Base-Objekt</em> oder einer Klasse definieren.</li>
</ul>
<p><a href="#Meta_Functions">Metafunktionen</a> können genutzt werden, um das Verhalten eines Objekts noch genauer zu steuern.</p>
<p class="note"><strong>Hinweis:</strong> In diesem Abschnitt ist ein <em>Objekt</em> eine beliebige Instanz der <a href="objects/Object.htm">Object</a>-Klasse. Dieser Abschnitt gilt nicht für COM-Objekte.</p>

<h3 id="ad-hoc">Ad Hoc</h3>
<p>Ein neues Objekt kann grundsätzlich zu jeder Zeit um Eigenschaften und Methoden erweitert werden. Das folgende Beispiel zeigt, wie ein Objekt mit einer Eigenschaft und einer Methode konstruiert werden kann:</p>
<pre><em>; Erstellt ein Objekt.</em>
obj := {}
<em>; Speichert einen Wert.</em>
obj.foo := "bar"
<em>; Definiert eine Methode.</em>
thing.DefineMethod "test", Func("thing_test")
<em>; Ruft die Methode auf.</em>
obj.test()

obj_test(this) {
    MsgBox this.foo
}</pre>
<p>Sobald <code>obj.test()</code> aufgerufen wird, wird <i>obj</i> automatisch an den Anfang der Parameterliste gesetzt. Standardmäßig wird der Name der Funktion aus folgenden Komponenten gebildet (aber nicht zwingend notwendig): der "Typ" des Objekts und der Name der Methode.</p>
<p>Siehe auch: <a href="objects/Object.htm#DefineMethod">DefineMethod</a>, <a href="objects/Object.htm#DefineProp">DefineProp</a></p>

<h3 id="delegation">Delegation</h3>
<p>Objekte sind <em>prototypenbasiert</em>. Das heißt, dass alle Eigenschaften oder Methoden, die nicht im Objekt selbst definiert sind, stattdessen im <a href="objects/Object.htm#Base">Base</a> des Objekts definiert werden können. Man bezeichnet dies als <em>Vererbung durch Delegation</em> oder <em>Differenzielle Vererbung</em>, da ein Objekt nur die Teile implementieren kann, die sich vom Objekt unterscheiden, während es den Rest an dessen Base delegiert.</p>
<p>Obwohl ein Base-Objekt gemeinhin auch als Prototyp bekannt ist, verwenden wir den Begriff "<a href="objects/Class.htm#Prototype">Prototyp</a> einer Klasse" für das Objekt, auf dem jede Instanz der Klasse basiert, und "Base" für das Objekt, auf dem eine Instanz basiert (oder manchmal die <a href="#Custom_Classes_base">Base-Klasse/Superklasse</a> der aktuellen Klasse).</p>
<p class="note">Das Objektdesign von AutoHotkey wurde hauptsächlich von JavaScript und Lua beeinflusst, und etwas C#. Wir verwenden <code><i>obj</i>.base</code> anstelle von JavaScript's <code><i>obj</i>.__proto__</code> und <code><i>cls</i>.Prototype</code> anstelle von JavaScript's <code><i>func</i>.prototype</code>. (Klassenobjekte werden anstelle von Konstruktorfunktionen verwendet.)</p>

<p>Das Base eines Objekts wird auch verwendet, um dessen Typ oder Klasse zu identifizieren. Zum Beispiel erstellt <code>x := []</code> ein Objekt <em>basierend auf</em> <code>Array.Prototype</code>; das heißt, dass die Ausdrücke <code>x is Array</code> und <code>x.HasBase(Array.Prototype)</code> True sind und <code>type(x)</code> "Array" zurückgibt.</p>
<p>Es kann eine beliebige Instanz von Object oder eine abgeleitete Klasse ein Base-Objekt sein, allerdings kann ein Objekt nur <a href="objects/Object.htm#Base">als Base</a> eines Objekts mit dem gleichen nativen Typ zugewiesen werden. Auf diese Weise wird sichergestellt, dass interne Methoden immer den nativen Typ eines Objekts identifizieren und nur auf Objekte angewendet werden können, die die richtige binäre Struktur aufweisen.</p>
<p>Base-Objekte können auf zwei verschiedene Arten definiert werden:</p>
<ul>
  <li>Durch <a href="#creating-a-base-object">Erstellen eines normalen Objekts</a>.</li>
  <li>Durch <a href="#Custom_Classes">Definieren einer Klasse</a>. Jede Klasse hat eine <a href="objects/Class.htm#Prototype">Prototype</a>-Eigenschaft, die ein Objekt enthält, auf dem alle Instanzen dieser Klasse basieren, während die Klasse selbst zum Base-Objekt von allen direkten Unterklassen wird.</li>
</ul>
<p>Ein Base-Objekt kann der <a href="objects/Object.htm#Base">Base</a>-Eigenschaft eines anderen Objekts zugewiesen werden, allerdings wird das Base eines Objekts normalerweise beim Erstellen implizit gesetzt.</p>

<h3 id="creating-a-base-object">Erstellen eines Base-Objekts</h3>
<p>Es kann ein beliebiges Objekt als Base eines anderen Objekts verwendet werden, das den gleichen nativen Typ hat. Das folgende Beispiel basiert auf dem vorherigen Beispiel unter <a href="#ad-hoc">Ad Hoc</a> (kombinieren Sie beide vor dem Ausführen):</p>
<pre>anderesObj := {}
anderesObj.base := obj
anderesObj.test()</pre>
<p>In diesem Fall erbt <i>anderesObj</i> das <i>foo</i> und <i>test</i> von <i>obj</i>. Diese Vererbung ist dynamisch - das heißt, wenn <code>obj.foo</code> modifiziert wird, wird <code>anderesObj.foo</code> diese Änderung widerspiegeln. Wenn das Skript <code>anderesObj.foo</code> einen Wert zuweist, wird dieser Wert in <i>anderesObj</i> gespeichert; weitere Änderungen an <code>obj.foo</code> hätten keinen Einfluss auf <code>anderesObj.foo</code>. Sobald <code>anderesObj.test()</code> aufgerufen wird, enthält ihr <i>this</i>-Parameter eine Referenz zu <i>anderesObj</i> statt zu <i>obj</i>.
</p>

<h3 id="Custom_Classes">Klassen</h3>
<blockquote>Unter einer Klasse (auch Objekttyp genannt) versteht man in der objektorientierten Programmierung ein abstraktes Modell bzw. einen Bauplan für eine Reihe von ähnlichen Objekten. <a href="https://de.wikipedia.org/wiki/Klasse_(Objektorientierung)" class="source">Wikipedia</a></blockquote>
<p>Allgemein ausgedrückt ist eine <em>Klasse</em> eine Gruppe oder Kategorie von Dingen, die Eigenschaften oder Attribute gemeinsam nutzen. In AutoHotkey definiert <code>class</code> Eigenschaften und Methoden, die von Instanzen der Klasse gemeinsam genutzt werden sollen. Eine <em>Instanz</em> ist nur ein Objekt, das Eigenschaften und Methoden von der Klasse erbt und typischerweise auch als Teil dieser Klasse verstanden werden kann (z. B. mit dem Ausdruck <code><i>Instanz</i> is <i>Klassenname</i></code>). Instanzen werden typischerweise durch den Aufruf von <a href="objects/Class.htm#New"><em>Klassenname</em>.new()</a> erzeugt.</p>
<p>Da ein von <a href="objects/Object.htm">Object</a> abgeleitetes Objekt <a href="#ad-hoc">dynamisch</a> und <a href="#delegation">prototypenbasiert</a> ist, besteht jede Klasse aus zwei Teilen:</p>
<ul>
  <li>Die Klasse hat ein <a href="objects/Class.htm#Prototype">Prototype</a>-Objekt, auf dem alle Instanzen der Klasse basieren. Alle Methoden und Eigenschaften, die sich auf eine bestimmte Instanz beziehen, sind im Prototype-Objekt enthalten. Dazu gehören alle Eigenschaften und Methoden, denen das Schlüsselwort <code>static</code> fehlt.</li>
  <li>Die Klasse selbst ist ein Objekt, das nur statische Methoden und Eigenschaften enthält. Dazu gehören alle Eigenschaften und Methoden mit dem Schlüsselwort <code>static</code> und alle verschachtelten Klassen. Diese gelten nicht für eine bestimmte Instanz und können verwendet werden, indem man via Name auf die Klasse selbst verweist.</li>
</ul>
<p>Das Folgende zeigt die meisten Elemente einer Klassendefinition:</p>
<pre>class Klassenname extends BaseKlassenname
{
    InstanzVar := <i>Ausdruck</i>
    
    static KlassenVar := <i>Ausdruck</i>

    class VerschachtelteKlasse
    {
        ...
    }

    Methode()
    {
        ...
    }
    
    static Methode()
    {
        ...
    }

    Eigenschaft[]  <em>; Die eckigen Klammern sind optional</em>
    {
        <span class="dec">get</span> {
            return <i>Eigenschaftswert</i>
        }
        <span class="dec">set</span> {
            <i>Speichere oder verarbeite</i> <span class="biv">value</span>
        }
    }
    
    KurzeEigenschaft[]
    {
        <span class="dec">get</span> =&gt; <i>Ausdruck zum Ermitteln des Eigenschaftswertes</i>
        <span class="dec">set</span> =&gt; <i>Ausdruck zum Speichern oder Verarbeiten von</i> <span class="biv">value</span>
    }
    
    KürzereEigenschaft[] =&gt; <i>Ausdruck zum Ermitteln des Eigenschaftswertes</i>
}
</pre>
<p>Dies konstruiert, nachdem das Skript geladen wurde, ein <a href="objects/Class.htm">Class</a>-Objekt und speichert es in die <a href="Functions.htm#SuperGlobal">superglobale</a> Variable <i>Klassenname</i>. Um diese Klasse innerhalb einer <a href="Functions.htm#ForceLocal">Force-Local</a>-Funktion zu verweisen, ist eine Deklaration wie <code>global Klassenname</code> notwendig. Wenn <code>extends BaseKlassenname</code> vorhanden ist, muss der <i>BaseKlassenname</i> der vollständige Name einer anderen Klasse sein. Der vollständige Name jeder Klasse ist in <code><i>Klassenname</i>.Prototype.__Class</code> gespeichert.</p>
<p>Da die Klasse via Variable verwiesen wird, kann der Klassenname nicht genutzt werden, um im selben Kontext sowohl die Klasse zu verweisen als auch eine separate Variable zu erstellen (um z. B. eine Instanz der Klasse zu enthalten). Zum Beispiel würde <code>box := new Box</code> das Klassenobjekt in <em>Box</em> mit einer Instanz von sich selbst ersetzen. <a href="commands/_Warn.htm#ClassOverwrite">#Warn ClassOverwrite</a> aktiviert eine Warnung, die angezeigt wird, wenn Sie versuchen, eine Klasse zu überschreiben.</p>
<p>In dieser Dokumentation bezieht sich das Wort "Klasse" in der Regel auf ein Klassenobjekt, das mit dem Schlüsselwort <code>class</code> erstellt wurde.</p>
<p>Klassendefinitionen können Variablendeklarationen, Methodendefinitionen und Unterklassendefinitionen enthalten.</p>

<h4 id="Custom_Classes_var">Instanzvariablen</h4>
<p>Eine <em>Instanzvariable</em> ist eine Variable, von der jede Instanz der Klasse eine eigene Kopie hat. Sie werden wie normale Zuweisungen deklariert, ohne dass das Präfix <code>this.</code> angegeben werden muss (dies gilt nur in der Klassendefinition):</p>
<pre>InstanzVar := Ausdruck</pre>
<p>Solche Deklarationen werden jedes Mal ausgewertet, wenn eine neue Instanz der Klasse mit dem <a href="#Custom_NewDelete">new</a>-Schlüsselwort oder <a href="objects/Class.htm#New"><em>Klassenname</em>.new()</a> erstellt wird, nachdem alle Base-Klassendeklarationen ausgewertet wurden, aber bevor <a href="#Custom_NewDelete">__New</a> aufgerufen wird. Dies wird erreicht, indem automatisch eine Methode mit dem Namen <em>__Init</em> erstellt wird, die einen Aufruf von <code>base.__Init()</code> enthält, und jede Deklaration in diese eingefügt wird. Daher darf eine einzelne Klassendefinition weder eine __Init-Methode noch eine Instanzvariablendeklaration enthalten.</p>
<p><em>Ausdruck</em> kann mit <code>this</code> auf andere Instanzvariablen und Methoden zugreifen, aber alle anderen Variablenreferenzen werden als global angesehen.</p>
<p>Um auf eine Instanzvariable zugreifen zu können (sogar innerhalb einer Methode), gibt man immer das Zielobjekt an; zum Beispiel <code><b>this</b>.InstanzVar</code>.</p>
<p>Deklarationen wie <code>x.y := z</code> werden auch unterstützt, sofern <code>x</code> zuvor in dieser Klasse deklariert wurde. <code>x := {}, x.y := 42</code> würde beispielsweise <code>x</code>  deklarieren und außerdem <code>this.x.y</code> initialisieren.</p>

<h4 id="Custom_Classes_staticvar">Statische bzw. Klassenvariablen</h4>
<p>Statische bzw. Klassenvariablen gehören nur der Klasse selbst, allerdings können ihre Werte von Unterklassen geerbt werden. Solche Variablen müssen mit dem Schlüsselwort "static" deklariert werden:</p>
<pre>static KlassenVar := Ausdruck</pre>
<p>Diese Deklarationen werden nur einmal ausgewertet, während die Klasse initialisiert wird. In dieser AutoHotkey-Version werden Klassen der Reihenfolge nach, wie sie im Skript erscheinen, initialisiert, bevor der <a href="Scripts.htm#auto">automatische Ausführungsbereich</a> und statische Deklarationen in Funktionen ausgewertet werden. Zu diesem Zweck wird automatisch eine statische Methode namens <em>__Init</em> definiert.</p>
<p>Jede Deklaration speichert einen Wert in das Klassenobjekt. Alle Variablenreferenzen in <i>Ausdruck</i> werden als global angesehen.</p>
<p>Um einer Klassenvariable etwas zuweisen zu können, gibt man immer das Klassenobjekt an; zum Beispiel <code><b>Klassenname</b>.KlassenVar := Wert</code>. Wenn eine Unterklasse keine Eigenschaft mit diesem Namen besitzt, kann <code><i>Unterklasse</i>.KlassenVar</code> auch genutzt werden, um den Wert abzurufen; wenn der Wert eine Referenz zu einem Objekt ist, werden Unterklassen sich dieses Objekt standardmäßig teilen. Allerdings würde <code><i>Unterklasse</i>.KlassenVar := y</code> den Wert nicht in <em>Klassenname</em>, sondern in <em>Unterklasse</em> speichern.</p>
<p>Deklarationen wie <code>static x.y := z</code> werden auch unterstützt, sofern <code>x</code> zuvor in dieser Klasse deklariert wurde. <code>static x := {}, x.y := 42</code> würde beispielsweise <code>x</code> deklarieren und außerdem <code><i>Klassenname</i>.x.y</code> initialisieren.</p>

<h4 id="Custom_Classes_class">Verschachtelte Klassen</h4>
<p>Verschachtelten Klassendefinitionen ermöglichen es, ein Klassenobjekt mit einer statischen Variable/Klassenvariable der äußeren Klasse statt mit einer separaten globalen Variablen zu assoziieren. Im obigen Beispiel konstruiert <code>class VerschachtelteKlasse</code> ein <a href="objects/Class.htm">Class</a>-Objekt und speichert es in <code>Klassenname.VerschachtelteKlasse</code>. Unterklassen können <em>VerschachtelteKlasse</em> erben oder es mit ihrer eigenen verschachtelten Klasse überschreiben (in diesem Fall kann mit <code><i>WelcheKlasse</i>.VerschachtelteKlasse.new()</code> eine geeignete Klasse instanziiert werden).</p>
<pre>
class VerschachtelteKlasse
{
    ...
}
</pre>
<p>Die Verschachtelung einer Klasse bedeutet nicht, dass eine bestimmte Beziehung zur äußeren Klasse besteht. Die verschachtelte Klasse wird weder automatisch instanziiert, noch haben Instanzen der verschachtelten Klasse eine Verbindung zu einer Instanz der äußeren Klasse, es sei denn, das Skript stellt diese Verbindung explizit her.</p>

<h4 id="Custom_Classes_method">Methoden</h4>
<p>Methodendefinitionen sehen genauso aus wie Funktionsdefinitionen. Jede Methode hat einen versteckten Parameter namens <code>this</code>, der eine Referenz zum Objekt enthält, über dem die Klasse aufgerufen wurde. Es gibt zwei Arten von Methoden:</p>
<ul>
  <li>Instanzmethoden sind wie folgt definiert und an den <a href="objects/Class.htm#Prototype">Prototyp</a> der Klasse gekoppelt, wodurch sie über jede Instanz der Klasse zugänglich sind. Wenn die Methode aufgerufen wird, verweist <code>this</code> auf eine Instanz der Klasse.</li>
  <li>Um statische Methoden zu definieren, muss vor dem Methodennamen das separate Schlüsselwort <code>static</code> verwendet werden. Diese sind an das Klassenobjekt selbst gekoppelt, allerdings werden diese auch von Unterklassen geerbt, so dass <code>this</code> entweder auf die Klasse selbst oder auf eine Unterklasse verweist.</li>
</ul>
<pre>
Methode()
{
    ...
}
</pre>

<p id="Custom_Classes_base">Innerhalb einer Methode kann das Pseudo-Schlüsselwort <code>base</code> verwendet werden, um auf Superklassen-Versionen von Methoden oder Eigenschaften, die in einer abgeleiteten Klasse überschrieben werden, zugreifen zu können. <code>base.Methode()</code> in der Klasse oben würde beispielsweise bewirken, dass eine Version von <em>Methode</em> aufgerufen wird, die über <em>BaseKlassenname</em> definiert wurde. <a href="#Meta_Functions">Metafunktionen</a> werden nicht aufgerufen, es sei denn, sie werden explizit benannt. Hinweis:</p>
<ul>
  <li><code>base.Methode()</code> ruft immer dort das Base der Klasse auf, wo die aktuelle Methode definiert wurde, egal ob <code>this</code> von einer <em>Unterklasse</em> aus dieser Klasse oder von einer ganz anderen Klasse abgeleitet worden ist.</li>
  <li>dass <code>base.Methode()</code> implizit <code>this</code> als ersten (versteckten) Parameter übergibt.</li>
</ul>
<p><code>base</code> hat nur eine besondere Bedeutung, wenn danach ein Punkt <code>.</code> oder eine eckige Klammer <code>[]</code> erfolgt, demzufolge wird so etwas wie <code>obj := base, obj.Methode()</code> nicht funktionieren. Skripte können das spezielle Verhalten von <i>base</i> deaktivieren, indem sie dieser Sondervariable einen nicht-leeren Wert zuweisen; dies wird jedoch nicht empfohlen.</p>

<p>Die <a href="Variables.htm#fat-arrow">Fat-Arrow-Syntax</a> kann genutzt werden, um eine einzeilige Methode für die Rückgabe eines Ausdrucks zu definieren:</p>
<pre>Methode() =&gt; <i>Ausdruck</i></pre>
<p>Siehe auch: <a href="objects/Object.htm#DefineMethod">DefineMethod</a></p>

<h4 id="Custom_Classes_property">Eigenschaften</h4>
<p>Eine Eigenschaftsdefinition erzeugt eine <a href="objects/Object.htm#DefineProp">dynamische Eigenschaft</a>, die eine Methode aufruft, anstatt einfach einen Wert zu speichern oder zurückzugeben.</p>
<pre>Eigenschaft[]  <em>; Die eckigen Klammern sind optional</em>
{
    <span class="dec">get</span> {
        return <i>Eigenschaftswert</i>
    }
    <span class="dec">set</span> {
        <i>Speichere oder verarbeite</i> <span class="biv">value</span>
    }
}
</pre>
<p><em>Eigenschaft</em> ist der Name der Eigenschaft, mit dem sie aufgerufen werden kann. <code>obj.Eigenschaft</code> würde beispielsweise <em>get</em> aufrufen, und <code>obj.Eigenschaft := Wert</code> würde <em>set</em> aufrufen. Innerhalb von  <em>get</em> oder <em>set</em> bezieht sich <code>this</code> auf das Objekt, das aufgerufen wird. Innerhalb von <em>set</em> enthält <code>value</code> den Wert, der zugewiesen wird.</p>
<p>Die Definition und Übergabe von Parametern erfolgt auf der rechten Seite des Eigenschaftsnamens, in eckigen Klammern. Abgesehen von den eckigen Klammern werden Eigenschaftsparameter genauso wie Methodenparameter definiert - optionale, variadische und ByRef-Parameter werden unterstützt.</p>
<p>Wenn eine Eigenschaft keine Parameter akzeptieren kann (die eckigen Klammern werden weggelassen oder sind leer), werden Parameter automatisch an die <a href="#__Item">__Item</a>-Eigenschaft des von <em>get</em> zurückgegebenen Objekts weitergeleitet. <code>this.Eigenschaft[x]</code> beispielsweise hätte die gleiche Wirkung wie <code>(this.Eigenschaft)[x]</code> oder <code>y := this.Eigenschaft, y[x]</code>.</p>
<p>Um statische Eigenschaften zu definieren, muss vor dem Eigenschaftsnamen das separate Schlüsselwort <code>static</code> verwendet werden. In diesem Fall verweist <code>this</code> auf die Klasse selbst oder eine Unterklasse.</p>
<p>Der Rückgabewert von <em>set</em> wird ignoriert. <code>Wert := obj.Eigenschaft := 42</code> beispielsweise wird immer <code>Wert := 42</code> zuweisen, egal was die Eigenschaft macht, es sei denn, sie löst eine Ausnahme aus oder beendet den Thread.</p>
<p>Jede Klasse kann eine oder beide Hälften einer Eigenschaft definieren. Wenn eine Klasse eine Eigenschaft überschreibt, kann sie <code><a href="#Custom_Classes_base">base.Eigenschaft</a></code> benutzen, um auf die via eigene Base-Klasse definierte Eigenschaft zugreifen zu können. Wenn <em>Get</em> oder <em>Set</em> nicht definiert ist, kann es von einem Base-Objekt geerbt werden. Wenn <em>Get</em> undefiniert ist, kann die Eigenschaft einen Wert zurückgeben, der von einem Base geerbt wurde. Wenn <em>Set</em> in diesem und allen Base-Objekten undefiniert ist, ist die Eigenschaft schreibgeschützt (der Versuch, die Eigenschaft zu setzen, löst eine Ausnahme aus).</p>
<p>Intern sind <em>get</em> und <em>set</em> zwei unterschiedliche Methoden, die sich untereinander keine Variablen teilen können (es sei denn, man speichert sie in <code>this</code>).</p>
<p>Siehe auch: <a href="objects/Object.htm#DefineProp">DefineProp</a></p>
<p><a href="#Meta_Functions">Metafunktionen</a> bieten eine breitere Auswahl an Möglichkeiten für den kontrollierten Zugriff auf Eigenschaften und Methoden eines Objekts, allerdings sind sie komplizierter und fehleranfälliger.</p>

<h4 id="Custom_Classes_property_short">Fat-Arrow-Eigenschaften</h4>
<p>Die <a href="Variables.htm#fat-arrow">Fat-Arrow-Syntax</a> kann genutzt werden, um einen <a href="#Custom_Classes_property">Eigenschaft</a>-Getter oder -Setter für die Rückgabe eines Ausdrucks zu definieren:</p>
<pre>KurzeEigenschaft[]
{
    <span class="dec">get</span> =&gt; <i>Ausdruck zum Ermitteln des Eigenschaftswertes</i>
    <span class="dec">set</span> =&gt; <i>Ausdruck zum Speichern oder Verarbeiten von</i> <span class="biv">value</span>
}</pre>
<p>Wenn man nur einen Getter definiert, können die geschweiften Klammern und <code>get</code> weggelassen werden:</p>
<pre>KürzereEigenschaft[] =&gt; <i>Ausdruck zum Ermitteln des Eigenschaftswertes</i></pre>

<h3 id="__Enum">__Enum-Methode</h3>
<pre class="Syntax">__Enum(AnzahlVars)</pre>
<p>Die __Enum-Methode wird aufgerufen, wenn das Objekt an eine <a href="commands/For.htm">For-Schleife</a> übergeben wird. Diese Methode sollte einen <a href="objects/Enumerator.htm">Enumerator</a> zurückgeben, der Elemente im Objekt, wie z. B. Array-Elemente, zurückgeben wird. Wenn es undefiniert bleibt, kann das Objekt nicht direkt an eine For-Schleife übergeben werden.</p>
<p><em>AnzahlVars</em> enthält die Anzahl der Variablen, die an die For-Schleife übergeben wurden. Wenn <em>AnzahlVars</em> 2 ist, wird erwartet, dass der Enumerator dem ersten Parameter den Key oder Index eines Elements und dem zweiten Parameter den Wert zuweist. Jeder Key oder Index sollte als Parameter der <a href="#__Item">__Item</a>-Eigenschaft akzeptiert werden. Dadurch können <a href="AHKL_DBGPClients.htm">DBGp-basierte Debugger</a> ein bestimmtes Element abrufen oder setzen, nachdem sie via Enumerator aufgelistet wurden.</p>

<h3 id="__Item">__Item-Eigenschaft</h3>
<p>Die __Item-Eigenschaft wird indirekt aufgerufen, wenn der Index-Operator (Array-Syntax) in Verbindung mit dem Objekt verwendet wird. Zum Beispiel:</p>
<pre>class Env {
    __Item[name] {
        get =&gt; EnvGet(name)
        set =&gt; EnvSet(name, value)
    }
}

Env["PATH"] .= ";" A_ScriptDir  <em>; Hat nur Einfluss auf dieses Skript und Unterprozesse.</em>
MsgBox Env["PATH"]</pre>
<p><code>__Item</code> ist quasi ein Standardeigenschaftsname (wenn so eine Eigenschaft definiert wurde):</p>
<ul>
  <li><code><i>object</i>[<i>params</i>]</code> ist äquivalent zu <code><i>object</i>.__Item[<i>params</i>]</code>, wenn Parameter vorhanden sind.</li>
  <li><code><i>object</i>[]</code> ist äquivalent zu <code><i>object</i>.__Item</code>.</li>
</ul>
<p>Zum Beispiel:</p>
<pre>
obj := {}
obj[] := Map()     <em>; Äquivalent zu obj.__Item := Map()</em>
obj["base"] := 10
MsgBox obj.base = Object.prototype  <em>; True</em>
MsgBox obj["base"]                  <em>; 10</em>
</pre>
<p class="note"><strong>Hinweis:</strong> Wenn ein expliziter Eigenschaftsname mit leeren eckigen Klammern kombiniert wird, wie in <code>obj.prop[]</code>, wird dies als zwei separate Operationen behandelt: zuerst wird <code>obj.prop</code> abgerufen, danach indirekt die Standardeigenschaft des Ergebnisses aufgerufen. Dies ist Bestandteil der Sprachsyntax und somit objektunabhängig.</p>

<h3 id="Custom_NewDelete">Konstruktion und Destruktion</h3>
<p>Jedes Mal, wenn ein Objekt via <a href="objects/Class.htm#New"><em>Klassenname</em>.new()</a> oder <code>new</code>-Schlüsselwort erstellt wird, wird dessen <code>__New</code>-Methode aufgerufen, um eine benutzerdefinierte Initialisierung zu ermöglichen. Alle Parameter, die an <code>new</code> übergeben werden, werden an <code>__New</code> weitergeleitet, so dass sie den ursprünglichen Inhalt des Objekts oder die Art und Weise, wie es konstruiert ist, beeinflussen können. Zerstört man ein Objekt, wird <code>__Delete</code> aufgerufen. Zum Beispiel:</p>
<pre>m1 := GMem.new(0, 10)
m2 := new GMem(0, 20)
m3 := {base: GMem.Prototype}.__New(0, 30)

<em>; Hinweis: Für allgemeine Speicherzuweisungen sollten Sie stattdessen <a href="commands/BufferAlloc.htm">BufferAlloc</a>() verwenden.</em>
class GMem<span id="GMem"></span>
{
    __New(aFlags, aGröße)
    {
        this.ptr := DllCall("GlobalAlloc", "UInt", aFlags, "Ptr", aGröße, "Ptr")
        if !this.ptr
            throw Exception("Nicht genug Speicher")
        MsgBox "New GMem mit einer Größe von " aGröße " Bytes auf der Adresse " this.ptr "."
        return this  <em>; Diese Zeile wird nur benötigt, wenn __new direkt aufgerufen wird.</em>
    }

    __Delete()
    {
        MsgBox "Delete GMem auf der Adresse " this.ptr "."
        DllCall("GlobalFree", "Ptr", this.ptr)
    }
}</pre>
<p>__Delete wird nicht bei Objekten aufgerufen, die eine Eigenschaft namens "__Class" besitzen. <a href="objects/Class.htm#Prototype">Prototype-Objekte</a> haben standardmäßig diese Eigenschaft.</p>
<p>Wenn eine Ausnahme oder ein Laufzeitfehler ausgelöst wird, während __Delete ausgeführt wird, und nicht innerhalb von __Delete behandelt wird, verhält es sich so, als wäre __Delete von einem neuen <a href="misc/Threads.htm">Thread</a> aufgerufen wurden. Das heißt, dass ein Fehlerdialogfenster angezeigt und __Delete durchgeführt wird, aber der Thread nicht beendet wird (es sei denn, er wurde bereits beendet).</p>
<p>Jede Klasse kann auch eine <code>static __New</code>-Methode haben, die unmittelbar nach Initialisierung ihrer <a href="#Custom_Classes_staticvar">statischen Variablen</a> aufgerufen wird (dies geschieht der Reihenfolge nach, wie die Klassen im Skript definiert sind). Diese Methode kann von einer Base-Klasse geerbt und daher zum Initialisieren von Unterklassen verwendet werden. Innerhalb von <code>static __New</code> verweist <code>this</code> entweder auf die Klasse, die die Methode definiert hat, oder auf eine Unterklasse.</p>

<h3 id="Meta_Functions">Metafunktionen</h3>
<pre class="Syntax">
class <i>Klassenname</i> {
    __Get(Name, Params)
    __Set(Name, Params, Wert)
    __Call(Name, Params)
}
</pre>
<dl>
  <dt>Name</dt>
  <dd><p>Der Name der Eigenschaft oder Methode.</p></dd>
  <dt>Params</dt>
  <dd><p>Ein <a href="objects/Array.htm">Array</a> mit Parametern. Dazu gehören nur die Parameter zwischen <code>()</code> oder <code>[]</code>, die also leer sein können. Die Metafunktion soll Fälle wie <code>x.y[z]</code> behandeln, in denen <code>x.y</code> nicht definiert ist.</p></dd>
  <dt>Wert</dt>
  <dd><p>Der Wert, der zugewiesen wird.</p></dd>
</dl>
<p>Metafunktionen definieren, was passieren soll, wenn eine undefinierte Eigenschaft oder Methode aufgerufen wird. Wenn <code>obj.unk</code> beispielsweise keinen Wert zugewiesen bekommen hat, wird die <i>__Get</i>-Metafunktion aufgerufen. <code>obj.unk := value</code> veranlasst hingegen den Aufruf von <i>__Set</i> und <code>obj.unk()</code> den Aufruf von <i>__Call</i>.</p>
<p>Eigenschaften und Methoden können im Objekt selbst oder in einem seiner <a href="#delegation">Base-Objekte</a> definiert werden. Damit für jede Eigenschaft eine Metafunktion aufgerufen werden kann, sollte man grundsätzlich vermeiden, irgendwelche Eigenschaften zu definieren. Interne Eigenschaften wie <a href="objects/Object.htm#Base">Base</a> können mit einer <a href="#Custom_Classes_property">Eigenschaftsdefinition</a> oder <a href="objects/Object.htm#DefineProp">DefineProp</a> überschrieben werden.</p>
<p>Wenn eine Metafunktion definiert ist, muss sie die gewünschte Standardaktion ausführen. Zum Beispiel kann Folgendes erwartet werden:</p>
<ul>
  <li><i>Call</i>: Löse eine Ausnahme "Unbekannte Methode" aus.</li>
  <li>Wenn Parameter angegeben wurden, löse eine Ausnahme aus (es gibt kein Objekt, an das die Parameter weitergeleitet werden können).</li>
  <li><i>Get</i>: Gib eine leere Zeichenkette zurück (Standardverhalten bei Funktionen ohne <code>return</code>).</li>
  <li><i>Set</i>: Definiere eine neue Eigenschaft mit dem angegebenen Wert, z. B. durch Aufruf von <a href="objects/Object.htm#RawSet">ObjRawSet</a>. </li>
</ul>
<p>Es kann ein beliebiges <a href="objects/Functor.htm">aufrufbare Objekt</a> als Metafunktion verwendet werden, indem es an <a href="objects/Object.htm#DefineMethod">DefineMethod</a> übergeben wird.</p>
<p>Metafunktionen werden nie aufgerufen, wenn der Name der Eigenschaft oder Methode weggelassen wird:</p>
<ul>
  <li>Für <code>x[y]</code> können Sie stattdessen eine <code>__Item</code>-Eigenschaft definieren (sie sollte mindestens einen Parameter akzeptieren).</li>
  <li>Für <code>%x%()</code> können Sie stattdessen eine <code>__Call</code>-Methode definieren.</li>
</ul>

<h4 id="Dynamic_Properties">Dynamische Eigenschaften</h4>
<p>Mit der <a href="#Custom_Classes_property">Eigenschaftssyntax</a> und <a href="objects/Object.htm#DefineProp">DefineProp</a> können Eigenschaften definiert werden, die jedes Mal, wenn sie ausgewertet werden, einen Wert berechnen, allerdings muss jede Eigenschaft im Voraus definiert sein. Mit <em>__Get</em> und <em>__Set</em> können hingegen Eigenschaften implementiert werden, die erst zum Zeitpunkt ihres Aufrufs bekannt sind.</p>
<p>Zum Beispiel kann ein "Proxy-Objekt" mit Eigenschaften erstellt werden, die den aktuellen Wert über das Netzwerk (oder über einen anderen Kanal) abfragen. Ein Remote-Server sendet eine Antwort zurück, die den Wert der Eigenschaft enthält, und das Proxy-Objekt übergibt den Wert an seinen Aufrufer. Auch wenn der Name jeder Eigenschaft im Voraus bekannt war, wäre es unlogisch, jede Eigenschaft einzeln in der Proxy-Klasse zu definieren, da jede Eigenschaft dasselbe tun würde (eine Netzwerkanfrage senden). Metafunktionen bekommen den Namen der Eigenschaft als Parameter, demzufolge sind sie eine gute Lösung für dieses Problem.</p>

<h2 id="Default_Base_Object">Standard-Base-Objekt</h2>
<p class="warning"><strong>Hinweis:</strong> Dieser Abschnitt ist veraltet, außerdem wird das Standard-Base-Objekt bald mit spezifischeren Klassen ersetzt.</p>
<p>Wenn ein objektloser Wert mit der Objektsyntax benutzt wird, wird das <i>Standard-Base-Objekt</i> aufgerufen. Dieses Objekt ist nützlich, um das Skript zu debuggen oder um Zeichenketten, Zahlen und/oder Variablen in globaler Hinsicht ein objektähnliches Verhalten zu geben. Der Zugriff auf das Standard-Base kann nur erfolgen, wenn <code>.base</code> mit irgendeinem objektlosen Wert verwendet wird; zum Beispiel <code>"".base</code>. Obwohl das Standard-Base nicht wie in <code>"".base := Object()</code> <i>gesetzt</i> werden kann, kann es selbst ein Base wie in <code>"".base.base := Object()</code> haben.</p>

<h3 id="Automatic_Var_Init">Automatische Variableninitialisierung</h3>
<p>Wenn eine leere Variable als Ziel einer <i>Set</i>-Operation bestimmt wurde, wird sie direkt an die __Set-Metafunktion übergeben, damit sie ein neues Objekt in die Variable einfügen kann. Aus Platzgründen unterstützt dieses Beispiel nicht mehr als ein Parameter; mit einer <a href="Functions.htm#Variadic">variadischen Funktion</a> wäre das möglich.</p>
<pre>"".base.__Set := Func("Default_Set_AutomaticVarInit")

empty_var.foo := "bar"
MsgBox empty_var.foo

Default_Set_AutomaticVarInit(ByRef var, key, value)
{
    if (var = "")
        var := Object(key, value)
    return var
}</pre>

<h3 id="Pseudo_Properties">Pseudo-Eigenschaften</h3>
<p>Diese Art von Syntax kann auch auf Zeichenketten und Zahlen angewendet werden.</p>
<pre>"".base.__Get := Func("Default_Get_PseudoProperty")
"".base.is    := Func("Default_is")

MsgBox A_AhkPath.length " == " StrLen(A_AhkPath)
MsgBox A_AhkPath.length.is("int")

Default_Get_PseudoProperty(nonobj, key)
{
    if (key = "length")
        return StrLen(nonobj)
}

Default_is(nonobj, type)
{
    static alias := {int: "integer"}
    return nonobj is (alias[type] or type)
}</pre>
<p>Beachten Sie, dass interne Funktionen auch genutzt werden können, aber in diesem Fall dürfen die runden Klammern nicht weggelassen werden:</p>
<pre>"".base.length := Func("StrLen")
MsgBox A_AhkPath.length() " == " StrLen(A_AhkPath)</pre>

<h3 id="Default__Warn">Debuggen</h3>
<p>Standardmäßig bewirkt der Aufruf eines objektlosen Wertes, dass eine Ausnahme ausgelöst wird. Das folgende Beispiel ändert das Verhalten, so dass eine Warnung angezeigt und dann das Skript fortgesetzt wird:</p>
<pre>"".base.__Get := "".base.__Set := "".base.__Call := Func("Default__Warn")

empty_var.foo := "bar"
x := (1 + 1).is("integer")

Default__Warn(nonobj, p1:="", p2:="", p3:="", p4:="")
{
    ListLines
    MsgBox "Ein objektloser Wert wurde unsachgemäß aufgerufen.`n`nSpeziell: " nonobj
    return "" <em>; Überschreibt das Standardverhalten durch explizites Returning.</em>
}</pre>

<h2 id="Implementation">Implementierung</h2>
<span id="Refs"></span><h3 id="Reference_Counting">Referenzzählung</h3>
<p>AutoHotkey verwendet einen einfachen Referenzzählungsmechanismus, um automatisch Ressourcen freizugeben, falls ein Objekt nicht länger in einem Skript benötigt bzw. verwiesen wird. Skript-Autoren sollten diesen Mechanismus nicht explizit aufrufen, es sei denn, sie müssen sich direkt mit unverwalteten <a href="#Implementation_Pointers">Objekt-Pointern</a> befassen.</p>
<p>Temporär zurückgegebene Referenzen von Funktionen, Methoden oder Operatoren innerhalb eines Ausdrucks werden erst freigegeben, wenn die Auswertung dieses Ausdrucks abgeschlossen oder abgebrochen wurde. Dadurch können temporäre Objekte für die Ressourcenverwaltung verwendet werden. Zum Beispiel:</p>
<pre>MsgBox <a href="commands/DllCall.htm">DllCall</a>("GlobalSize", "ptr", (new <a href="#GMem">GMem</a>(0, 20)), "ptr")  <em>; 20</em></pre>
<p>Um eine Aktion nach Freigabe der letzten Referenz zu einem Objekt durchzuführen, implementiert man die <a href="#Custom_NewDelete">__Delete</a>-Metafunktion.</p>
<p><b>Bekannte Einschränkungen:</b></p>
<ul>
  <li>Zirkelbezüge müssen unterbrochen werden, bevor ein Objekt freigegeben werden kann. Siehe <a href="#Circular_References">Freigeben von Objekten</a>, um anhand eines Beispiels mehr darüber zu erfahren.</li>
  <li>Im Gegensatz zu Referenzen in statischen und globalen Variablen werden Referenzen in nicht-statischen lokalen Variablen oder im Ausdrucksauswertungsstapel nicht automatisch freigegeben, sobald das Programm beendet wird. Solche Referenzen werden nur freigegeben, wenn die Funktion oder der Ausdruck regulär beendet werden kann.</li>
</ul>
<p>Obwohl das Betriebssystem den vom Objekt benutzten Speicher zurückfordert, sobald das Programm beendet wird, kann <a href="#Custom_NewDelete">__Delete</a> erst aufgerufen werden, wenn alle Referenzen zum Objekt freigegeben worden sind. Das kann wichtig sein, wenn andere Ressourcen freigegeben werden, die nicht automatisch vom Betriebssystem zurückgefordert werden, wie zum Beispiel temporäre Dateien.</p>

<span id="AddressCast"></span><h3 id="Implementation_Pointers">Objekt-Pointer</h3>
<p>In einigen seltenen Fällen ist es eventuell erforderlich, dass ein Objekt via DllCall an einen externen Code übergeben werden muss, oder dass ein Objekt in eine binäre Datenstruktur gespeichert werden muss, damit es später abgerufen werden kann. Die Adresse eines Objekts kann via <code>Adresse := &amp;Objekt</code> abgerufen werden; dies würde allerdings effektiv zwei Referenzen zum Objekt erzeugen, während das Programm selbst nur die eine Referenz in <em>Objekt</em> kennt. Das Objekt wird gelöscht, sobald die letzte <em>bekannte</em> Referenz zum Objekt freigegeben wird. Demzufolge muss das Skript das Objekt darüber informieren, dass es eine Referenz erhalten hat. Dies kann man wie folgt erreichen:</p>
<pre><a href="commands/ObjAddRef.htm">ObjAddRef</a>(Adresse := &amp;Objekt)</pre>
<p>Außerdem muss das Objekt informiert werden, wenn das Skript mit dieser Referenz fertig ist:</p>
<pre><a href="commands/ObjAddRef.htm">ObjRelease</a>(Adresse)</pre>
<p>Generell sollte jede neue Kopie einer Objektadresse als separate Referenz zum Objekt behandelt werden, demzufolge sollte das Skript ObjAddRef aufrufen, wenn es eine Kopie erhält, und sofort ObjRelease aufrufen, bevor es eine verliert. Zum Beispiel sollte immer ObjAddRef aufgerufen werden, wenn eine Adresse mit so etwas wie <code>x := Adresse</code> kopiert wird. Ebenso sollte das Skript ObjRelease aufrufen, wenn es mit <em>x</em> fertig ist (oder dabei ist den Wert von <em>x</em> zu überschreiben).</p>
<p>Mit der Object-Funktion kann eine Adresse in eine geeignete Referenz umgewandelt werden:</p>
<pre>MeinObjekt := Object(Adresse)</pre>
<p>Beachten Sie, dass die Object-Funktion sogar auf Objekte angewendet werden kann, die sie selbst nicht erstellt hat, wie z. B. <a href="commands/ComObjCreate.htm">COM-Objekt-Wrapper</a> oder <a href="objects/File.htm">File-Objekte</a>.</p>

</body>
</html>
