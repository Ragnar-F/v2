<!DOCTYPE HTML>
<html>
<head>
<title>Objekte</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="robots" content="noindex, nofollow">
<link href="static/theme.css" rel="stylesheet" type="text/css" />
<script src="static/content.js" type="text/javascript"></script>
<script src="static/ga.js" type="text/javascript"></script>
<style>
ul.list_of_p p { margin: 0.5em 0; }
ul.list_of_p li { margin: 1em 0; }
</style>
</head>
<body>

<h1>Objekte</h1>

<p>Ein <i>Objekt</i> ist in AutoHotkey ein abstrakter Datentyp, das drei Grundfunktionen bereitstellt:</p>
<ul>
  <li>GET - Abrufen eines Wertes.</li>
  <li>SET - Setzen eines Wertes.</li>
  <li>CALL - Aufrufen einer Methode (eine Funktion, die das Zielobjekt beeinflusst).</li>
</ul>
<p>Ein Objekt<i>verweis</i> ist ein Pointer oder Handle, der auf ein bestimmtes Objekt verweist. Objektverweise können, wie Zeichenketten und Zahlen auch, in Variablen gespeichert werden, an Funktionen übergeben oder von Funktionen zurückgegeben werden und in Objekten gespeichert werden. Hat man einen Verweis von einer Variable in einer anderen gespeichert (z. B. mit <code>x := y</code>), würden beide Variablen auf das gleiche Objekt verweisen.</p>

<p>Mit <b>IsObject</b> kann festgestellt werden, ob ein Wert ein Objekt ist:</p>
<pre>Ergebnis := IsObject(<i>Ausdruck</i>)</pre>

<p>Es gibt folgende Objekttypen:</p>
<ul>
  <li><a href="objects/Object.htm"><b>Object</b></a> - skriptfähiges assoziatives Array.</li>
  <li><a href="objects/File.htm">File</a> - stellt eine Schnittstelle für die Dateibearbeitung bereit.</li>
  <li><a href="objects/Functor.htm">Funktionsobjekte</a> - <a href="objects/Func.htm">Func</a>, <a href="objects/Functor.htm#BoundFunc">BoundFunc</a> oder <a href="objects/Functor.htm#User-Defined">benutzerdefiniert</a>.</li>
  <li><a href="commands/ComObjCreate.htm">ComObject</a> - Wrappt eine IDispatch-Schnittstelle (ein COM oder "Automatisierungsobjekt").</li>
</ul>

<h2>Inhaltsverzeichnis</h2>
<ul>
  <li><a href="#Usage">Grundlagen</a> - <a href="#Usage_Simple_Arrays">Einfache Arrays</a>, <a href="#Usage_Associative_Arrays">Assoziative Arrays</a>, <a href="#Usage_Objects">Objekte</a>, <a href="#Usage_Freeing_Objects">Freigeben von Objekten</a>, <a href="#Usage_Remarks">Bemerkungen</a></li>
  <li><a href="#Extended_Usage">Erweiterte Grundlagen</a> - <a href="#Function_References">Funktionsverweise</a>, <a href="#Usage_Arrays_of_Arrays">Mehrdimensionale Arrays</a>, <a href="#Usage_Arrays_of_Functions">Arrays mit Funktionen</a></li>
  <li><a href="#Custom_Objects">Benutzerdefinierte Objekte</a> - <a href="#Custom_Prototypes">Prototypen</a>, <a href="#Custom_Classes">Klassen</a>, <a href="#Custom_NewDelete">Konstruktion und Destruktion</a>, <a href="#Meta_Functions">Meta-Funktionen</a></li>
  <li><a href="#Default_Base_Object">Standard-base-Objekt</a> - <a href="#Automatic_Var_Init">Automatische Variableninitialisierung</a>, <a href="#Pseudo_Properties">Pseudo-Eigenschaften</a>, <a href="#Default__Warn">Debugging</a></li>
  <li><a href="#Implementation">Implementierung</a> - <a href="#Reference_Counting">Referenzzählung</a>, <a href="#Implementation_Pointers">Pointer auf Objekte</a></li>
</ul>

<span id="Syntax"></span><h2 id="Usage">Grundlagen</h2>

<h3 id="Usage_Simple_Arrays">Einfache Arrays</h3>
<p>Erstellen eines Arrays:</p>
<pre>Array := [Element1, Element2, ..., ElementN]
Array := Array(Element1, Element2, ..., ElementN)</pre>
<p>Abrufen eines Elements:</p>
<pre>Wert := Array[Index]</pre>
<p>Zuweisen eines Elements:</p>
<pre>Array[Index] := Wert</pre>
<p>Einfügen beliebig vieler Elemente ab einem bestimmten Index:</p>
<pre>Array.<a href="objects/Object.htm#InsertAt">InsertAt</a>(Index, Wert, Wert2, ...)</pre>
<p>Anfügen eines oder von mehreren Elementen:</p>
<pre>Array.<a href="objects/Object.htm#Push">Push</a>(Wert, Wert2, ...)</pre>
<p>Entfernen eines Elements:</p>
<pre>EntfernterWert := Array.<a href="objects/Object.htm#RemoveAt">RemoveAt</a>(Index)</pre>
<p>Entfernen des letzten Elements:</p>
<pre>EntfernterWert := Array.<a href="objects/Object.htm#Pop">Pop</a>()</pre>
<p>Sofern Array nicht leer ist, können <a href="objects/Object.htm#MinMaxIndex">MinIndex</a> und <a href="objects/Object.htm#MinMaxIndex">MaxIndex</a>/<a href="objects/Object.htm#Length">Length</a> den niedrigsten und höchsten Index des Arrays zurückgeben. Während der niedrigste Index fast immer 1 ist, wird MaxIndex üblicherweise die Anzahl der Elemente zurückgeben. Sind aber keine Integer-Keys vorhanden, gibt MaxIndex eine leere Zeichenkette zurück, während Length eine 0 zurückgibt. Um die Inhalte des Arrays zu durchlaufen, benutzt man entweder den Index oder eine For-Schleife. Zum Beispiel:</p>
<pre>array := ["eins", "zwei", "drei"]

<em>; Durchläuft das Array von 1 bis zu seinem Ende:</em>
<a href="commands/Loop.htm">Loop</a> % array.Length()
    MsgBox % array[A_Index]

<em>; Enumeriert die Inhalte des Arrays:</em>
<a href="commands/For.htm">For</a> index, wert in array
    MsgBox % "Element " index " ist '" wert "'"
</pre>

<span id="Arrays"></span><h3 id="Usage_Associative_Arrays">Assoziative Arrays</h3>
<p>Ein assoziatives Array ist ein Objekt, das mehrere eindeutige Keys (Schlüssel) und mehrere Values (Werte) enthält, die jeweils miteinander verbunden sind. Keys können Zeichenketten, Integer oder Objekte sein. Values beliebige Typen. Ein assoziatives Array kann wie folgt erstellt werden:</p>
<pre>Array := {KeyA: ValueA, KeyB: ValueB, ..., KeyZ: WertZ}
Array := Object("KeyA", ValueA, "KeyB", ValueB, ..., "KeyZ", ValueZ)</pre>
<p>Wenn man die <code>{Key:Value}</code>-Schreibweise verwendet, können die Anführungszeichen beim Key weggelassen werden, sofern dieser nur aus Wortzeichen besteht. Jeder Ausdruck kann als Key verwendet werden. Um eine Variable als Key zu benutzen, muss es mit runden Klammern umschlossen werden. Zum Beispiel wäre sowohl <code>{(KeyVar): Value}</code> als auch <code>{GetKey(): Value}</code> eine gültige Angabe.</p>
<p>Abrufen eines Elements:</p>
<pre>Value := Array[Key]</pre>
<p>Zuweisen eines Elements:</p>
<pre>Array[Key] := Value</pre>
<p>Entfernen eines Elements:</p>
<pre>EntfernterWert := Array.<a href="objects/Object.htm#Delete">Delete</a>(Key)</pre>
<p>Enumerieren von Elementen:</p>
<pre>array := {zehn: 10, zwanzig: 20, dreißig: 30}
<a href="commands/For.htm">For</a> key, value in array
    MsgBox %key% = %value%</pre>
<p>Assoziative Arrays können lückenhaft gefüllt werden - zum Beispiel enthält <code>{1: "a", 1000: "b"}</code> nur zwei Key-Value-Paare, nicht 1000.</p>
<p id="same_thing">In AutoHotkey v1.x sind einfache Arrays und assoziative Arrays das gleiche. Das Behandeln von <code>[]</code> als einfaches lineares Array stellt sicher, dass dessen Rolle eindeutig zugeordnet werden kann, und erhöht die Chance, dass dein Skript auch mit einer zukünftigen Version von AutoHotkey noch funktionieren wird, wo vielleicht zwischen einfachem und assoziativem Array unterschieden wird.</p>

<h3 id="Usage_Objects">Objekte</h3>
<p>Bei allen Objekttypen kann die Schreibweise <code>Objekt.LiteralerKey</code> benutzt werden, um auf eine Eigenschaft, ein Array oder eine Methode zuzugreifen. Hierbei muss <em>LiteralerKey</em> ein Identifier oder Integer sein, und <em>Objekt</em> ein beliebiger Ausdruck. Identifiers (Bezeichner) sind Zeichenketten ohne Anführungszeichen, die aus alphanumerischen Zeichen, Unterstrich und Nicht-ASCII-Zeichen bestehen können. Zum Beispiel wäre <code>match.Pos</code> das gleiche wie <code>match["Pos"]</code>, oder <code>arr.1</code> das gleiche wie <code>arr[1]</code>. Es darf kein Leerzeichen nach dem Punkt erfolgen.</p>
<p><strong>Beispiele:</strong></p>
<p>Abrufen einer Eigenschaft:</p>
<pre>Wert := Objekt.Eigenschaft</pre>
<p>Setzen einer Eigenschaft:</p>
<pre>Objekt.Eigenschaft := Wert</pre>
<p>Aufrufen einer Methode:</p>
<pre>Rückgabewert := Objekt.Methode(Parameter)</pre>
<p>Aufrufen einer Methode mit einem errechneten Methodennamen:</p>
<pre>Rückgabewert := Object[Methodenname](Parameter)</pre>
<p>Einige Eigenschaften von COM-Objekten und benutzerdefinierten Objekten können Parameter akzeptieren:</p>
<pre>Wert := Objekt.Eigenschaft[Parameter]
Objekt.Eigenschaft[Parameter] := Wert</pre>
<p><strong>Siehe auch</strong>: <a href="objects/Object.htm">Objekt</a>, <a href="objects/File.htm">File-Objekt</a>, <a href="objects/Func.htm">Func-Objekt</a>, <a href="commands/ComObjCreate.htm">COM-Objekt</a></p>
<p><b>Bekannte Einschränkung:</b></p>
<ul><li>Zurzeit wird <code><span class="dull">x</span>.y[z]<span class="dull">()</span></code> als <code><span class="dull">x</span>["y", z]<span class="dull">()</span></code> behandelt, was aber nicht unterstützt wird. Als Übergangslösung kann man <code><span class="red">(</span><span class="dull">x.y</span><span class="red">)</span>[z]()</code> benutzen, das <code>x.y</code>  zuerst auswerten und dann das Ergebnis als Ziel des Methodenaufrufs verwenden würde. Beachte, dass <code>x.y[z].Call()</code> diese Einschränkung nicht hat, weil es genauso wie <code>(x.y[z]).Call()</code> ausgewertet wird.</li></ul>

<h3 id="Usage_Freeing_Objects">Freigeben von Objekten</h3>
<p>Skripte geben Objekte nicht explizit frei. Sobald der letzte Verweis auf ein Objekt freigegeben ist, wird das Objekt automatisch freigegeben. Ein Verweis, der in einer Variable gespeichert ist, wird automatisch freigegeben, wenn diese Variable irgendeinen anderen Wert zugewiesen bekommt. Zum Beispiel:</p>
<pre>obj := {}  <em>; Erstellt ein Objekt.</em>
obj := ""  <em>; Gibt den letzten Verweis frei, wodurch das Objekt freigegeben wird.</em></pre>
<p>In diesem Zusammenhang wird ein Verweis, der in einem Feld eines anderen Objekts gespeichert ist, freigegeben, wenn dieses Feld irgendeinen anderen Wert zugewiesen bekommt oder vom Objekt entfernt wird. Dies gilt auch für Arrays, weil sie eigentlich Objekte sind.</p>
<pre>arr := [{}]  <em>; Erstellt ein Array, das ein Objekt enthält.</em>
arr[1] := {}  <em>; Erstellt ein zweites Objekt, wodurch das erste Objekt indirekt freigegeben wird.</em>
arr.RemoveAt(1)  <em>; Entfernt und gibt das zweite Objekt frei.</em></pre>
<p id="Circular_References">Da alle Verweise auf ein Objekt freigegeben werden müssen, bevor das Objekt freigegeben werden kann, können Objekte mit Zirkelbezügen nicht automatisch freigegeben werden. Wenn beispielsweise <code>x.child</code> auf <code>y</code> verweist und <code>y.parent</code> auf <code>x</code> verweist, würde es nicht genügen, <code>x</code> und <code>y</code> zu leeren, weil das Parent-Objekt noch einen Verweis auf das Child-Objekt enthält, und umgekehrt. Um diese Situation in den Griff zu bekommen, muss der Zirkelbezug entfernt werden.</p>
<pre>
x := {}, y := {}             <em>; Erstellt zwei Objekte.</em>
x.child := y, y.parent := x  <em>; Erstellt ein Zirkelbezug.</em>

y.parent := ""               <em>; Der Zirkelbezug muss entfernt werden, bevor die Objekte freigegeben werden können.</em>
x := "", y := ""             <em>; Ohne die obige Zeile würde dies hier die Objekte nicht freigeben.</em>
</pre>
<p>Für mehr Details, siehe <a href="#Reference_Counting">Referenzzählung</a>.</p>

<h3 id="Usage_Remarks">Bemerkungen</h3>

<h4>Syntax</h4>
<p>Alle Objektarten unterstützen sowohl die Array-Syntax (eckige Klammern) als auch die Objekt-Syntax (Punkte).</p>
<p>Darüber hinaus können Objektverweise auch in Ausdrücken verwendet werden:</p>
<ul>
  <li>Vergleicht man ein Objektverweis mit irgendeinem anderen Wert per <code>= == != &lt;&gt;</code>, werden sie nur als gleich angesehen, wenn beide Werte auf dasselbe Objekt verweisen.</li>
  <li>Objekte werden immer als <i>True</i> angesehen, falls ein logischer Wert erforderlich ist, wie z. B. in <code>if obj</code>, <code>!obj</code> oder <code>obj ? x : y</code>.</li>
  <li>Eine Objektadresse kann mithilfe des <code>&amp;</code>-Operators abgerufen werden. So eine Adresse identifiziert eindeutig das Objekt - von seiner Erstellung bis zur letzten <a href="#Refs">Freigabe</a> seines Verweises.</li>
</ul>
<p>Dort, wo ein Objekt nicht erwartet wird, wird das Objekt als leere Zeichenkette angesehen. Zum Beispiel würde <code>MsgBox %objekt%</code> eine leere MsgBox anzeigen und <code>objekt + 1</code> eine leere Zeichenkette zurückgeben. Verlasse dich nicht auf dieses Verhalten, weil es noch geändert werden könnte.</p>
<p>Ein Zuweisungsoperator unmittelbar nach einem Methodenaufruf ist das gleiche wie, als würde man eine Eigenschaft mit Parametern setzen. Zum Beispiel bewirken beide Zeilen dasselbe:</p>
<pre>obj.item(x) := y
obj.item[x] := y</pre>
<p id="cassign">Verbundzuweisungen wie <code>x.y += 1</code> und <code>--arr[1]</code> werden unterstützt.</p>
<p>Parameter können beim Abrufen oder Setzen von Eigenschaften weggelassen werden. Zum Beispiel <code>x[,2]</code>. Skripte können dies nutzen, indem sie Standardwerte für Parameter in <a href="#Custom_Classes_property">Eigenschaften</a> und <a href="#Meta_Functions">Meta-Funktionen</a> definieren. Den Methodennamen kann man zudem komplett weglassen, wie z. B. in <code>x[](a)</code>. Skripte können dies nutzen, indem sie einen Standardwert für den ersten Parameter der __Call-<a href="#Meta_Functions">Meta-Funktion</a> definieren, da er sonst nicht im Wert enthalten wäre. Wenn man den Eigenschafts- oder Methodennamen beim Aufrufen eines COM-Objekts weglässt, wird sein "Standardelement" aufgerufen.</p>

<h4>Keys</h4>
<p>Objekte, die mit <code>[]</code>, <code>{}</code> oder dem <code>new</code>-Operator erstellt wurden, erlauben den Einsatz von Zeichenketten, Integern und Objekten als Keys, aber mit folgenden Einschränkungen:</p>
<p>Der Wert des Keys wird beibehalten, aber nicht seine <em>Typenidentität</em>. Das heißt, dass Integer als Zeichenketten abgespeichert werden könnten oder umgekehrt, solange der Wert der gleiche bleibt (einschließlich der Formatierung von numerischen Zeichenketten). Im Einzelnen:</p>
<ul>
  <li>Integer-Keys werden unter Verwendung des nativen vorzeichenbehafteten Integer-Typs gespeichert, sofern möglich. Integer, die kleiner als -2147483648 oder größer als 2147483647 sind, werden in der 32-Bit-Version von AutoHotkey als Zeichenketten und in der 64-Bit-Version als Integer abgespeichert. (64-Bit-Integer können hingegen in jeder Version als Wert abgespeichert werden.)</li>
  <li>Wenn eine Zeichenkette in einen Integer (vom nativen vorzeichenbehafteten Integertyp) und dann wieder in eine Zeichenkette ohne Datenverlust umgewandelt werden kann, wird sie als Integer abgespeichert. Das heißt, dass <code>x[16]</code> und <code>x["16"]</code> identisch sind, aber nicht <code>x["0016"]</code> oder <code>x["0x10"]</code>. Allerdings wären <code>x[0x10]</code> und <code>x["16"]</code> auch identisch, da numerische Literale während der Ladezeit in reine Zahlen umgewandelt werden.</li>
  <li>Gleitkommazahlen werden nicht als Keys unterstützt - stattdessen werden sie in Zeichenketten umgewandelt. Um Widersprüche zu vermeiden und die Verständlichkeit zu verbessern, sollte man verhindern, literale Gleitkommazahlen als Keys zu verwenden.</li>
</ul>
<p>Einige Zeichenketten sollten nicht als Keys verwendet werden:</p>
<ul>
  <li>Standardmäßig kann mit dem Zeichenketten-Key "base" das <a href="#Custom_Objects">base-Objekt</a> des Objekts abgerufen oder gesetzt werden, und wäre demzufolge nicht dazu geeignet, gewöhnliche Werte mithilfe einer normalen Zuweisung abzuspeichern. Wenn ein Wert allerdings auf andere Weise abgespeichert wird (z. B. <code><a href="objects/Object.htm#RawSet">ObjRawSet</a>(Object, "base", "")</code> oder <code><a href="objects/Object.htm#SetCapacity">Object.SetCapacity</a>("base", 0)</code>, wird sich der base-Key wie eine beliebige Zeichenkette verhalten.</li>
  <li><a href="objects/Object.htm">Built-In-Methoden</a> wie "Length" können als Keys verwendet werden, aber sobald man einen Wert in sie speichert, verlieren sie ihre ursprüngliche Funktion (es sei denn, dieser Wert selbst verweist auf die entsprechende Funktion, wie z. B. <em>ObjLength</em>).</li>
</ul>

<h2 id="Extended_Usage">Erweiterte Grundlagen</h2>
<h3 id="Function_References">Funktionsverweise</h3>
<p>Enthält die Variable <i>funk</i> einen Funktionsnamen, kann die Funktion mit dem Ausdruck  <code><a href="Functions.htm#DynCall">%funk%()</a></code> aufgerufen werden. Allerdings muss dabei die Funktion jedes Mal neu aufgelöst werden. Sobald die Funktion mehr als einmal aufgerufen wird, würde die Effizienz darunter leiden. Zur Verbesserung der Performance speichert man den Funktionsverweis in eine Variable, um sie später wiederzuverwenden:</p>
<pre>MeinFunkVerweis := Func("MeineFunk")</pre>
<p>Eine Funktion kann mithilfe der folgenden Syntax per Verweis aufgerufen werden:</p>
<pre>
RückWert := <a href="Functions.htm#DynCall">%MeinFunkVerweis%</a>(<i>Params</i>)
RückWert := MeinFunkVerweis.<a href="objects/Func.htm#Call">Call</a>(<i>Params</i>)
</pre>
<p>Um mehr über zusätzliche Eigenschaften von Funktionsverweisen zu erfahren, siehe <a href="objects/Func.htm">Func-Objekt</a>.</p>

<span id="JaggedArrays"></span><h3 id="Usage_Arrays_of_Arrays">Mehrdimensionale Arrays</h3>
<p>AutoHotkey unterstützt "mehrdimensionale" Arrays - das sind Arrays innerhalb von anderen Arrays. Eine Tabelle beispielsweise könnte man als Array mit Reihen ansehen, bei dem jede Reihe ein Array mit Spalten ist. In diesem Fall kann der Inhalt der Spalte <code>y</code> von der Reihe <code>x</code> mit einer der folgenden Methoden gesetzt werden:</p>
<pre>Tabelle[x][y] := Inhalt  <em>; A</em>
Tabelle[x, y] := Inhalt  <em>; B</em></pre>
<p>Wenn <code>Tabelle[x]</code> nicht vorhanden ist, unterscheiden sich <span class="Code"><em>A</em></span> und <span class="Code"><em>B</em></span> wie folgt:</p>
<ul>
  <li><span class="Code"><em>A</em></span> schlägt fehl, während <span class="Code"><em>B</em></span> automatisch ein Objekt erstellt und es in <code>Tabelle[x]</code> speichert.</li>
  <li>Wenn  <code>Tabelle</code>'s <a href="#Custom_Objects">base</a> <a href="#Meta_Functions">Meta-Funktionen</a> bereitstellt, werden sie wie folgt aufgerufen:
  <pre>Tabelle.base.__Get(Tabelle, x)<span class="dull">[y] := Inhalt</span>   <em>; A</em>
Tabelle.base.__Set(Tabelle, x, y, Inhalt)     <em>; B</em></pre>
  Folglich kann durch <span class="Code"><em>B</em></span> das Objekt ein benutzerdefiniertes Verhalten für die gesamte Zuweisung definieren.</li>
</ul>
<p>Mehrdimensionale Zuweisungen wie <code>Tabelle[a, b, c, d] := Wert</code> werden wie folgt behandelt:</p>
<ul>
  <li>Bleibt nur ein Key übrig, führe die Zuweisung durch und gebe sie zurück. Ansonsten:</li>
  <li>Suche im Objekt den ersten Key in der Liste.</li>
  <li>Wenn ein Nicht-Objekt gefunden wird, schlage fehl (löse eine Ausnahme aus).</li>
  <li>Wenn kein Objekt gefunden wird, erstelle eines und speichere es.</li>
  <li>Rufe das Unterobjekt rekursiv auf und übergebe die restlichen Keys und Values - beginne wieder von oben.</li>
</ul>
<p>Dieses Verhalten gilt nur für skript-erstellte Objekte, nicht für spezielle Objekttypen wie COM-Objekte oder COM-Arrays.</p>

<span id="FuncArrays"></span><h3 id="Usage_Arrays_of_Functions">Arrays mit Funktionen</h3>
<p>Ein Array mit Funktionen ist im Prinzip ein Array, das Funktionsnamen oder Verweise enthält. Zum Beispiel:</p>
<pre>array := [Func("ErsteFunk"), Func("ZweiteFunk")]

<em>; Ruft jede Funktion auf und übergibt "foo" als Parameter:</em>
Loop 2
    array[A_Index].Call("foo")

<em>; Ruft jede Funktion auf und übergibt indirekt das Array selbst als Parameter:</em>
Loop 2
    array[A_Index]()

ErsteFunk(Parameter) {
    MsgBox % A_ThisFunc ": " (IsObject(Parameter) ? "Objekt" : Parameter)
}
ZweiteFunk(Parameter) {
    MsgBox % A_ThisFunc ": " (IsObject(Parameter) ? "Objekt" : Parameter)
}</pre>

<h2 id="Custom_Objects">Benutzerdefinierte Objekte</h2>
<p>Objekte, die vom Skript erstellt wurden, müssen nicht zwingend eine vordefinierte Struktur haben. Stattdessen kann jedes Objekt Eigenschaften und Methoden von seinem <code>base</code>-Objekt (auch bekannt als "Prototyp" oder "Klasse") erben. Bei einem Objekt kann man jederzeit Eigenschaften und Methoden hinzufügen oder entfernen. Solche Änderungen haben auch Auswirkung auf alle abgeleiteten Objekte. Bei komplexeren oder spezielleren Situationen kann das base-Objekt das Standardverhalten überschreiben, indem es <a href="#Meta_Functions"><i>Meta-Funktionen</i></a> definiert.</p>
<p><em>Base</em>-Objekte sind ganz normale Objekte, die mit den folgenden zwei Möglichkeiten erstellt werden können:</p>
<pre>class baseObject {
    static foo := "bar"
}
<em>; OR</em>
baseObject := {foo: "bar"}</pre>
<p>Um ein Objekt zu erstellen, das von einem anderen Objekt abgeleitet wurde, können Skripte die <code>base</code>-Eigenschaft zuweisen oder das <a href="#Custom_NewDelete"><code>new</code>-Schlüsselwort</a> verwenden:</p>
<pre>obj1 := Object(), obj1.base := baseObject
obj2 := {base: baseObjekt}
obj3 := new baseObjekt
MsgBox % obj1.foo " " obj2.foo " " obj3.foo</pre>
<p>Es ist jederzeit möglich, einem Objekt ein neues <code>base</code> zuzuweisen, das alle Eigenschaften und Methoden ersetzen würde, die das Objekt geerbt hat.</p>

<h3 id="Custom_Prototypes">Prototypen</h3>
<p>Prototypen oder <code>base</code>-Objekte können konstruiert und manipuliert werden, wie jedes andere Objekt auch. Zum Beispiel könnte ein gewöhnliches Objekt mit einer Eigenschaft und einer Methode wie folgt konstruiert werden:</p>
<pre><em>; Erstellt ein Objekt.</em>
obj := {}
<em>; Speichert einen Wert.</em>
obj.foo := "bar"
<em>; Erstellt eine Methode durch Speichern eines Funktionsverweises.</em>
obj.test := Func("obj_test")
<em>; Ruft die Methode auf.</em>
obj.test()

obj_test(this) {
   MsgBox % this.foo
}</pre>
<p>Ruft man <code>obj.test()</code> auf, wird <i>obj</i> automatisch an den Anfang der Parameterliste gesetzt. Üblicherweise benennt man die Funktion nach dem Objekttypen und dem Methodennamen.</p>
<p>Ein Objekt ist ein <i>Prototyp</i> oder <i>base</i>, wenn ein anderes Objekt davon abgeleitet wurde:</p>
<pre>obj2 := {}
obj2.base := obj
obj2.test()</pre>
<p>In diesem Fall würde <i>obj2</i> das <i>foo</i> und <i>test</i> von <i>obj</i> erben. Diese Vererbung ist dynamisch - würde man <code>obj.foo</code> ändern, wäre die Änderung auch bei <code>obj2.foo</code> bemerkbar. Wenn das Skript <code>obj2.foo</code> einen Wert zuweist, wird dieser Wert in <i>obj2</i> gespeichert; weitere Änderungen an <code>obj.foo</code> hätten keinen Einfluss auf <code>obj2.foo</code>. Ruft man <code>obj2.test()</code> auf, würde dessen <i>this</i>-Parameter einen Verweis auf <i>obj2</i> statt auf <i>obj</i> enthalten.
</p>

<h3 id="Custom_Classes">Klassen</h3>
<p>Im Grunde ist eine "Klasse" eine Reihe oder Kategorie von Dingen, die einige Eigenschaften oder Attribute haben. Da ein <a href="#Custom_Objects">Base</a>- oder <a href="#Custom_Prototypes">Prototyp</a>-Objekt Eigenschaften und Verhaltensweisen für eine Reihe von Objekten definiert, kann man es auch als <em>Klassen</em>objekt bezeichnen. Der Einfachheit halber können Base-Objekte wie folgt mithilfe des Schlüsselworts "class" definiert werden:</p>
<pre>class Klassenname extends BaseKlassenname
{
    InstanzVar := Ausdruck
    static KlassenVar := Ausdruck

    class VerschachtelteKlasse
    {
        ...
    }

    Methode()
    {
        ...
    }

    Eigenschaft[]  <em>; Die eckigen Klammern sind optional</em>
    {
        get {
            return ...
        }
        set {
            return ... := Wert
        }
    }
}
</pre>
<p>Beim Laden des Skripts würde mit diesem Beispiel ein Objekt konstruiert und in die <a href="Functions.htm#SuperGlobal">superglobale</a> Variable <i>Klassenname</i> gespeichert werden. Wenn <code>extends BaseKlassenname</code> vorhanden ist, muss der <i>BaseKlassenname</i> der vollständige Name einer anderen Klasse sein, aber die Reihenfolge, in der sie definiert werden, spielt keine Rolle. Der vollständige Name jeder Klasse ist in <code><i>objekt</i>.__Class</code> gespeichert.</p>
<p>Innerhalb dieser Dokumentation bedeutet das Wort "Klasse" in der Regel ein Klassenobjekt, das mit dem Schlüsselwort <code>class</code> erstellt wurde.</p>
<p>Klassendefinitionen können Variablendeklarationen, Methodendefinitionen und Unterklassendefinitionen enthalten.</p>

<h4 id="Custom_Classes_var">Instanzvariablen</h4>
<p>Eine <em>Instanzvariable</em> ist eine Variable, von der jede Instanz der Klasse (also jedes abgeleitete Objekt der Klasse) eine eigene Kopie hat. Sie werden wie normale Zuweisungen deklariert, aber ohne dem Präfix <code>this.</code> (nur direkt innerhalb der Klasse):</p>
<pre>InstanzVar := Ausdruck</pre>
<p>Solche Deklarationen werden jedes Mal ausgewertet, wenn eine neue Instanz der Klasse mit dem <a href="#Custom_NewDelete">new</a>-Schlüsselwort erstellt wird. Der Methodenname <code>__Init</code> ist für diesen Zweck reserviert, und sollte nicht im Skript verwendet werden. Die <a href="#Custom_NewDelete">__New()</a>-Methode wird aufgerufen, sobald alle Deklarationen dieser Art (auch solche, die in base-Klassen definiert wurden) ausgewertet worden sind. <em>Ausdruck</em> kann mit <code>this</code> auf andere Instanzvariablen und Methoden zugreifen, aber alle anderen Variablenverweise werden als global angesehen.</p>
<p>Um auf eine Instanzvariable zugreifen zu können, muss immer das Zielobjekt angegeben werden; zum Beispiel <code><b>this</b>.InstanzVar</code>.</p>
<p>Deklarationen wie <code>x.y := z</code> werden auch unterstützt, sofern <code>x</code> zuvor in dieser Klasse deklariert wurde. <code>x := {}, x.y := 42</code> würde beispielsweise <code>x</code>  deklarieren und außerdem <code>this.x.y</code> initialisieren.</p>

<h4 id="Custom_Classes_staticvar">Statische bzw. Klassenvariablen</h4>
<p>Statische bzw. Klassenvariablen gehören nur der Klasse selbst, aber sie können von abgeleiteten Objekten vererbt werden (einschließlich Unterklassen). Sie werden wie Instanzvariablen deklariert, aber unter Verwendung des static-Schlüsselworts:</p>
<pre>static KlassenVar := Ausdruck</pre>
<p>Statische Deklarationen werden nur einmal ausgewertet - bevor der <a href="Scripts.htm#auto">automatische Ausführungsbereich</a> erfolgt, und in der Reihenfolge, wie sie im Skript vorkommen. Jede Deklaration speichert einen Wert in das Klassenobjekt. Jeder Variablenverweis im <i>Ausdruck</i> wird als global angesehen.</p>
<p>Um etwas in eine Klassenvariable speichern zu können, muss immer das Klassenobjekt angegeben werden; zum Beispiel <code><b>Klassenname</b>.KlassenVar := Wert</code>. Wenn ein Objekt <em>x</em> von <em>Klassenname</em> abgeleitet wurde und wenn <em>x</em> selbst nicht den Key "KlassenVar" enthält, dann kann <code>x.KlassenVar</code> auch verwendet werden, dynamisch den Wert von <code>Klassenname.KlassenVar</code> abzurufen. Allerdings würde <code>x.KlassenVar := y</code> den Wert in <em>x</em> speichern, und nicht in <em>Klassenname</em>.</p>
<p>Deklarationen wie <code>static x.y := z</code> werden auch unterstützt, sofern <code>x</code> zuvor in dieser Klasse deklariert wurde. <code>static x := {}, x.y := 42</code> würde beispielsweise <code>x</code> deklarieren und außerdem <code><i>Klassenname</i>.x.y</code> initialisieren.</p>

<h4 id="Custom_Classes_class">Verschachtelte Klassen</h4>
<p>Verschachtelte Klassendefinitionen ermöglichen Klassenobjekte innerhalb von anderen Klassenobjekten, anstatt eine separate globale Variable verwenden zu müssen. Im obigen Beispiel würde <code>class VerschachtelteKlasse</code> ein Objekt konstruieren und es in <code>Klassenname.VerschachtelteKlasse</code> speichern. Unterklassen können <em>VerschachtelteKlasse</em> erben oder es mit ihrer eigenen verschachtelten Klasse überschreiben (in diesem Fall könnte mit <code>new this.VerschachtelteKlasse</code> eine Instanz unabhängig einer geeigneten Klasse erstellt werden).</p>
<pre>
class VerschachtelteKlasse
{
    ...
}
</pre>

<h4 id="Custom_Classes_method">Methoden</h4>
<p>Methodendefinitionen sehen genauso aus wie Funktionsdefinitionen. Jede Methode hat einen versteckten Parameter namens <code>this</code>, der üblicherweise einen Verweis auf ein Objekt enthält, das von der Klasse abgeleitet wurde. Allerdings könnte er auch einen Verweis auf die Klasse selbst oder auf eine abgeleitete Klasse enthalten, je nachdem, wie die Methode aufgerufen wurde. Methoden werden <a href="#Function_References">per Verweis</a> in das Klassenobjekt gespeichert.</p>
<pre>
Methode()
{
    ...
}
</pre>

<p id="Custom_Classes_base">Innerhalb einer Methode kann das Pseudo-Schlüsselwort <code>base</code> verwendet werden, um auf Super-Klassen-Versionen von Methoden zugreifen zu können, oder auf Eigenschaften, die in einer abgeleiteten Klasse überschrieben werden. Zum Beispiel würde <code>base.Methode()</code>, wenn man es in der Klasse oben definiert, eine Version von <em>Methode</em> aufrufen, die über <em>BaseKlassenname</em> definiert wurde. <a href="#Meta_Functions">Meta-Funktionen</a> werden nicht aufgerufen; ansonsten verhält sich <code>base.Methode()</code> wie <code>BaseKlassenname.Methode.Call(this)</code>. Das heißt,</p>
<ul>
  <li>dass <code>base.Methode()</code> immer dort das Base der Klasse aufruft, wo die aktuelle Methode definiert wurde, selbst wenn <code>this</code> von einer <em>Unterklasse</em> von dieser oder einer anderen Klasse vollständig abgeleitet ist.</li>
  <li>dass <code>base.Methode()</code> implizit <code>this</code> als ersten (versteckten) Parameter übergibt.</li>
</ul>
<p><code>base</code> hat nur eine besondere Bedeutung, wenn ein Punkt <code>.</code> oder eine eckige Klammer <code>[]</code> danach erfolgt. Deshalb wird so etwas wie <code>obj := base, obj.Methode()</code> nicht funktionieren. Skripte können das spezielle Verhalten von <i>base</i> deaktivieren, indem sie base einen nicht-leeren Wert zuweisen; dies wird jedoch nicht empfohlen.</p>

<h4 id="Custom_Classes_property">Eigenschaften</h4>
<p>Eigenschaftsdefinitionen erlauben das Ausführen einer Methode, wann immer das Skript einen spezifischen Key abruft oder setzt.</p>
<pre>Eigenschaft[]
{
    get {
        return ...
    }
    set {
        return ... := Wert
    }
}</pre>
<p><em>Eigenschaft</em> ist der Name der Eigenschaft, mit dem sie aufgerufen werden kann. <code>obj.Eigenschaft</code> würde beispielsweise <em>get</em> aufrufen, und <code>obj.Eigenschaft := Wert</code> würde <em>set</em> aufrufen. Innerhalb von  <em>get</em> oder <em>set</em> bezieht sich <code>this</code> auf das Objekt, das aufgerufen wird. Innerhalb von <em>set</em> enthält <code>Wert</code> den Wert, der zugewiesen wird.</p>
<p>Parameter können übergeben werden, indem man sie auf der rechten Seite des Eigenschaftsnamens in eckigen Klammern setzt, sowohl beim Definieren als auch beim Aufrufen der Eigenschaft. Abgesehen von der Verwendung eckiger Klammern werden Eigenschaftsparameter genauso wie Methodenparameter definiert - optionale, variadische und ByRef-Parameter werden unterstützt.</p>
<p>Der Rückgabewert von <em>get</em> oder <em>set</em> ist das Ergebnis des Unterausdrucks, der die Eigenschaft aufgerufen hat. Zum Beispiel würde <code>Wert := obj.Eigenschaft := 42</code> den Rückgabewert von <em>set</em> in <code>Wert</code> speichern.</p>
<p>Jede Klasse kann eine oder beide Hälften einer Eigenschaft definieren. Wenn eine Klasse eine Eigenschaft überschreibt, kann sie mit <code><a href="#Custom_Classes_base">base.Eigenschaft</a></code> auf die Eigenschaft, die über deren base-Klasse definiert wurde, zugreifen. Wenn <em>get</em> oder <em>set</em> nicht definiert ist, kann es über eine base-Klasse behandelt werden. Wenn <em>set</em> nicht definiert ist und nicht über eine Meta-Funktion oder base-Klasse behandelt wird, wird es beim Zuweisen eines Wertes in das Objekt gespeichert und die Eigenschaft deaktiviert.</p>
<p>Intern sind <em>get</em> und <em>set</em> zwei unterschiedliche Methoden, wodurch sie sich untereinander keine Variablen teilen können (außer sie werden in <code>this</code> gespeichert).</p>
<p><a href="#Meta_Functions">Meta-Funktionen</a> stellen eine breitere Auswahl an Möglichkeiten bereit, um auf Eigenschaften und Methoden eines Objekts zugreifen zu können, aber sie sind komplizierter und fehleranfällig.</p>

<h3 id="Custom_NewDelete">Konstruktion und Destruktion</h3>
<p>Immer wenn ein abgeleitetes Objekt mit dem Schlüsselwort <code>new</code> erstellt wird, wird die <code>__New</code>-Methode, definiert über das base-Objekt, aufgerufen. Diese Methode kann Parameter akzeptieren, das Objekt initialisieren und das Ergebnis des <code>new</code>-Operators durch Zurückgeben eines Wertes überschreiben. Zerstört man ein Objekt, wird <code>__Delete</code> aufgerufen. Zum Beispiel:</p>
<pre>m1 := new GMem(0, 20)
m2 := {base: GMem}.__New(0, 30)

<span id="GMem">class GMem</span>
{
    __New(aFlags, aGröße)
    {
        this.ptr := DllCall("GlobalAlloc", "uint", aFlags, "ptr", aGröße, "ptr")
        if !this.ptr
            return ""
        MsgBox % "New GMem mit einer Größe von " aGröße " Bytes auf der Adresse " this.ptr "."
        return this  <em>; Diese Zeile kann weggelassen werden, wenn der Operator 'new' verwendet wird.</em>
    }

    __Delete()
    {
        MsgBox % "Delete GMem auf der Adresse " this.ptr "."
        DllCall("GlobalFree", "ptr", this.ptr)
    }
}</pre>
<p>__Delete wird nicht bei Objekten aufgerufen, die den Key "__Class" haben. <a href="#Custom_Classes">Klassenobjekte</a> haben standardmäßig diesen Key.</p>

<h3 id="Meta_Functions">Meta-Funktionen</h3>
<pre class="Syntax">
<strong>Methodensyntax:</strong>
class <i>Klassenname</i> {
    __Get([Key, Key2, ...])
    __Set([Key, Key2, ...], Value)
    __Call(Name [, Parameter...])
}

<strong>Funktionssyntax:</strong>
<i>MeinGet</i>(this [, Key, Key2, ...])
<i>MeinSet</i>(this [, Key, Key2, ...], Value)
<i>MeinCall</i>(this, Name [, Parameter...])

<i>Klassenname</i> := { __Get: Func("<i>MeinGet</i>"), __Set: Func("<i>MeinSet</i>"), __Call: Func("<i>MeinCall</i>") }
</pre>
<p>Meta-Funktionen definieren, was passieren soll, wenn ein Key angefordert, aber nicht im Zielobjekt gefunden wird. Wenn <code>obj.key</code> beispielsweise leer wäre, würde es die <i>__Get</i>-Meta-Funktion aufrufen. Außerdem würde <code>obj.key := value</code> die Meta-Funktion <i>__Set</i> aufrufen und <code>obj.key()</code> die Meta-Funktion <i>__Call</i>. Diese Meta-Funktionen (oder Methoden) müssten in <code>obj.base</code>, <code>obj.base.base</code> oder ähnliches definiert werden.</p>
<p>Wenn das Skript einen nicht vorhandenen Key im Zielobjekt abruft (get), setzt (set) oder aufruft (call), wird das base-Objekt wie folgt aufgerufen:</p>
<ul class="list_of_p">
  <li>Definiert dieses base-Objekt die geeignete Meta-Funktion, rufe es auf. Wenn die Meta-Funktion explizit per <code>return</code> zurückgegeben wird, verwende den Rückgabewert als Ergebnis der Operation (was auch immer den Aufruf der Meta-Funktion verursacht hat) und übergebe die Kontrolle wieder an das Skript. Ansonsten mache weiter wie unten beschrieben.
    <p><i>Set</i>: Wenn die Meta-Funktion eine Zuweisung behandelt, sollte sie den zugewiesenen Wert zurückgeben. Auf diese Weise können Zuweisungen verkettet werden, wie in <code>a.x := b.y := z</code>. Der Rückgabewert könnte vom ursprünglichen Wert <code>z</code> abweichen (wenn beispielsweise Beschränkungen auferlegt werden, welche Werte zugewiesen werden können).</p></li>
  <li>Suche nach einem passenden Key in den eigenen Feldern des base-Objekts.</li>
  <li>Wenn ein Key einer Eigenschaft gefunden wurde und <em>get</em> oder <em>set</em> umsetzt (wie vorgesehen), rufe die Eigenschaft auf und kehre zurück. Ist das ein Methodenaufruf, rufe <em>get</em> auf.</li>
  <li>Wenn kein einziger Key gefunden wurde, rufe das eigene base von diesem base-Objekt auf (wende dabei jeden dieser Schritte darauf an, beginnend vom Anfang der Liste). Sind wir noch nicht fertig, durchsuche dieses base-Objekt nochmals nach einen passendem Key, falls ein Key von einer Meta-Funktion hinzugefügt wurde.
    <p>Aufgrund der Abwärtskompatibilität wird dieser Schritt für <em>set</em>-Operationen durchgeführt, selbst wenn ein Key gefunden wurde (es sei denn, es definiert eine Eigenschaft, die <em>set</em> umsetzt).</p></li>
  <li>Wenn mehrere Parameter bei <i>get</i> oder <i>set</i> angegeben wurden und ein Key gefunden wurde, überprüfe seinen Wert. Ist dieser Wert ein Objekt, rufe es auf, um die restlichen Parameter zu behandeln, und tue nichts weiter.</li>
  <li>Wenn ein Key gefunden wurde, stoppe die Suche und gehe folgendermaßen vor:<br>
    <i>Get</i>: Gebe den Wert zurück.<br>
    <i>Set</i>: Wende das Standardverhalten an, wie unten beschrieben.<br>
    <i>Call</i>: Versuch den Wert aufzurufen und übergib das Zielobjekt als ersten Parameter (<code>this</code>). Der Wert sollte ein Funktionsname oder <a href="objects/Functor.htm">Funktionsobjekt</a> sein.</li>
</ul>
<p>Wenn eine Meta-Funktion einen passenden Key im Objekt beinhaltet, aber keinen <code>return</code> verwendet, ist das Verhalten das gleiche wie, als wäre der Key bereits zu Beginn im Objekt da gewesen. Um zu erfahren, wie __Set funktioniert, siehe <a href="#Subclassing_aoa">Mehrdimensionale Arrays bei Unterklassen</a>.</p>
<p>Wenn die Operation immer noch nicht behandelt wurde, überprüfe, ob es eine Built-in-Methode oder -Eigenschaft ist:</p>
<ul>
  <li><i>Get</i>: Wenn der Key "base" ist, gebe das base des Objekts zurück.</li>
  <li><i>Set</i>: Wenn der Key "base" ist, setze das base des Objekts (oder entferne es, wenn der Wert kein Objekt ist).</li>
  <li><i>Call</i>: Rufe eine <a href="objects/Object.htm">Built-in-Methode</a> auf, falls zutreffend.</li>
</ul>
<p>Wenn die Operation immer noch nicht behandelt wurde,</p>
<ul>
  <li><i>Get</i> und <i>Call</i>: Gebe eine leere Zeichenkette zurück.</li>
  <li><i>Set</i>: Wenn nur ein Key-Parameter angegeben wurde, speichere den Key und Wert in das Zielobjekt und gebe den zugewiesenen Wert zurück. Wenn mehrere Parameter angegeben wurden, erstelle ein neues Objekt und speichere es, und verwende dabei den ersten Parameter als Key; rufe dann das neue Objekt auf, um die restlichen Parameter zu behandeln. (Siehe <a href="#Usage_Arrays_of_Arrays">Mehrdimensionale Arrays</a>.)</li>

</ul>

<p><b>Bekannte Einschränkung:</b></p>
<ul><li>Das Verwenden von <code>return</code> ohne Wert ist dasselbe wie <code>return ""</code>. Dieser Sachverhalt wird vielleicht in einer zukünftigen Version geändert, so dass man mit <code>return</code> aus einer Meta-Funktion "flüchten" kann, ohne dabei das Standardverhalten überschreiben zu müssen.</li></ul>

<h4 id="Dynamic_Properties">Dynamische Eigenschaften</h4>
<p>Mit der <a href="#Custom_Classes_property">Eigenschaftssyntax</a> können Eigenschaften definiert werden, die jedes Mal, wenn sie ausgewertet werden, einen Wert berechnen, aber jede Eigenschaft muss im Voraus bekannt und einzeln im Skript definiert sein. Mit <em>__Get</em> und <em>__Set</em> können hingegen Eigenschaften implementiert werden, die das Skript nicht vorher kennen muss.</p>
<p>Zum Beispiel könnte man ein "Proxy"-Objekt erstellen, das Eigenschaften über das Netzwerk (oder über einen beliebig anderen Kanal) anfordern könnte. Ein Remote-Server würde dann mit dem Wert von der Eigenschaft antworten, den das Proxy-Objekt dann an seinen Aufrufer weiterleiten könnte. Auch wenn der Name jeder Eigenschaft im Voraus bekannt war, wäre es unlogisch, jede Eigenschaft einzeln in der Proxy-Klasse zu definieren, da jede Eigenschaft dasselbe tun würde (einen Netzwerk-Request senden). Meta-Funktionen erhalten die Eigenschaftsnamen als Parameter und wären daher eine gute Lösung für dieses Problem.</p>
<p>Eine weitere Verwendungsmöglichkeit von <em>__Get</em> und <em>__Set</em> wäre es, eine Reihe von verwandten Eigenschaften zu implementieren, die Code unter sich aufteilen. In dem Beispiel unten werden sie verwendet, um ein "Farbe"-Objekt mit R, G, B und RGB-Eigenschaften zu implementieren, wo tatsächlich nur der RGB-Wert gespeichert wird:</p>
<pre>rot := new Farbe(0xff0000), rot.R -= 5
cyan := new Farbe(0), cyan.G := 255, cyan.B := 255

MsgBox % "rot: " rot.R "," rot.G "," rot.B " = " rot.RGB
MsgBox % "cyan: " cyan.R "," cyan.G "," cyan.B " = " cyan.RGB

class Farbe
{
    __New(aRGB)
    {
        this.RGB := aRGB
    }

    static Verschiebung := {R:16, G:8, B:0}

    __Get(aName)
    {
        <em>; <span class="red">HINWEIS:</span> this.Verschiebung würde hier eine Endlosschleife erzeugen!</em>
        Verschiebung := Farbe.Verschiebung[aName]  <em>; Ermittelt die Anzahl der zu verschiebenden Bits.</em>
        if (Verschiebung != "")  <em>; Ist sie eine bekannte Eigenschaft?</em>
            return (this.RGB &gt;&gt; Verschiebung) &amp; 0xff
        <em>; <span class="red">HINWEIS:</span> Ein 'return' hier würde this.RGB kaputtmachen.</em>
    }

    __Set(aName, aWert)
    {
        if ((Verschiebung := Farbe.Verschiebung[aName]) != "")
        {
            aWert &amp;= 255  <em>; Kürzt es auf eine geeignete Länge.

            ; Errechnet und speichert den neuen RGB-Wert.</em>
            this.RGB := (aWert &lt;&lt; Verschiebung) | (this.RGB &amp; ~(0xff &lt;&lt; Verschiebung))

            <em>; 'Return' ist notwendig, um die Erstellung eines neuen Key-Value-Paares zu verhindern.
            ; Dies bestimmt auch, was in dem 'x' in 'x := clr[name] := val' gespeichert wird:</em>
            return aWert
        }
        <em>; <span class="red">HINWEIS:</span> Ein 'return' hier würde this._RGB und this.RGB kaputtmachen.</em>
    }

    <em>; Meta-Funktionen können mit Eigenschaften vermischt werden:</em>
    RGB {
        get {
            <em>; Als Hex-Wert zurückgeben:</em>
            return format("0x{:06x}", this._RGB)
        }
        set {
            return this._RGB := value
        }
    }
}</pre>
<p>In diesem Fall hätte man stattdessen die <a href="#Custom_Classes_property">Eigenschaftssyntax</a> verwenden können, wo Code untereinander aufgeteilt werden kann, indem man jede Eigenschaft eine zentrale Methode aufrufen lässt. Meta-Funktionen sollte man wenn möglich vermeiden, da ein hohes Risiko besteht, dass sie falsch verwendet werden (siehe die roten Hinweise oben).</p>

<h4 id="Objects_as_Functions">Objekte als Funktionen</h4>
<p>Siehe <a href="objects/Functor.htm#User-Defined">Funktionsobjekte</a>, wie Objekte erstellt werden können, die sich wie Funktionen verhalten.</p>
<p>Ein Funktionsobjekt kann sich auch wie eine Meta-Funktion verhalten, um z. B. dynamische Eigenschaften zu definieren, die denen im vorherigen Abschnitt ähneln. Obwohl man die <a href="#Custom_Classes_property">Eigenschaftssyntax</a> immer wenn möglich verwenden sollte, zeigt das Beispiel unten das Potenzial von Meta-Funktionen, um neue Konzepte oder Verhaltensmuster zu implementieren, oder um die Struktur des Skripts zu ändern.</p>
<pre>blau := new Farbe(0x0000ff)
MsgBox % blau.R "," blau.G "," blau.B

class Eigenschaften
{
    __Call(aTarget, aName, aParams*)
    {
        <em>; Falls dieses Eigenschaftsobjekt eine Definition für diese Halb-Eigenschaft enthält, wird es aufgerufen.</em>
        if ObjHasKey(this, aName)
            return this[aName].Call(aZiel, aParams*)
    }
}

class Farbe
{
    __New(aRGB)
    {
        this.RGB := aRGB
    }

    class __Get extends Eigenschaften
    {
        R() {
            return (this.RGB &gt;&gt; 16) &amp; 255
        }
        G() {
            return (this.RGB &gt;&gt; 8) &amp; 255
        }
        B() {
            return this.RGB &amp; 255
        }
    }

    <em>;...</em>
}</pre>

<h4 id="Subclassing_aoa">Mehrdimensionale Arrays bei Unterklassen</h4>
<p>Wenn eine <a href="#Usage_Arrays_of_Arrays">Multiparameter-Zuweisung</a> wie <code>Tabelle[x, y] := Inhalt</code> indirekt bewirken sollte, dass ein neues Objekt erstellt wird, hat das neue Objekt kein base und folglich keine benutzerdefinierten Methoden oder Sonderverhalten. Mit <code>__Set</code> könnten diese Objekte wie folgt initialisiert werden.</p>
<pre>x := {base: {addr: Func("x_Addr"), __Set: Func("x_Setter")}}

<em>; Weist einen Wert zu, und ruft indirekt x_Setter auf, um Unterobjekte zu erstellen.</em>
x[1,2,3] := "..."

<em>; Ermittelt den Wert und ruft die Beispielmethode auf.</em>
MsgBox % x[1,2,3] "`n" x.addr() "`n" x[1].addr() "`n" x[1,2].addr()

x_Setter(x, p1, p2, p3) {
    x[p1] := new x.base
}

x_Addr(x) {
    return &amp;x
}</pre>
<p>Da <code>x_Setter</code> vier Pflichtparameter hat, wird es nur aufgerufen, wenn zwei oder mehr Key-Parameter vorhanden sind. Erfolgt die oben genannte Zuweisung, findet folgendes statt:</p>
<ul>
  <li><code>x[1]</code> existiert nicht, daher wird <code>x_Setter(x,1,2,3)</code> aufgerufen (<code>"..."</code> wird nicht übergeben, da zu wenig Parameter vorhanden sind).
  <ul>
    <li>In <code>x[1]</code> wird ein neues Objekt gespeichert, mit demselben base wie <code>x</code>.</li>
    <li>Kein Rückgabewert - die Zuweisung wird fortgesetzt.</li>
  </ul></li>
  <li><code>x[1][2]</code> existiert nicht, daher wird <code>x_Setter(x[1],2,3,"...")</code> aufgerufen.
  <ul>
    <li>In <code>x[1][2]</code> wird ein neues Objekt gespeichert, mit demselben base wie <code>x[1]</code>.</li>
    <li>Kein Rückgabewert - die Zuweisung wird fortgesetzt.</li>
  </ul></li>
  <li><code>x[1][2][3]</code> existiert nicht, aber weil <code>x_Setter</code> vier Parameter benötigt und nur drei zur Verfügung stehen (<code>x[1][2], 3, "..."</code>), wird es nicht aufgerufen und die Zuweisung normal beendet.</li>
</ul>

<h2 id="Default_Base_Object">Standard-base-Objekt</h2>
<p>Verwendet man ein Nicht-Objekt-Wert in Verbindung mit der Objektsyntax, wird das <i>Standard-base-Objekt</i> aufgerufen. Dies könnte zum einen fürs Debuggen nützlich sein, oder, um ein objektähnliches Verhalten für Zeichenketten, Zahlen und/oder Variablen global definieren zu können. Möchte man auf das Standard-base zugreifen, könnte man <code>.base</code> in Verbindung mit einem beliebigen Nicht-Objekt-Wert verwenden; zum Beispiel <code>"".base</code>. Das Standard-base kann nicht wie in <code>"".base := Object()</code> <i>gesetzt</i> werden. Allerdings kann das Standard-base selbst auch ein base haben, wie in <code>"".base.base := Object()</code>.</p>

<h4 id="Automatic_Var_Init">Automatische Variableninitialisierung</h4>
<p>Dient eine leere Variable als Ziel einer <i>Set</i>-Operation, wird sie direkt an die __Set-Meta-Funktion übergeben, so dass sie ein neues Objekt in die Variable einfügen kann. Aus Platzgründen unterstützt dieses Beispiel nicht mehr als ein Parameter; mit einer <a href="Functions.htm#Variadic">variadischen Funktion</a> wäre das möglich.</p>
<pre>"".base.__Set := Func("Default_Set_AutomaticVarInit")

empty_var.foo := "bar"
MsgBox % empty_var.foo

Default_Set_AutomaticVarInit(ByRef var, key, value)
{
    if (var = "")
        var := Object(key, value)
}</pre>

<h4 id="Pseudo_Properties">Pseudo-Eigenschaften</h4>
<p>Diese Art von Syntax kann auch auf Zeichenketten und Zahlen angewendet werden.</p>
<pre>"".base.__Get := Func("Default_Get_PseudoProperty")
"".base.is    := Func("Default_is")

MsgBox % A_AhkPath.length " == " StrLen(A_AhkPath)
MsgBox % A_AhkPath.length.is("integer")

Default_Get_PseudoProperty(nonobj, key)
{
    if (key = "length")
        return StrLen(nonobj)
}

Default_is(nonobj, type)
{
    if nonobj is %type%
        return true
    return false
}</pre>
<p>Beachte, dass Built-in-Funktionen auch möglich sind, aber in diesem Fall können die runden Klammern nicht weggelassen werden:</p>
<pre>"".base.length := Func("StrLen")
MsgBox % A_AhkPath.length() " == " StrLen(A_AhkPath)</pre>

<h4 id="Default__Warn">Debuggen</h4>
<p>Standardmäßig bewirkt der Aufruf eines Nicht-Objekt-Wertes, dass eine Ausnahme ausgelöst wird. Das folgende Beispiel ändert das Verhalten, so dass eine Warnung angezeigt und dann das Skript fortgesetzt wird:</p>
<pre>"".base.__Get := "".base.__Set := "".base.__Call := Func("Default__Warn")

empty_var.foo := "bar"
x := (1 + 1).is("integer")

Default__Warn(nonobj, p1="", p2="", p3="", p4="")
{
    ListLines
    MsgBox Ein Nicht-Objekt-Wert wurde unsachgemäß aufgerufen.`n`nSpeziell: %nonobj%
    return "" <em>; Überschreibt das Standardverhalten durch Rückgabe eines Wertes.</em>
}</pre>

<h2 id="Implementation">Implementierung</h2>
<span id="Refs"></span><h3 id="Reference_Counting">Referenzzählung</h3>
<p>AutoHotkey verwendet einen einfachen Referenzzählungsmechanismus, um Ressourcen eines Objekts freizugeben, das nicht länger im Skript gebraucht wird. Skript-Autoren sollten diesen Mechanismus nur aufrufen, wenn man direkt mit unverwalteten <a href="#Implementation_Pointers">Pointer, die auf Objekte verweisen</a>, arbeiten muss.</p>
<p>Temporär zurückgegebene Verweise von Funktionen, Methoden oder Operatoren innerhalb eines Ausdrucks werden erst freigegeben, wenn die Auswertung dieses Ausdrucks abgeschlossen oder abgebrochen wurde. Dadurch können temporäre Objekte für die Ressourcenverwaltung verwendet werden. Zum Beispiel:</p>
<pre>MsgBox % <a href="commands/DllCall.htm">DllCall</a>("GlobalSize", "ptr", (new <a href="#GMem">GMem</a>(0, 20)).ptr, "ptr")  <em>; 20</em></pre>
<p>Wenn Code beim Freigeben des letzten Verweises auf ein Objekt ausgeführt werden soll, muss man die <a href="#Custom_NewDelete">__Delete</a>-Meta-Funktion implementieren.</p>
<p><b>Bekannte Einschränkungen:</b></p>
<ul>
  <li>Zirkelbezüge müssen unterbrochen werden, bevor ein Objekt freigegeben werden kann. Siehe <a href="#Circular_References">Freigeben von Objekten</a>, um anhand eines Beispiels mehr darüber zu erfahren.</li>
  <li>Verweise in statischen und globalen Variablen werden automatisch freigegeben, sobald das Programm beendet wird. Verweise in nicht-statischen lokalen Variablen oder im Ausdrucksauswertungsstapel bleiben bestehen. Solche Verweise werden nur freigegeben, wenn die Funktion oder der Ausdruck normal beendet werden konnte.</li>
</ul>
<p>Das Betriebssystem kann den benutzten Speicher vom Objekt wieder verwenden, sobald das Programm beendet wird. Allerdings wird <a href="#Custom_NewDelete">__Delete</a> erst aufgerufen, wenn alle Verweise auf das Objekt freigegeben worden sind. Das kann wichtig sein, wenn andere Ressourcen freigegeben werden, die nicht automatisch vom Betriebssystem wieder verwendet werden, wie zum Beispiel temporäre Dateien.</p>

<span id="AddressCast"></span><h3 id="Implementation_Pointers">Pointer auf Objekte</h3>
<p>In einigen seltenen Fällen kann es erforderlich sein, ein Objekt per DllCall an einen externen Code zu übergeben oder ein Objekt in eine binäre Datenstruktur zu speichern, um es später abrufen zu können. Die Adresse eines Objekts kann via <code>Adresse := &amp;Objekt</code> abgerufen werden; dies würde allerdings effektiv zwei Verweise auf das Objekt erzeugen, aber das Programm kennt nur den einen in <em>Objekt</em>. Wenn der letzte <em>bekannte</em> Verweis auf das Objekt freigegeben wurde, wird das Objekt gelöscht. Demzufolge muss das Skript das Objekt darüber informieren, dass es einen Verweis erhalten hat. Dies kann man wie folgt erreichen:</p>
<pre><a href="commands/ObjAddRef.htm">ObjAddRef</a>(Adresse := &amp;Objekt)</pre>
<p>Das Skript muss das Objekt außerdem darüber informieren, dass es mit diesem Verweis fertig ist:</p>
<pre><a href="commands/ObjAddRef.htm">ObjRelease</a>(Adresse)</pre>
<p>Generell sollte jede neue Kopie einer Objektadresse als seperater Objektverweis behandelt werden, demzufolge sollte das Skript ObjAddRef aufrufen, wenn es eine Kopie erhält, und sofort ObjRelease aufrufen, bevor es eine verliert. Würde man beispielsweise eine Adresse mit so etwas wie <code>x := Adresse</code> kopieren, sollte ObjAddRef aufgerufen werden. Ebenso sollte das Skript ObjRelease aufrufen, wenn es mit <em>x</em> fertig ist (oder dabei ist den Wert von <em>x</em> zu überschreiben).</p>
<p>Mit Object() kann eine Adresse in einen geeigneten Verweis umgewandelt werden:</p>
<pre>Objekt := Object(Adresse)</pre>
<p>Beachte, dass die Object()-Funktion sogar auf Objekte angewendet werden kann, die sie selbst nicht erstellt hat, wie z. B. <a href="commands/ComObjCreate.htm">COM-Objekt-Wrapper</a> oder <a href="objects/File.htm">File-Objekte</a>.</p>

</body>
</html>
