<!DOCTYPE HTML>
<html lang="de">
<head>
<title>Object - Methoden &amp; Eigenschaften | AutoHotkey v2</title>
<meta name="description" content="Object ist die Basisklasse, von der andere AutoHotkey-Objektklassen abgeleitet sind." />
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="robots" content="noindex, nofollow">
<link href="../static/theme.css" rel="stylesheet" type="text/css" />
<script src="../static/content.js" type="text/javascript"></script>
<script src="../static/ga.js" type="text/javascript"></script>
</head>
<body>

<h1>Object</h1>

<p><strong>Object</strong> ist die Basisklasse, von der andere AutoHotkey-Objektklassen abgeleitet sind. Jede Instanz von Object besteht aus folgendem:</p>
<ul>
  <li>Eigene Eigenschaften: eine Reihe von Eigenschaften, die zu diesem spezifischen Objekt gehören.</li>
  <li>Eigene Methoden: eine Reihe von Methoden, die zu diesem spezifischen Objekt gehören.</li>
  <li>Ein Base-Objekt, von dem Eigenschaften und Methoden geerbt werden.</li>
</ul>
<p>Es gibt Werteigenschaften und dynamische Eigenschaften. Werteigenschaften enthalten lediglich einen Wert. Dynamische Eigenschaften enthalten keinen Wert, sondern rufen stattdessen eine <em>Getter</em>- oder <em>Setter</em>-Funktion auf, wenn sie zugegriffen werden. Der <em>Getter</em> oder <em>Setter</em> kann via abgeleitetes Objekt überschrieben werden (am einfachsten definiert man diese innerhalb einer Klasse).</p>
<p>Die folgende Dokumentation verwendet <code>Obj</code> als Platzhalter für jede Instanz von Object. Alle Instanzen von Object basieren auf <code>Object.Prototype</code>, von dem die folgenden vordefinierten Methoden und Eigenschaften geerbt werden:</p>
<p><strong>Methoden:</strong></p>
<ul>
	<li><a href="#Clone">Clone</a></li>
  <li><a href="#DefineMethod">DefineMethod</a></li>
  <li><a href="#DefineProp">DefineProp</a></li>
  <li><a href="#DeleteMethod">DeleteMethod</a></li>
  <li><a href="#DeleteProp">DeleteProp</a></li>
  <li><a href="#GetMethod">GetMethod</a></li>
  <li><a href="#GetOwnPropDesc">GetOwnPropDesc</a></li>
  <li><a href="#HasBase">HasBase</a></li>
  <li><a href="#HasMethod">HasMethod</a></li>
  <li><a href="#HasOwnMethod">HasOwnMethod</a></li>
  <li><a href="#HasOwnProp">HasOwnProp</a></li>
  <li><a href="#HasProp">HasProp</a></li>
  <li><a href="#OwnMethods">OwnMethods</a></li>
  <li><a href="#OwnProps">OwnProps</a></li>
</ul>
<p><strong>Eigenschaften:</strong></p>
<ul>
	<li><a href="#Base">Base</a></li>
</ul>
<p><strong>Funktionen:</strong></p>
<ul>
	<li><a href="#GetBase">ObjGetBase</a>, <a href="#SetBase">ObjSetBase</a>: Ermittelt oder setzt das <a href="../Objects.htm#Custom_Objects">Base-Objekt</a> des Objekts.</li>
  <li><a href="#GetCapacity">ObjGetCapacity</a>, <a href="#SetCapacity">ObjSetCapacity</a>: Ermittelt oder setzt die Kapazität von Eigenschaften eines Objekts.</li>
  <li><a href="#OwnPropCount">ObjOwnPropCount</a>: Ruft die Anzahl von eigenen Eigenschaften ab, die in einem Objekt enthalten sind.</li>
	<li>Veraltet: <a href="#RawGet">ObjRawGet</a>, <a href="#RawSet">ObjRawSet</a>: Ermittelt oder setzt die eigene Werteigenschaft eines Objekts, umgeht alle Metafunktionen und überschreibt eventuell Eigenschaften-Accessor-Funktionen.</li>
  <li>ObjHasOwnProp, ObjHasProp, ObjOwnMethods, ObjOwnProps: Äquivalent zur entsprechenden vordefinierten Methode, kann aber nicht überschrieben werden.</li>
</ul>

<h1>Methoden</h1>

<div class="methodShort" id="Clone"><h2>Clone</h2>
<p>Gibt eine flache Kopie des Objekts zurück.</p>
<pre class="Syntax">Klon := Obj.<span class="func">Clone</span>()</pre>
<p>Jede Eigenschaft oder Methode, die dem Objekt gehört, wird in den Klon kopiert. Objekt<em>referenzen</em> werden kopiert (wie bei einer normalen Zuweisung), nicht die Objekte selbst;mit anderen Worten, wenn eine Eigenschaft eine Referenz zu einem Objekt enthält, enthält der Klon eine Referenz zum gleichen Objekt.</p>
<p>Dynamische Eigenschaften werden kopiert, nicht aufgerufen.</p>
<p>Der Klon hat das gleiche Base-Objekt wie das Originalobjekt.</p>
</div>

<div class="methodShort" id="DefineMethod"><h2>DefineMethod</h2>
<p>Definiert eine neue Methode.</p>
<pre class="Syntax">Obj.<span class="func">DefineMethod</span>(Name, MethodenFunk)</pre>
<dl>
  <dt>Name</dt>
  <dd>
    <p>Typ: <a href="../Concepts.htm#strings">Zeichenkette</a></p>
    <p>Der Name der Methode.</p>
  </dd>
  <dt>MethodenFunk</dt>
  <dd>
    <p>Typ: <a href="Functor.htm">Funktionsobjekt</a></p>
    <p>Die Implementierung der Methode. Die Funktion muss mindestens einen Parameter akzeptieren, der eine Referenz zum Zielobjekt des Methodenaufrufs erhält. Dieser Parameter wird automatisch mit dem Namen <code>this</code> definiert, wenn die Methode via Klassendefinition erzeugt wird.</p>
  </dd>
</dl>
<p>Die neue Methode gehört <em>Obj</em>, kann aber von allen Objekten geerbt werden, die <em>Obj</em> als Base verwenden. Wenn <em>Obj</em> eine Klasse ist, gilt die neue Methode nur für die Klasse selbst und die Unterklassen (das heißt, sie ist statisch). Um eine Methode für alle Instanzen einer Klasse zu definieren, können Sie <em>Obj</em> zum <code>Prototyp</code> der Klasse machen.</p>
</div>

<div class="methodShort" id="DefineProp"><h2>DefineProp</h2>
<p>Definiert eine neue dynamische Eigenschaft.</p>
<pre class="Syntax">Obj.<span class="func">DefineProp</span>(Name, Deskriptor)</pre>
<dl>
  <dt>Name</dt>
  <dd>
    <p>Typ: <a href="../Concepts.htm#strings">Zeichenkette</a></p>
    <p>Der Name der Eigenschaft.</p>
  </dd>
  <dt>Deskriptor</dt>
  <dd>
    <p>Typ: Object</p>
    <p>Ein Objekt mit keine oder mehr der folgenden eigenen Eigenschaften:</p>
    <p><code>Get</code>: Das <a href="Functor.htm">Funktionsobjekt</a>, das aufgerufen werden soll, wenn der Wert der Eigenschaft abgerufen wird.</p>
    <p><code>Set</code>: Das <a href="Functor.htm">Funktionsobjekt</a>, das aufgerufen werden soll, wenn der Eigenschaft ein Wert zugewiesen wird. Der zweite Parameter ist der Wert, der zugewiesen wird.</p>
  </dd>
</dl>
<p>Wenn <em>Get</em> oder <em>Set</em> nicht definiert ist, kann es von einem Base-Objekt geerbt werden. Wenn <em>Get</em> undefiniert ist, kann die Eigenschaft einen Wert zurückgeben, der von einem Base geerbt wurde. Wenn <em>Set</em> in diesem und allen Base-Objekten undefiniert ist, ist die Eigenschaft schreibgeschützt (der Versuch, die Eigenschaft zu setzen, löst eine Ausnahme aus).</p>
</div>

<div class="methodShort" id="DeleteMethod"><h2>DeleteMethod</h2>
<p>Entfernt eine eigene Methode aus dem Objekt.</p>
<pre class="Syntax">Obj.<span class="func">DeleteMethod</span>(Name)</pre>
<dl>
  <dt>Name</dt>
  <dd>
    <p>Typ: <a href="../Concepts.htm#strings">Zeichenkette</a></p>
    <p>Namen einer Methode. Wenn das Objekt keine Methode mit diesem Namen besitzt, wird eine Ausnahme ausgelöst.</p>
  </dd>
</dl>
</div>

<div class="methodShort" id="DeleteProp"><h2>DeleteProp</h2>
<p>Entfernt eine eigene Eigenschaft aus dem Objekt.</p>
<pre class="Syntax">Obj.<span class="func">DeleteProp</span>(Name)</pre>
<dl>
  <dt>Name</dt>
  <dd>
    <p>Typ: <a href="../Concepts.htm#strings">Zeichenkette</a></p>
    <p>Der Name einer Eigenschaft.</p>
  </dd>
  <dt>Rückgabewert</dt>
  <dd><p>Der Wert der entfernten Eigenschaft (leer, wenn es keinen gibt).</p></dd>
</dl>
</div>

<div class="methodShort" id="GetMethod"><h2>GetMethod</h2>
<p>Ruft die Implementierungsfunktion einer Methode ab.</p>
<pre class="Syntax">Obj.<span class="func">GetMethod</span>(Name)</pre>
<dl>
  <dt>Name</dt>
  <dd>
    <p>Typ: <a href="../Concepts.htm#strings">Zeichenkette</a></p>
    <p>Namen einer Methode.</p>
  </dd>
  <dt>Rückgabewert</dt>
  <dd>
    <p>Typ: <a href="Functor.htm">Funktionsobjekt</a></p>
    <p>Die Implementierung der Methode. Dies ist entweder ein <a href="Func.htm">Func</a>-Objekt, das via Klassendefinition erstellt wurde, oder ein Objekt, das zuvor an <a href="#DefineMethod">DefineMethod</a> übergeben wurde.</p>
  </dd>
</dl>
<p>Die Methode kann dem Objekt selbst gehören oder von einem Base-Objekt geerbt werden.</p>
</div>

<div class="methodShort" id="GetOwnPropDesc"><h2>GetOwnPropDesc</h2>
<p>Gibt einen Deskriptor für eine bestimmte Eigenschaft zurück, der kompatibel mit <a href="#DefineProp">DefineProp</a> ist.</p>
<pre class="Syntax">Obj.<span class="func">GetOwnPropDesc</span>(Name)</pre>
<dl>
  <dt>Name</dt>
  <dd>
    <p>Typ: <a href="../Concepts.htm#strings">Zeichenkette</a></p>
    <p>Der Name einer Eigenschaft.</p>
  </dd>
  <dt>Rückgabewert</dt>
  <dd>
    <p>Typ: Object</p>
    <p>Ein neues Objekt mit keine oder mehr der folgenden eigenen Eigenschaften:</p>
    <p><code>Get</code>: Das <a href="Functor.htm">Funktionsobjekt</a>, das aufgerufen wird, wenn der Wert der Eigenschaft abgerufen wird, sofern dies in <em>Obj</em> definiert ist.</p>
    <p><code>Set</code>: Das <a href="Functor.htm">Funktionsobjekt</a>, das aufgerufen wird, wenn der Eigenschaft ein Wert zugewiesen wird, sofern dies in <em>Obj</em> definiert ist.</p>
  </dd>
</dl>
<p>Das Ändern des zurückgegebenen Objekts hat keinen Einfluss auf <em>Obj</em>, es sei denn, <a href="#DefineProp">DefineProp</a> wird aufgerufen.</p>
</div>

<div class="methodShort" id="HasOwnMethod"><h2>HasOwnMethod</h2>
<pre class="Syntax">Obj.<span class="func">HasOwnMethod</span>(Name)</pre>
<p>Gibt True zurück, wenn das Objekt eine Methode mit diesem Namen besitzt, ansonsten False.</p>
</div>

<div class="methodShort" id="HasOwnProp"><h2>HasOwnProp</h2>
<pre class="Syntax">Obj.<span class="func">HasOwnProp</span>(Name)</pre>
<p>Gibt True zurück, wenn das Objekt eine Eigenschaft mit diesem Namen besitzt, ansonsten False.</p>
</div>

<div class="methodShort" id="HasBase"><h2>HasBase</h2>
<pre class="Syntax">Obj.<span class="func">HasBase</span>(BaseObj)</pre>
<p>Gibt True zurück, wenn <em>BaseObj</em> ein direktes oder indirektes Base von <em>Obj</em> ist, ansonsten False. Zum Beispiel ist <code>Obj.HasBase(Array.Prototype)</code> True, wenn <em>Obj</em> eine Instanz eines Arrays oder einer abgeleiteten Klasse ist. Dieselbe Prüfung wird von <code>Obj is Array</code> durchgeführt; Instanzen können jedoch auf anderen Instanzen basieren, während <code>is</code> ein Class-Objekt benötigt.</p>
</div>

<div class="methodShort" id="HasMethod"><h2>HasMethod</h2>
<pre class="Syntax">Obj.<span class="func">HasMethod</span>(Name)</pre>
<p>Gibt True zurück, wenn das Objekt eine Methode mit diesem Namen hat, ansonsten False. Die Methode kann dem Objekt selbst gehören oder von einem Base-Objekt geerbt werden.</p>
</div>

<div class="methodShort" id="HasProp"><h2>HasProp</h2>
<pre class="Syntax">Obj.<span class="func">HasProp</span>(Name)</pre>
<p>Gibt True zurück, wenn das Objekt eine Eigenschaft mit diesem Namen hat, ansonsten False. Die Eigenschaft kann dem Objekt selbst gehören oder von einem Base-Objekt geerbt werden.</p>
</div>

<div class="methodShort" id="OwnMethods"><h2>OwnMethods</h2>
<p>Enumeriert die eigenen Methoden des Objekts.</p>
<pre class="Syntax">For Name <span class="optional">, MethodenFunk</span> in Obj.<span class="func">OwnMethods</span>()</pre>
<p>Gibt einen neuen <a href="Enumerator.htm">Enumerator</a> zurück. Der Enumerator wird typischerweise direkt an eine <a href="../commands/For.htm">For-Schleife</a> übergeben, die den Enumerator einmal für jede Wiederholung der Schleife aufruft. Jeder Aufruf des Enumerators gibt den nächsten Methodennamen und/oder Implementierungsfunktion zurück. Die Variablen der For-Schleife entsprechen den folgenden Parametern des Enumerators:</p>
<dl>
  <dt>Name</dt>
  <dd>
    <p>Typ: <a href="../Concepts.htm#strings">Zeichenkette</a></p>
    <p>Der Name der Methode.</p>
  </dd>
  <dt>MethodenFunk</dt>
  <dd>
    <p>Typ: <a href="Functor.htm">Funktionsobjekt</a></p>
    <p>Die Implementierung der Methode. Dies ist entweder ein <a href="Func.htm">Func</a>-Objekt, das via Klassendefinition erstellt wurde, oder ein Objekt, das zuvor an <a href="#DefineMethod">DefineMethod</a> übergeben wurde.</p>
  </dd>
</dl>
</div>

<div class="methodShort" id="OwnProps"><h2>OwnProps</h2>
<p>Enumeriert die eigenen Eigenschaften des Objekts.</p>
<pre class="Syntax">For Name <span class="optional">, Wert</span> in Obj.<span class="func">OwnProps</span>()</pre>
<p>Gibt einen neuen <a href="Enumerator.htm">Enumerator</a> zurück. Der Enumerator wird typischerweise direkt an eine <a href="../commands/For.htm">For-Schleife</a> übergeben, die den Enumerator einmal für jede Wiederholung der Schleife aufruft. Jeder Aufruf des Enumerators gibt den nächsten Eigenschaftsnamen und/oder Wert zurück. Die Variablen der For-Schleife entsprechen den folgenden Parametern des Enumerators:</p>
<dl>
  <dt>Name</dt>
  <dd>
    <p>Typ: <a href="../Concepts.htm#strings">Zeichenkette</a></p>
    <p>Der Name der Eigenschaft.</p>
  </dd>
  <dt>Wert</dt>
  <dd>
    <p>Der Wert der Eigenschaft.</p>
    <p>Wenn die Eigenschaft eine Getter-Methode hat, wird sie aufgerufen, um den Wert zu ermitteln (es sei denn, <em>Wert</em> wird weggelassen).</p>
  </dd>
</dl>
</div>

<h1>Eigenschaften</h1>

<div class="methodShort" id="Base"><h2>Base</h2>
<p>Ermittelt oder setzt das <a href="../Objects.htm#Custom_Objects">Base-Objekt</a> des Objekts.</p>
<pre class="Syntax">BaseObj := Obj.Base</pre>
<pre class="Syntax">Obj.Base := BaseObj</pre>
<p><em>BaseObj</em> muss ein Objekt vom Typ Object sein.</p>
<p>Wenn die Zuweisung des neuen Base den nativen Typ des Objekts ändern sollte, wird eine Ausnahme ausgelöst. Der native Typ eines Objekts wird vom nächstgelegenen Prototype-Objekt einer internen Klasse bestimmt, wie z. B. <code>Object.Prototype</code> oder <code>Array.Prototype</code>. Zum Beispiel muss eine Instanz eines Arrays immer von <code>Array.Prototype</code> abgeleitet werden, entweder direkt oder indirekt.</p>
<p></p>
<p>Eigenschaften und Methoden werden dynamisch vom Base-Objekt geerbt; ändert man also das Base eines Objekts, ändert man gleichzeitig auch die Verfügbarkeit von geerbten Eigenschaften und Methoden.</p>
<p>Siehe auch: <a href="#GetBase">ObjGetBase</a>, <a href="#SetBase">ObjSetBase</a></p>
</div>

<h1>Funktionen</h1>

<div class="methodShort" id="RawGet"><h2>ObjRawGet</h2>
<p>Ruft den Wert einer eigenen Eigenschaft eines Objekts ab.</p>
<p class="warning"><strong>Veraltet:</strong> Diese Funktion wird möglicherweise in einer zukünftigen Version entfernt oder ersetzt.</p>
<pre class="Syntax">Wert := <span class="func">ObjRawGet</span>(Obj, Name)</pre>
<p>Wenn das Objekt keine Eigenschaft mit diesem Namen besitzt oder handelt es sich um eine dynamische Eigenschaft, ist der Rückgabewert eine leere Zeichenkette. Es werden keine <a href="../Objects.htm#Meta_Functions">Metafunktionen</a> oder <a href="../Objects.htm#Custom_Classes_property">Eigenschaftsfunktionen</a> aufgerufen. Geerbte Eigenschaften werden nicht berücksichtigt.</p>
<p>Es wird eine Ausnahme ausgelöst, wenn <em>Obj</em> vom falschen Typ ist.</p>
</div>

<div class="methodShort" id="RawSet"><h2>ObjRawSet</h2>
<p>Erstellt eine neue Werteigenschaft oder setzt den Wert einer bestehenden.</p>
<p class="warning"><strong>Veraltet:</strong> Diese Funktion wird möglicherweise in einer zukünftigen Version entfernt oder ersetzt.</p>
<pre class="Syntax"><span class="func">ObjRawSet</span> Obj, Name, Wert</pre>
<p>Diese Funktion wurde bereitgestellt, um den Skripten die Möglichkeit zu bieten, die __Set-<a href="../Objects.htm#Meta_Functions">Metafunktion</a> und <a href="../Objects.htm#Custom_Classes_property">Eigenschaften</a> zu umgehen. Falls dies nicht notwendig ist, sollte stattdessen eine normale Zuweisung verwendet werden. Zum Beispiel: <code>Obj.%Name% := Wert</code></p>
<p>Da der Zweck darin besteht, Metafunktionen zu umgehen, ist dies nur eine Funktion, keine Methode. Das Aufrufen einer internen Methode ruft generell auch die __Call-Metafunktion auf.</p>
<p>Es wird eine Ausnahme ausgelöst, wenn <em>Obj</em> vom falschen Typ ist.</p>
</div>

<div class="methodShort" id="GetBase"><h2>ObjGetBase</h2>
<p>Gibt das <a href="../Objects.htm#Custom_Objects">Base-Objekt</a> des Objekts zurück.</p>
<pre class="Syntax">BaseObj := <span class="func">ObjGetBase</span>(Obj)</pre>
<p>Es werden keine <a href="../Objects.htm#Meta_Functions">Metafunktionen</a> oder <a href="../Objects.htm#Custom_Classes_property">Eigenschaftsfunktionen</a> aufgerufen. Der Aufruf dieser Funktion entspricht dem Aufruf der Standardimplementierung der <a href="#Base">Base</a>-Eigenschaft, auch wenn diese Eigenschaft überschrieben wurde.</p>
<p>Es wird eine Ausnahme ausgelöst, wenn <em>Obj</em> vom falschen Typ ist.</p>
<p>Siehe auch: <a href="#Base">Base-Eigenschaft</a></p>
</div>

<div class="methodShort" id="SetBase"><h2>ObjSetBase</h2>
<p>Setzt das <a href="../Objects.htm#Custom_Objects">Base-Objekt</a> des Objekts.</p>
<pre class="Syntax"><span class="func">ObjSetBase</span>(Obj, BaseObj)</pre>
<p>Es werden keine <a href="../Objects.htm#Meta_Functions">Metafunktionen</a> oder <a href="../Objects.htm#Custom_Classes_property">Eigenschaftsfunktionen</a> aufgerufen. Der Aufruf dieser Funktion entspricht dem Aufruf der Standardimplementierung der <a href="#Base">Base</a>-Eigenschaft, auch wenn diese Eigenschaft überschrieben wurde.</p>
<p>Es wird eine Ausnahme ausgelöst, wenn <em>Obj</em> oder <em>BaseObj</em> vom falschen Typ ist.</p>
<p>Siehe auch: <a href="#Base">Base-Eigenschaft</a></p>
</div>

<div class="methodShort" id="OwnPropCount"><h2>ObjOwnPropCount</h2>
<p>Gibt die Anzahl der Eigenschaften zurück, die einem Objekt gehören.</p>
<pre class="Syntax">Anzahl := <span class="func">ObjOwnPropCount</span>(Obj)</pre>
</div>

<div class="methodShort" id="SetCapacity"><h2>ObjSetCapacity</h2>
<p>Setzt die aktuelle Kapazität des internen Arrays mit eigenen Eigenschaften des Objekts.</p>
<pre class="Syntax"><span class="func">ObjSetCapacity</span>(Obj, MaxEigenschaften)</pre>
<dl>
	<dt>MaxEigenschaften</dt>
	<dd>
    <p>Typ: <a href="../Concepts.htm#numbers">Integer</a></p>
    <p>Die neue Kapazität. Wenn dieser Parameter kleiner als die aktuelle Anzahl von eigenen Eigenschaften ist, wird dieser Wert stattdessen verwendet und ungenutzter Speicher freigegeben.</p>
  </dd>
	<dt>Rückgabewert</dt>
	<dd>
    <p>Typ: <a href="../Concepts.htm#numbers">Integer</a></p>
    <p>Die neue Kapazität.</p>
  </dd>
</dl>
<p>Es wird eine Ausnahme ausgelöst, wenn <em>Obj</em> vom falschen Typ ist.</p>
</div>

<div class="methodShort" id="GetCapacity"><h2>ObjGetCapacity</h2>
<pre class="Syntax">MaxElemente := <span class="func">ObjGetCapacity</span>(Obj)</pre>
<dl>
	<dt>Rückgabewert</dt>
	<dd>
    <p>Typ: <a href="../Concepts.htm#numbers">Integer</a></p>
    <p>Die aktuelle Kapazität des internen Arrays mit Eigenschaften des Objekts.</p>
  </dd>
</dl>
<p>Es wird eine Ausnahme ausgelöst, wenn <em>Obj</em> vom falschen Typ ist.</p>
</div>

</body>
</html>
