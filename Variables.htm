<!DOCTYPE HTML>
<html>
<head>
<title>Variablen und Ausdrücke</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="robots" content="noindex, nofollow">
<link href="static/theme.css" rel="stylesheet" type="text/css" />
<script src="static/content.js" type="text/javascript"></script>
<script src="static/ga.js" type="text/javascript"></script>
</head>

<body>
<h1>Variablen und Ausdrücke</h1>

<h2>Inhaltsverzeichnis</h2>
<ul>
  <li><a href="#Variables">Variablen</a></li>
  <li><a href="#Expressions">Ausdrücke</a></li>
  <li><a href="#Operators">Operatoren innerhalb von Ausdrücken</a></li>
  <li><a href="#BuiltIn">Built-in-Variablen</a></li>
  <li><a href="#env">Umgebungsvariablen vs. normale Variablen</a></li>
  <li><a href="#cap">Kapazität und Speicher einer Variable</a></li>
</ul>
<span id="Variables"></span><h2 id="Intro">Variablen</h2>
<p id="Variable_types"><strong>Variablentypen</strong>: AutoHotkey besitzt keine explizit definierten Variablentypen. Stattdessen kann jede Variable eine Zeichenkette, einen Integer, Objektverweis oder eine Fließkommazahl enthalten. Darüber hinaus werden Zahlen automatisch in oder von Zeichenketten umgewandelt, falls notwendig.  Mit der <a href="commands/Type.htm">Type</a>-Funktion kann der aktuelle Typ eines Wertes festgestellt werden.</p>
<p id="Variable_scope"><strong>Gültigkeitsbereiche und Deklarationen von Variablen</strong>: Mit Ausnahme von <a href="Functions.htm#Locals">lokalen Variablen</a> in Funktionen sind alle Variablen global; das heißt, dass deren Inhalte jederzeit vom Skript gelesen oder geändert werden können. Im Normalfall müssen Variablen nicht deklariert werden (in <a href="Functions.htm#Global">Funktionen</a> gibt es Ausnahmen); Variablen stehen zur Verfügung, sobald sie verwendet werden (zudem sind sie anfangs leer).</p>
<p id="Variable_names"><strong>Variablennamen</strong>: Bei Variablennamen ist die Groß- und Kleinschreibung egal (zum Beispiel wäre <em>AktuellesDatum</em> das gleiche wie <em>aktuellesdatum</em>). Variablennamen können bis zu 253 Zeichen lang sein und dürfen nur aus Buchstaben, Zahlen, Unterstrichen und Nicht-ASCII-Zeichen bestehen. Variablennamen dürfen nicht mit einer Zahl beginnen.</p>
<p id="Reserved_words"><strong>Reservierte Wörter:</strong> <code>and</code>, <code>contains</code>, <code>in</code>, <code>is</code>, <code>new</code>, <code>not</code> und <code>or</code>. Diese Wörter dienen als <a href="#Operators">Operatoren</a> und sind daher als Variablennamen nicht zu gebrauchen, wenn sie in einem Ausdruck direkt geschrieben werden.</p>
<p>Die Namen der Ablaufsteuerungsanweisungen sind auch reserviert, um in erster Linie Fehler zu finden. Dazu gehören: <code>Break</code>, <code>Catch</code>, <code>Continue</code>, <code>Else</code>, <code>Finally</code>, <code>For</code>, <code>Gosub</code>, <code>Goto</code>, <code>If</code>, <code>Loop</code>, <code>LoopFile</code>, <code>LoopParse</code>, <code>LoopRead</code>, <code>LoopReg</code>, <code>Return</code>, <code>Throw</code>, <code>Try</code>, <code>Until</code>, <code>While</code></p>
<p>Funktionen, Klassen und Fenstergruppen benutzen die gleiche Validierung wie Variablen und haben deshalb die gleichen Einschränkungen.</p>
<p id="assigning"><strong>Speichern von Variablenwerten</strong>: Um eine Zeichenkette oder Zahl in eine Variable zu speichern, verwende den <a href="commands/SetExpression.htm">Doppelpunkt-Gleich-Operator (:=)</a>, gefolgt von einer Zahl, einer Zeichenkette in Anführungszeichen oder ein beliebig anderer <a href="#Expressions">Ausdruck</a>. Zum Beispiel:</p>
<pre>MeineZahl := 123
MeineZeichenkette := "Das ist eine direkt geschriebene Zeichenkette."
KopieVonVar := Var</pre>
<p>Variablen ohne zugewiesenem Wert enthalten standardmäßig eine leere Zeichenkette. enn der Inhalt einer Variable gelöscht werden soll, weist man der Variable einfach eine leere Zeichenkette zu:</p>
<pre>MeineVar := ""</pre>
<p>Es ist außerdem möglich, der Variable indirekt einen Wert zuzuweisen, wenn sie als <em>Ausgabevariable</em> einer Funktion verwendet wird. Zum Beispiel:</p>
<pre><a href="commands/MouseGetPos.htm">MouseGetPos</a> <strong>x</strong>, <strong>y</strong></pre>
<p id="retrieving"><strong>Abrufen von Variablenwerten</strong>: Mit <a href="#concat">Verkettung</a> oder <a href="commands/Format.htm">Format</a> kann der Inhalt einer Variable in eine Zeichenkette eingefügt werden. Zum Beispiel:</p>
<pre><a href="commands/MsgBox.htm">MsgBox</a> "Der Wert von Var ist " . Var . "."
MsgBox "Der Wert in der Variable namens Var ist " Var "."
MsgBox Format("Var hat den Wert {1}.", Var)
</pre>
<p>Teilausdrücke können auf dieselbe Weise mit Zeichenketten kombiniert werden. Zum Beispiel:</p>
<pre>MsgBox("Die Summe von X und Y ist " . (X + Y))
</pre>
<p><strong>Vergleichen von Variablen</strong>: Bitte ließ dir den folgenden Abschnitt genau durch, wie auf welche Weise Vergleiche durchgeführt werden können.</p>
<h2 id="Expressions">Ausdrücke</h2>
<p>Ausdrücke sind nützlich, um eine oder mehrere Operationen an Variablen, direkt geschriebenen Zeichenketten und/oder direkt geschriebenen Zahlen durchzuführen.</p>
<p>Innerhalb eines Ausdrucks werden Variablennamen nicht mit Prozentzeichen umschlossen (nur bei Variablen innerhalb einer Zeichenkette mit Anführungszeichen, und bei <a href="misc/Arrays.htm#pseudo">Pseudo-Arrays</a> und anderen <a href="#ref">Doppelverweisen</a>). Demzufolge müssen direkt geschriebene Zeichenketten in Anführungszeichen gesetzt werden, wenn sie nicht als Variablen interpretiert werden sollen. Zum Beispiel:</p>
<pre>if (AktuelleEinstellung &gt; 100 or GefundeneFarbe &lt;&gt; "Blau")
    MsgBox "Die Einstellung ist zu hoch oder die Farbe ist falsch."</pre>
<p>Im obigen Beispiel kann man sehen, dass "Blau" in Anführungszeichen gesetzt wurde, weil es als Zeichenkette interpretiert werden soll. Einfache Anführungszeichen (') und doppelte Anführungszeichen (") sind funktionsgemäß identisch, außer dass eine Zeichenkette, die von einfachen Anführungszeichen umschlossen ist, direkt geschriebene doppelte Anführungszeichen enthalten kann, und umgekehrt. Um ein <em>tatsächliches</em> Anführungszeichen innerhalb einer direkt geschriebenen Zeichenkette einzufügen, muss das Anführungszeichen entweder mit einem <a href="misc/EscapeChar.htm">Escapezeichen</a> versehen werden oder die Zeichenkette von gegenteiligen Anführungszeichen umschlossen werden. Zum Beispiel:</p>
<pre>MsgBox "Sie sagte: <span class="red">`"</span>Ein Apfel pro Tag.<span class="red">`"</span>"
MsgBox <span class="red">'</span>Sie sagte: "Ein Apfel pro Tag."<span class="red">'</span></pre>
<p><strong>Leere Zeichenketten</strong>: Mithilfe von zwei aufeinanderfolgenden Anführungszeichen kann eine leere Zeichenkette in einem Ausdruck angegeben werden. Zum Beispiel wäre die Anweisung <code>if (MeineVar &lt;&gt; "")</code> wahr, wenn <em>MeineVar</em> nicht leer ist.</p>
<p><strong>Speichern eines Ausdruckwertes</strong>: Mit dem <a href="commands/SetExpression.htm">Operator ":="</a> kann der Wert bzw. das Ergebnis eines Ausdrucks in eine Variable gespeichert werden. Zum Beispiel:</p>
<pre>Nettopreis := Preis * (1 - Rabatt/100)</pre>
<p id="Boolean"><strong>Logische Werte</strong>: Bei einem Ausdruck, der als wahr oder falsch gewertet werden muss (z. B. bei einer IF-Anweisung), wird ein leerer Wert oder ein Wert mit Null als falsch angesehen und die restlichen Werte als wahr. Zum Beispiel wäre die Anweisung <code>if Elementzählung</code> nur falsch, wenn Elementzählung leer oder 0 ist. Der Ausdruck <code>if not Elementzählung</code> würde das Gegenteil zurückgeben.</p>
<p>Operatoren wie NOT/&gt;/=/&lt; erzeugen automatisch einen wahren oder falschen Wert: sie geben eine 1 für True und 0 für False zurück. Die Operatoren AND/OR geben immer einen der Eingabewerte zurück. Im folgenden Beispiel bekommt die <em>Done</em>-Variable eine 1 zugewiesen, wenn A_Index größer als 5 ist, oder der Wert von <em>Gefunden</em>, wenn dies nicht der Fall ist:</p>
<pre>Done := A_Index &gt; 5 or Gefunden</pre>
<p>Wie es bereits oben angedeutet wurde, enthält eine Variable einen falschen Wert, sobald sie leer gemacht oder ihr eine 0 zugewiesen wird. So könnte man mit einer einfachen Anweisung wie <code>if Done</code> überprüfen, ob die Done-Variable wahr oder falsch ist.</p>
<p><span id="True"></span><span id="False"></span>Innerhalb eines Ausdrucks werden die Schlüsselwörter <em>True</em> und <em>False</em> in 1 und 0 aufgelöst. Sie können verwendet werden, um ein Skript besser lesbar zu machen, z. B.:</p>
<pre>Zeichengenauigkeit := false
Weitersuchen := true</pre>
<p id="numbers"><strong>Integer und Gleitkommazahlen</strong>: Innerhalb eines Ausdrucks werden Zahlen mit Dezimalpunkt oder wissentschaftlicher Schreibweise als Gleitkommazahlen angesehen; pure Zahlen sind Integer. Bei den meisten Operatoren -- wie Addition und Multiplikation -- gilt: Wenn einer der Eingabewerte eine Gleitkommazahl ist, wird das Ergebnis auch eine Gleitkommazahl sein.</p>
<p>Innerhalb von Ausdrücken und auch sonst können Zahlen entweder im hexadezimalen oder dezimalen Format geschrieben werden. Hexadezimalzahlen beginnen mit dem 0x-Präfix. Zum Beispiel wäre <code>Sleep 0xFF</code> das gleiche wie <code>Sleep 255</code>. Optional können Gleitkommazahlen mithilfe der wissenschaftlichen Schreibweise angegeben werden, mit oder ohne Dezimalpunkt (z. B. <code>1e4</code> oder <code>-2.1E-4</code>).</p>
<p>Innerhalb von Ausdrücken werden direkt angegebene Zahlen ohne Anführungszeichen wie <code>128</code>, <code>0x7F</code> und <code>1.0</code> in reine Zahlen umgewandelt, bevor das Skript seine Ausführung beginnt. Das heißt, dass die Zahl-Zeichenkette-Konvertierung einen Wert erzeugen würde, der vom originalen direkt geschriebenen Wert abweicht. Zum Beispiel:</p>
<pre>MsgBox(0x7F)  <em>; Zeigt 128</em>
MsgBox(1.00)  <em>; Zeigt 1.0</em></pre>

<h2 id="Operators">Operatoren innerhalb von Ausdrücken</h2>
<p>Operatoren mit gleichwertiger Priorität, wie z. B. Multiplizieren (*) und Dividieren, (/), werden von links nach rechts ausgewertet, sofern nicht anders unten angegeben. Ein Operator mit niedrigerer Priorität, wie z. B. Addieren (+), wird <em>erst</em> ausgewertet, wenn ein höherer Operator, wie z. B. Multiplizieren (*), ausgewertet wurde. Zum Beispiel würde 3 + 2 * 2 wie 3 + (2 * 2) ausgewertet werden. Mit runden Klammern können die Prioritäten wie folgt überschrieben werden: (3 + 2) * 2</p>
<p>In der Regel werden leere Werte (leere Zeichenketten) oder nicht-numerische Werte bei einer mathematischen Operation <strong>nicht</strong> als Null angesehen. Stattdessen werden sie als Fehler behandelt - der Fehler bewirkt, dass dieser Teil des Ausdrucks eine leere Zeichenkette zurückgibt. Wenn beispielsweise eine Variable namens X leer wäre, würde der Ausdruck X+1 einen leeren Wert statt eine 1 zurückgeben.</p>

<h3>Ausdrucksoperatoren (in absteigender Priorität)</h3>
<table class="info">
  <tr id="ref">
    <td style="text-align:center; white-space:nowrap"><strong>%Ausdr%</strong></td>
    <td>
      <p>Wertet den Teilausdruck <em>Ausdr</em> aus und benutzt seinen Wert als Namen oder teilweisen Namen einer Variable oder Funktionen. Dadurch kann das Skript auf eine Variable oder Funktion verweisen, deren Name nicht direkt im Skript vorkommt, aber durch Auswerten von <em>Ausdr</em> ermittelt werden kann, das üblicherweise eine andere Variable ist. Prozentzeichen können wegen ihrer Mehrdeutigkeit nicht direkt in <em>Ausdr</em> benutzt werden, aber sie können innerhalb von runden Klammern ineinander verschachtelt werden. Ansonsten kann <em>Ausdr</em> ein beliebiger Ausdruck sein.</p>
      <p><code>%Ausdr%()</code> bewirkt einen <a href="Functions.htm#DynCall">dynamischen Funktionsaufruf</a>.</p>
      <p><code>%Ausdr%</code> ermittelt dynamisch eine Variable via Name. Das <u>Ergebnis</u> des Teilausdrucks <em>Ausdr</em> muss der komplette oder teilweise Name einer Variable sein, die abgerufen werden soll. Eventuell angrenzende <em>%Ausdr%</em>-Sequenzen und teilweise <a href="#Variable_names">Variablennamen</a> (ohne Leerzeichen oder sonstigen Zeichen dazwischen) werden kombiniert, um einen einzelnen Namen zu bilden.</p>
      <p>Wenn die Variable noch nicht existieren sollte, wird eine leere Variable erstellt. Eine <a href="commands/Throw.htm#Exception">Ausnahme</a> wird ausgelöst, wenn der Name <a href="#Variable_names">ungültig</a> ist.</p>
      <p>Meistens verwendet man diese Methode bei <a href="misc/Arrays.htm#pseudo">Pseudo-Array</a>-Elementen, z. B:</p>
      <pre>Loop 4
    MsgBox("IP-Adresse " A_Index " ist " <a href="#IPAddress">A_IPAddress</a>%<a href="commands/Loop.htm">A_Index</a>%)</pre>
      <p>Auch historisch bekannt als "Doppel-Dereferenzierung", allerdings ist dieser Begriff ungenau, wenn <em>Ausdr</em> keine Variable enthält (erste Derefenzierung), und wenn die resultierende Variable, die das Ziel einer Zuweisung ist, nicht dereferenziert wird (zweite Derefenzierung).</p>
    </td>
  </tr>
  <tr id="objdot">
    <td style="text-align:center"><strong>x.y</strong></td>
    <td><strong>Zugriff auf Objektelemente</strong>. Ruft einen Wert ab, setzt einen Wert oder ruft eine Methode des Objekts <i>x</i> auf. Hierbei muss <i>y</i> ein direkt geschriebener Name sein. Siehe <a href="Objects.htm#Usage_Objects">Objekt-Syntax</a>.</td>
  </tr>
  <tr id="new">
    <td style="text-align:center"><strong>new</strong></td>
    <td><code>new <i>Klasse</i></code> oder <code>new <i>Klasse</i>(<i>Params</i>)</code> erstellt ein neues abgeleitetes Objekt von <em>Klasse</em>. Zum Beispiel wäre <code>x := new y</code> generell das gleiche wie <code>x := {base: y}</code>. <em>Klasse</em> kann nahezu jeder Ausdruck sein, der ein Klassenobjekt erzeugt, und ist üblicherweise ein Klassenname wie <code>GlobaleKlasse</code> oder <code>GlobaleKlasse.Unterklasse</code>. Komplexere Fälle wie <code>new new (getClass())(params1)(params2)</code> werden ebenfalls unterstützt, aber es dürfen kein Leerzeichen zwischen dem Klassenausdruck und der Parameterliste vorkommen. Um mehr darüber zu erfahren, siehe <a href="Objects.htm#Custom_Objects">Benutzerdefinierte Objekte</a>.</td>
  </tr>
  <tr id="IncDec">
    <td style="text-align:center"><strong>++<br>
    
    --</strong></td>
    <td>
      <p><strong>Pre- und Post-Inkrement/Dekrement</strong>. Erhöht oder verringert eine Variable um 1. Der Operator kann entweder vor oder hinter dem Variablennamen erfolgen. Erfolgt der Operator <em>vor</em> dem Namen, wird die Operation sofort durchgeführt und ihr Ergebnis für die nächste Operation bereitgestellt. Zum Beispiel würde <code>Var := ++X</code> die X-Variable sofort erhöhen und ihr Wert in <em>Var</em> speichern. Erfolgt der Operator <em>hinter</em> dem Variablennamen, wird die Operation <em>erst nach</em> der nächsten Operation durchgeführt. Zum Beispiel würde <code>Var := X++</code> die X-Variable erst erhöhen, wenn der aktuelle Wert von X in <em>Var</em> gespeichert wird. Aufgrund der Abwärtskompatibilität behandeln diese Operatoren leere Variablen als Null, sofern sie alleine auf einer Zeile vorkommen; zum Beispiel würde sowohl <code>y := 1, ++x</code> als auch <code>MsgBox ++x</code> ein leeres Ergebnis erzeugen, wenn x leer ist.</p>
      <p>Wenn die Zielvariable leer ist, wird sie von den Operatoren <strong>++</strong> und <strong>--</strong> als Null behandelt. Dadurch kann eine Zeile wie <code>Var++</code> in einem Hotkey benutzt werden, ohne zuerst <em>Var</em> im <a href="Scripts.htm#auto">automatischen Ausführungsbereich</a> initialisieren zu müssen.</p>
    </td>
  </tr>
  <tr id="pow">
    <td style="text-align:center"><strong>**</strong></td>
    <td><strong>Potenz</strong>. Sowohl die Basis als auch der Exponent können einen Dezimalpunkt enthalten. Ist der Exponent negativ, wird das Ergebnis in eine Gleitkommazahl umgewandelt, auch dann, wenn die Basis und der Exponent Integer sind. Da dieser Operator eine höhere Priorität hat als ein einstelliges Minuszeichen, wird <code>-2**2</code> wie <code>-(2**2)</code> ausgewertet und daher -4 zurückgeben. Um eine direkt geschriebene negative Zahl demzufolge potenzieren zu können, muss sie in runden Klammern gesetzt werden, z. B <code>(-2)**2</code> . Hinweis: Eine negative Basis in Verbindung mit einem gebrochenen Exponenten wie <code>(-2)**0.5</code> wird nicht unterstützt; das Ergebnis wird eine leere Zeichenkette sein. Schreibweisen wie <code>(-2)**2</code> und <code>(-2)**2.0</code> werden aber unterstützt.</td>
  </tr>
  <tr id="unary">
    <td style="text-align:center"><strong>-<br>
    
    !<br>
    
    ~<br>
    
    &amp;</strong></td>
    <td>
      <p><strong>Einstelliges Minuszeichen (-)</strong>: Invertiert das Vorzeichen des Operanden.</p>
      <p><strong>Einstelliges Pluszeichen (+)</strong>: <code>+N</code> ist das gleiche wie <code>-(-N)</code>. Bei einer reinen Zahl funktioniert dieser Operator nicht, aber man kann mit diesem Operator numerische Zeichenketten in reine Zahlen umwandeln. Das Ergebnis ist, wie bei jedem anderen mathematischen Operator auch, ein leerer Wert (leere Zeichenkette), wenn der Operand weder eine Zahl noch eine numerische Zeichenkette ist.</p>
      <p><strong>Logisches NICHT (!)</strong>: Ist der Operand leer oder 0, wird das Ergebnis mit einem logischen NICHT eine 1 sein, also "wahr". Ansonsten ist das Ergebnis eine 0 (falsch). Zum Beispiel: <code>!x or !(y and z)</code>. Hinweis: Das Wort NOT ist das gleiche wie <strong>!</strong>, aber <strong>!</strong> hat eine höhere Priorität. Aufeinanderfolgende einstellige Operatoren wie <code><strong>!!</strong>Var</code> sind erlaubt, weil sie von rechts nach links ausgewertet werden.</p>
      <p><strong>Bitweises NICHT (~)</strong>: Invertiert jedes Bit seines Operanden. Ist der Operand eine Gleitkommazahl, wird er vor der Berechnung auf einen Integer gekürzt. Liegt der Operand zwischen 0 und 4294967295 (0xffffffff), wird er als <u>vorzeichenloser</u> 32-Bit-Wert behandelt. Ansonsten wird er als <u>vorzeichenbehafteter</u> 64-Bit-Wert behandelt. Zum Beispiel wäre <code>~0xf0f</code> dann 0xfffff0f0 (4294963440).</p>
      <p id="amp"><strong>Adresse (&amp;)</strong>: <code>&amp;MeineVar</code> ermittelt die Adresse des Speicherinhalts von <em>MeineVar</em>. Solche Adressen sind üblicherweise bei <a href="commands/DllCall.htm#struct">DllCall-Strukturen</a> nützlich. Der Inhalt von <em>MeineVar</em> kann eine Zeichenkette, ein 64-Bit-Integer, eine 64-Bit-Gleitkommazahl oder ein Objekt sein.</p>
    </td>
  </tr>
  <tr id="MulDiv">
    <td style="text-align:center"><strong>*<br>
    
    /<br>
    
    //
    
    </strong></td>
    <td><p><strong>Multiplizieren (*)</strong>: Das Ergebnis ist ein Integer, wenn beide Eingabewerte Integer sind, ansonsten ist es eine Gleitkommazahl.</p>
      <p><strong>Andere Verwendungen</strong>: Das Sternchensymbol (*) wird auch bei <a href="Functions.htm#VariadicCall">variadischen Funktionsaufrufen</a> benutzt.</p>
      <p id="divide"><strong>Echtes Dividieren (/)</strong>: Die echte Division wird immer eine Gleitkommazahl zurückgeben, sogar wenn beide Eingabewerte Integer sind. Zum Beispiel wäre <code>3/2</code> gleich 1.5 statt 1, und <code>4/2</code> gleich 2.0 statt 2.</p>
      <p id="FloorDivide"><strong>Floor-Dividieren (//)</strong>: Der Doppel-Schrägstrich-Operator verwendet die leistungsstarke Integer-Division, wenn beide Eingabewerte Integer sind. Zum Beispiel wäre <code>5//3</code> gleich 1 und <code>5//-3</code> gleich -1. Wenn einer der beiden Eingabewerte eine Gleitkommazahl ist, wird die Gleitkomma-Division erfolgen und das Ergebnis auf den nächstmöglichen linksbefindlichen Integer gekürzt. Zum Beispiel wäre <code>5//3.0</code> gleich 1.0 und <code>5.0//-3</code> gleich -2.0. Das Ergebnis wird im Gleitkommaformat gespeichert, selbst wenn das Ergebnis dieser Gleitkomma-Division ein Integer ist. Für Modulo, siehe <a href="commands/Math.htm#Mod">Mod</a>.</p>
    <p>Die Operatoren <a href="#AssignOp">*=</a> und <a href="#AssignOp">/=</a> sind eine Kurzschreibweise, um den Wert in einer Variable mit einem anderen Wert zu multiplizieren oder dividieren. Zum Beispiel würde <code>Var *= 2</code> das gleiche Ergebnis wie <code>Var := Var * 2</code> erzeugen (die erste Methode ist performanter).</p>
    <p>Eine Division durch 0 erzeugt ein leeres Ergebnis (leere Zeichenkette).</p></td>
  </tr>
  <tr id="AddSub">
    <td style="text-align:center"><strong>+<br>
    
    -</strong></td>
    <td><p><strong>Addieren (+)</strong> und <strong>Subtrahieren (-)</strong>. Die Operatoren <a href="#AssignOp"><strong>+=</strong></a> und <a href="#AssignOp"><strong>-=</strong></a> sind eine Kurzschreibweise zum Erhöhen oder Verringern einer Variable. Zum Beispiel würde <code>Var += 2</code> das gleiche Ergebnis wie <code>Var := Var + 2</code> erzeugen (die erste Methode ist performanter). Desweiteren kann mit <a href="#IncDec">Var++, Var--, ++Var oder --Var</a> eine Variable auf einfache Weise um 1 erhöht oder verringert werden.</p>
      <p><strong>Andere Verwendungen</strong>: Wenn das Plus- oder Minuszeichen keinen Wert (oder Teilausdruck, der einen Wert zurückgibt) davor hat, wird es stattdessen als <a href="#unary">einstelliger Operator</a> interpretiert.</p>
    </td>
  </tr>
  <tr id="bitshift">
    <td style="text-align:center"><strong>&lt;&lt;<br>
    
    &gt;&gt;</strong></td>
    <td><strong>Bitweise Verschiebung nach links (&lt;&lt;)</strong> und <strong>nach rechts (&gt;&gt;)</strong>. Anwendungsbeispiel: <code>Wert1 &lt;&lt; Wert2</code>. Jeder Eingabewert im Gleitkommaformat wird zu einem Integer gekürzt, bevor die Berechnung erfolgt. Die bitweise Verschiebung nach links (<strong>&lt;&lt;</strong>) wäre das gleiche wie, als würde man <em>Wert1</em> mit "2, potenziert um <em>Wert2</em>" multiplizieren. Die bitweise Verschiebung nach rechts (<strong>&gt;&gt;</strong>) wäre das gleiche wie, als würde man <em>Wert1</em> mit "2, potenziert um <em>Wert2</em>" dividieren und das Ergebnis dann auf den nächstmöglichen Integer auf der Zahlenreihe runden; zum Beispiel wäre <code>-3&gt;&gt;1</code> gleich -2.</td>
  </tr>
  <tr id="bitwise">
    <td style="text-align:center"><strong>&amp;<br>
      
      ^<br>
      
      |
    
    </strong></td>
    <td>
      <p><strong>Bitweises UND (&amp;)</strong>, <strong>bitweises exklusives ODER (^)</strong> und <strong>bitweises ODER (|)</strong>. Von diesen drei Operatoren hat <strong>&amp;</strong> die höchste Priorität und <strong>|</strong> die niedrigste Priorität. Jeder Eingabewert im Gleitkommaformat wird zu einem Integer gekürzt, bevor die Berechnung erfolgt.</p>
      <p>Siehe auch: <a href="#unary">Bitweises NICHT (~)</a></p>
      <p><strong>Andere Verwendungen</strong>: Wenn das Und-Zeichen keinen Wert (oder Teilausdruck, der einen Wert zurückgibt) davor hat, wird es stattdessen als <a href="#unary">Adressoperator</a> interpretiert.</p>
  </td></tr>
  <tr id="concat">
    <td style="text-align:center"><strong>.</strong></td>
    <td>
      <p><strong>Verkettung</strong>. Ein Punkt mit mindestens einem Leer- oder Tabulatorzeichen auf jeder Seite dient dazu, zwei Elemente zu einer einzigen Zeichenkette zusammenzuführen. Den Punkt kann man weglassen, um das gleiche zu erreichen (außer bei Zweideutigkeiten wie <code>x <strong>-</strong>y</code>, oder wenn das rechtsbefindliche Element ein ++ oder -- davor hat). Wenn man den Punkt weglässt, müssen Elemente, die zusammengeführt werden sollen, mit mindestens einem Leer- oder Tabulatorzeichen voneinander getrennt werden.</p>
      <pre>Var := "Die Farbe ist " <strong>.</strong> GefundeneFarbe  <em>; Explizite Verkettung</em>
Var := "Die Farbe ist " GefundeneFarbe    <em>; Auto-Verkettung</em>
</pre>
      <p>Teilausdrücke kann man auch verketten. Zum Beispiel: <code>Var := "Der Nettopreis ist " <strong>.</strong> Preis * (1 - Rabatt/100)</code>.</p>
      <p>Eine Zeile, die mit einem Punkt (oder beliebig anderen Operator) beginnt, wird automatisch mit der Zeile darüber <a href="Scripts.htm#continuation">verbunden</a>.</p>
      <p>Es wird immer die komplette <a href="commands/StrLen.htm">Länge</a> von jedem Eingabewert benutzt, sogar wenn binäre Nullen enthalten sind. Zum Beispiel würde <code>Chr(0x2010) Chr(0x0000) Chr(0x4030)</code> die folgende Byte-Kette erzeugen (wegen der UTF-16-LE-Codierung): 0x10, 0x20, 0, 0, 0x30, 0x40. Das Ergebnis hat einen zusätzlichen Null-Terminator (binäre Null), der in der Länge nicht enthalten ist.</p>
      <p><strong>Andere Verwendungen</strong>: Wenn auf der rechten Seite eines Punktes kein Leer- oder Tabulatorzeichen vorkommt, wird es entweder als <a href="#numbers">Gleitkommazahl</a> oder als <a href="#objdot">Zugriff auf ein Objektelement</a> interpretiert. Zum Beispiel ist <code>1.1</code> oder <code>(.5)</code> eine Zahl, <code>A_Args.Length()</code> ein Methodenaufruf und <code>meinArray.1</code> das gleiche wie <code>meinArray[1]</code>.</p>
    </td>
  </tr>
  <tr id="regex">
    <td style="text-align:center"><strong>~=</strong></td>
    <td>Kurzschreibweise für <a href="commands/RegExMatch.htm">RegExMatch</a>. Zum Beispiel würde <code>"abc123" ~= "\d"</code> eine 4 zurückgeben (die Position des ersten numerischen Zeichens).</td>
  </tr>
  <tr id="compare">
    <td style="text-align:center"><strong>&gt;&nbsp;&nbsp;&nbsp;&lt;<br>
    
    &gt;= &lt;=</strong></td>
    <td>
      <p><strong>Größer (&gt;)</strong>, <strong>kleiner (&lt;)</strong>, <strong>größer gleich (&gt;=)</strong> und <strong>kleiner gleich (&lt;=)</strong>. Wenn einer der beiden Eingabewerte nicht-numerisch ist (oder wenn beide Zeichenketten sind), werden sie alphabetisch verglichen. Zum Beispiel wäre 2 &lt; "10" <em>True</em>, während "2" &lt; "10" <em>False</em> ist. Der Vergleich unterscheidet nur zwischen Groß- und Kleinschreibung, wenn <a href="commands/StringCaseSense.htm">StringCaseSense</a> aktiviert ist. Siehe auch: <a href="commands/Sort.htm">Sort</a></p>
      <p>Bei einem Zeichenkettenvergleich werden diese Operatoren nur Zeichenketten bis zur ersten binären Null vergleichen.</p>
    </td>
  </tr>
  <tr id="equal">
    <td style="text-align:center"><strong>=<br>
      
      ==<br>
    
    &lt;&gt; !=</strong></td>
    <td>
      <p><strong>Gleich (=)</strong>, <strong>zeichengenau gleich (==)</strong> und <strong>ungleich (&lt;&gt; oder !=)</strong>. Funktionsgemäß sind die Operatoren <strong>!=</strong> und <strong>&lt;&gt;</strong> identisch. Die Operatoren <strong>==</strong> und <strong>=</strong> verhalten sich gleich. Sobald jedoch einer der Eingabewerte nicht-numerisch ist (oder beide Zeichenketten sind), wird <strong>==</strong> zwischen Groß- und Kleinschreibung unterscheiden, während <strong>=</strong> dies nicht tut (die Nichtunterscheidungsmethode ist abhängig von <a href="commands/StringCaseSense.htm">StringCaseSense</a>). Die Operatoren <strong>&lt;&gt;</strong> und <strong>!=</strong> berücksichtigen <a href="commands/StringCaseSense.htm">StringCaseSense</a>.</p>
      <p>Mit dem <strong>==</strong>-Operator können Zeichenketten verglichen werden, die binäre Nullen enthalten. Alle anderen Vergleichsoperatoren, außer <strong>~=</strong>, vergleichen nur bis zur ersten binären Null. </p>
    </td>
  </tr>
  <tr>
    <td align="center"><strong>IS</strong><br><strong>IN</strong><br><strong>CONTAINS</strong></td>
    <td id="is">
      <p><code><i>Wert</i> <strong>is</strong> <i>Typ</i></code>: Gibt True (1) zurück, wenn <em>Wert</em> der angegebene <em>Typ</em> ist, oder ansonsten False (0). Siehe <a href="commands/is.htm"><em>Wert</em> is <em>Typ</em></a>, um mehr darüber zu erfahren.</p>
      <p><code id="in"><strong>in</strong></code> und <code id="contains"><strong>contains</strong></code> sind für die zukünftige Verwendung reserviert.</p>
    </td>
  </tr>
  <tr id="not">
    <td style="text-align:center"><strong>NOT</strong></td>
    <td><strong>Logisches NICHT</strong>. Abgesehen von seiner geringeren Priorität, ist dieser Operator funktionsgemäß identisch mit dem <strong>!</strong>-Operator. Zum Beispiel wäre <code>not (x = 3 or y = 3)</code> das gleiche wie <code><strong>!</strong>(x = 3 or y = 3)</code>.</td>
  </tr>
  <tr id="and">
    <td style="text-align:center"><strong>AND<br>
    
    &amp;&amp;</strong></td>
    <td><p>Beide sind ein <strong>logisches UND</strong>. Zum Beispiel: <code>x &gt; 3 and x &lt; 10</code>.</p>
      <p>In dem Ausdruck <code>x and y</code> ist y das Ergebnis, wenn x <a href="#Boolean">True</a> ist. Ansonsten ist x das Ergebnis, und y wird überhaupt nicht ausgewertet - zur Verbesserung der Performance wird die <a href="Functions.htm#ShortCircuit">Kurzschlussauswertung</a> angewendet. Das Ergebnis muss nicht unbedingt eine logische 0 oder 1 sein, allerdings kann es als <a href="#Boolean">logischer</a> Wert interpretiert werden, wie jeder anderer Ausdruck auch. Tatsächlich kann das Ergebnis nur True sein, wenn beide Eingabewerte auch True sind.</p>
      <p>Eine Zeile, die mit AND/OR/&amp;&amp;/|| (oder ein beliebig anderer Operator) beginnt, wird automatisch mit der darüberliegenden Zeile <a href="Scripts.htm#continuation">verbunden</a>.</p>
      </td>
  </tr>
  <tr id="or">
    <td style="text-align:center"><strong>OR<br>
    
    ||</strong></td>
    <td><p>Beide sind ein <strong>logisches ODER</strong>. Zum Beispiel: <code>x &lt;= 3 or x &gt;= 10</code>.</p>
      <p>In dem Ausdruck <em>x or y</em> ist y das Ergebnis, wenn x <a href="#Boolean">False</a> ist. Ansonsten ist x das Ergebnis, und y wird überhaupt nicht ausgewertet - zur Verbesserung der Performance wird die <a href="Functions.htm#ShortCircuit">Kurzschlussauswertung</a> angewendet. Das Ergebnis muss nicht unbedingt eine logische 0 oder 1 sein, allerdings kann es als <a href="#Boolean">logischer</a> Wert interpretiert werden, wie jeder anderer Ausdruck auch. Tatsächlich kann das Ergebnis nur True sein, wenn einer der beiden Eingabewerte auch True ist.</p></td>
  </tr>
  <tr id="ternary">
    <td style="text-align:center"><strong>?:</strong></td>
    <td><p><strong>Ternärer Operator</strong>. Dieser Operator ist die Kurzschreibweise für eine <a href="commands/IfExpression.htm">if-else-Anweisung</a>. Der Operator wertet die Bedingung auf seiner linken Seite aus, um festzustellen, welche der beiden Verzweigungen das Endergebnis sein soll. Zum Beispiel würde <code>Var := x&gt;y ? 2 : 3</code> eine 2 in <em>Var</em> speichern, falls x größer als y ist; ansonsten wird eine 3 gespeichert. Zur Verbesserung der Performance wird nur die gewinnende Verzweigung ausgewertet (siehe <a href="Functions.htm#ShortCircuit">Kurzschlussauswertung</a>).</p></td>
  </tr>
  <tr id="AssignOp">
    <td style="text-align:center"><strong>:=<br>
        
        +=<br>
        
        -=<br>
        
        *=<br>
        
        /=<br>
        
        //=<br>
        
        .=<br>
        
        |=<br>
        
        &amp;=<br>
        
        ^=<br>
        
        &gt;&gt;=<br>
        
        &lt;&lt;=</strong>
    </td>
    <td><p><strong>Zuweisung</strong>. Führt eine Operation auf den Inhalt einer Variable aus und speichert das Ergebnis wieder in die gleiche Variable. Der einfachste Zuweisungsoperator ist das <a href="commands/SetExpression.htm">Doppelpunkt-Gleich (:=)</a> - dieser Operator kann das Ergebnis eines Ausdrucks in eine Variable speichern. Da sie eine Kurzschreibweise eines Operators ist, findest du ihre Beschreibung jeweils beim dazugehörigen Operator in dieser Tabelle. Beispiel 1: <code>Var //= 2</code> führt eine <a href="#FloorDivide">Floor-Division</a> durch, um <em>Var</em> mit 2 zu teilen, und speichert dann das Ergebnis wieder in <em>Var</em>. Beispiel 2: <code>Var <strong>.=</strong> "abc"</code> ist die Kurzschreibweise für <code>Var := Var <strong>.</strong> "abc"</code>.</p>
      <p>Im Gegensatz zu den meisten anderen Operatoren werden Zuweisungen von rechts nach links ausgewertet. Demzufolge würde eine Zeile wie <code>Var1 := Var2 := 0</code> eine 0 in <em>Var2</em> speichern und dann <em>Var2</em> in <em>Var1</em> speichern.</p>
    <p>Verwendet man eine Zuweisung als Eingabewert eines anderen Operators, wird ihr Wert die Variable selbst sein. Zum Beispiel wäre der Ausdruck <code>(Var += 2) &gt; 50</code> wahr, wenn der gerade eben erhöhte Wert in <em>Var</em> größer als 50 ist. Mit diesem Verfahren könnte man auch eine Zuweisung via <a href="Functions.htm#ByRef">ByRef</a> übergeben oder ihre <a href="#amp">Adresse</a> verwenden; zum Beispiel: <code>&amp;(x:="abc")</code>.</p>
    <p>Die Priorität der Zuweisungsoperatoren erhöht sich automatisch, wenn dadurch ein Syntaxfehler verhindert oder ein besseres Verhalten bereitgestellt werden kann. Zum Beispiel: Die Auswertung von <code>not x := y</code> entspräche <code>not (x := y)</code>, <code>++Var := X</code> entspräche <code>++(Var := X)</code>; und <code>Z &gt; 0 ? X := 2 : Y := 2</code> entspräche <code>Z &gt; 0 ? (X := 2) : (Y := 2)</code>.</p>
    <p>Wenn die Zielvariable leer ist, wird sie von den Operatoren <strong>+=</strong> und <strong>-=</strong> als Null behandelt. Dadurch kann eine Zeile wie <code>Var += 1</code> in einem Hotkey benutzt werden, ohne zuerst <em>Var</em> im <a href="Scripts.htm#auto">automatischen Ausführungsbereich</a> initialisieren zu müssen.</p>
    </td>
  </tr>
  <tr id="comma">
    <td style="text-align:center"><strong>,</strong></td>
    <td><p><strong>Komma (mehrere Anweisungen)</strong>. Kommas können verwendet werden, um mehrere Teilausdrücke nebeneinander zu setzen. Es ist eine häufig eingesetzte Methode, um mehrere Zuweisungen oder Funktionsaufrufe zu gruppieren. Zum Beispiel: <code>x:=1<strong>,</strong> y+=2<strong>,</strong> ++index, func()</code>. Solche Anweisungen werden von links nach rechts ausgeführt. Hinweis: Eine Zeile, die mit einem Komma (oder einem anderen Operator) beginnt, wird automatisch mit der darüberliegenden Zeile <a href="Scripts.htm#continuation">verbunden</a>. Siehe auch: <a href="#CommaPerf">Komma-Performance</a>.</p>
        <p>Wenn man einen Mehrfachanweisungsausdruck innerhalb eines anderen Ausdrucks benutzt, wird jeder Teilausdruck ausgewertet und der Wert des finalen (ganz rechts befindlichen) Teilausdrucks als Endergebnis des kompletten Ausdrucks verwendet. Zum Beispiel würde <code>x := (++y, 1)</code> die y-Variable um 1 erhöhen und in x die Nummer 1 speichern.</p>
      <p>Ein Komma wird auch benutzt, um die Parameter eines Funktionsaufrufs oder einer Ablaufsteuerungsanweisung voneinander zu trennen. Um einen Ausdruck mit mehreren Anweisungen in eine Parameterliste einfügen zu können, muss er mit einem zusätzlichen Paar von runden Klammern umschlossen werden. Zum Beispiel würde <code>MeineFn((x, y))</code> sowohl x als auch y auswerten, aber y als ersten und einzigen Parameter von MeineFn übergeben.</p>
    </td>
  </tr>
</table>
<p>Die folgenden Typen von Teilausdrücken überschreiben die Priorität/Reihenfolge der Auswertung:</p>
<table class="info">
  <tr>
    <td style="text-align:center"><strong>(</strong><em>Ausdruck</em><strong>)</strong></td>
    <td><p>Jeder Teilausdruck, der von runden Klammern umschlossen ist. Zum Beispiel würde <code>(3 + 2) * 2</code> bewirken, dass <code>3 + 2</code> zuerst ausgewertet wird.</p></td>
  </tr>
  <tr>
    <td style="text-align:center; white-space:nowrap"><p><strong>Mod<br>
        
        Round<br>
    
    Abs</strong></p></td>
    <td><strong>Funktionsaufruf</strong>. Nach dem Funktionsnamen muss direkt eine runde Startklammer erfolgen, ohne Leer- oder Tabulatorzeichen dazwischen. Siehe <a href="Functions.htm">Funktionen</a>, um mehr zu erfahren.</td>
  </tr>
  <tr>
    <td style="text-align:center; white-space:nowrap"><p><strong>%</strong><em>Funk</em><strong>%()</strong></p></td>
    <td>Siehe <a href="Functions.htm#DynCall">Dynamisches Aufrufen einer Funktion</a>.</td>
  </tr>
  <tr>
    <td style="text-align:center">Fn(<strong><em>Params</em>*</strong>)</td>
    <td><p><a href="Functions.htm#VariadicCall">Variadischer Funktionsaufruf</a>. <em>Params</em> ist ein Array (Objekt) mit Parameterwerten.</p></td>
  </tr>
  <tr id="square-brackets">
    <td style="text-align:center"><strong>x[y]<br>[a, b, c]</strong></td>
    <td>
      <p><strong>Zugriff auf Objektelemente</strong>. Ruft einen Wert ab, setzt einen Wert oder ruft eine Methode des Objekts <i>x</i> auf. Hierbei kann <i>y</i> eine Parameterliste sein, oder ein Ausdruck, der einen Methodennamen zurückgibt.</p>
      <p><strong>Direkte Array-Schreibweise</strong>. Wenn die eckige Startklammer keinen Wert (oder Teilausdruck, der einen Wert zurückgibt) davor hat, wird sie stattdessen als Beginn eines direkt geschriebenen Arrays interpretiert. Zum Beispiel ist <code>[a, b, c]</code> das gleiche wie <code>Array(a, b, c)</code> (a, b und c sind Variablen).</p>
      <p>Siehe <a href="Objects.htm#Usage_Simple_Arrays">Array-Syntax</a> und <a href="Objects.htm#Usage_Objects">Objekt-Syntax</a>, um mehr zu erfahren.</p>
    </td>
  </tr>
  <tr id="curly-braces">
    <td style="text-align:center"><strong>{a: b, c: d}</strong></td>
    <td><p><strong>Direkte Objekt-Schreibweise</strong>. Erstellt ein Objekt oder assoziatives Array. Zum Beispiel ist <code>x := {a: b}</code> das gleiche wie <code>x := Object("a", b)</code> oder <code>x := Object(), x.a := b</code>. Siehe <a href="Objects.htm#Usage_Associative_Arrays">Assoziative Arrays</a>, um mehr zu erfahren.</p></td>
  </tr>
</table>
<br>
<p id="CommaPerf"><strong>Performance</strong>: Man erzielt häufig bessere Performance, wenn man mehrere aufeinanderfolgende Ausdrücke mit dem Komma-Operator trennt, besonders wenn es darum geht, eine Variable in eine andere Variable zu speichern (z. B. <code>x := y, a := b</code>). Je mehr Ausdrücke zu einem einzigen Ausdruck verbunden werden, desto höher ist die Performance; zum Beispiel könnte man ein Geschwindigkeitszuwachs von 35 % erreichen, wenn man fünf oder zehn einfache Ausdrücke zu einem Ausdruck kombinieren würde.</p>

<h2 id="BuiltIn">Built-in-Variablen</h2>
<p>Die folgenden Variablen sind fest in das Programm integriert und normal abrufbar. Solche Variablen sind schreibgeschützt, sofern nicht anders angegeben; das heißt, dass man deren Inhalte nicht direkt ändern kann.</p>
<h3>Inhaltsverzeichnis</h3>
<ul>
  <li>Sonderzeichen: <a href="#Space">A_Space</a>, <a href="#Tab">A_Tab</a></li>
  <li>Skript-Eigenschaften: <a href="#Args">Befehlszeilenparameter</a>, <a href="#WorkingDir">A_WorkingDir</a>, <a href="#ScriptDir">A_ScriptDir</a>, <a href="#ScriptName">A_ScriptName</a>, <a href="#prop">(...mehr...)</a></li>
  <li>Datum und Zeit: <a href="#YYYY">A_YYYY</a>, <a href="#MM">A_MM</a>, <a href="#DD">A_DD</a>, <a href="#Hour">A_Hour</a>, <a href="#Min">A_Min</a>, <a href="#Sec">A_Sec</a>, <a href="#date">(...mehr...)</a></li>
  <li>Skript-Einstellungen: <a href="#IsSuspended">A_IsSuspended</a>, <a href="#TitleMatchMode">A_TitleMatchMode</a>, <a href="#settings">(...mehr...)</a></li>
  <li>Abwesenheit des Benutzers: <a href="#TimeIdle">A_TimeIdle</a>, <a href="#TimeIdlePhysical">A_TimeIdlePhysical</a></li>
  <li>Hotkeys, Hotstrings und benutzerdefinierte Menüpunkte: <a href="#ThisHotkey">A_ThisHotkey</a>, <a href="#EndChar">A_EndChar</a>, <a href="#ThisMenuItem">A_ThisMenuItem</a>, <a href="#h">(...mehr...)</a></li>
  <li>Betriebssystem und Benutzerinformationen: <a href="#OSVersion">A_OSVersion</a>, <a href="#Screen">A_ScreenWidth</a>, <a href="#Screen">A_ScreenHeight</a>, <a href="#os">(...mehr...)</a></li>
  <li>Sonstiges: <a href="#Cursor">A_Cursor</a>, <a href="#Caret">A_CaretX</a>, <a href="#Caret">A_CaretY</a>, <a href="#EventInfo">A_EventInfo</a>, <a href="misc/Clipboard.htm">Clipboard</a>, <a href="misc/Clipboard.htm#ClipboardAll">ClipboardAll</a>, <a href="misc/ErrorLevel.htm">ErrorLevel</a></li>
  <li>Loop: <a href="#Index">A_Index</a>, <a href="#loop">(...mehr...)</a></li>
</ul>
<h3>Sonderzeichen</h3>
<table class="info">
  <tr id="Space">
    <td>A_Space</td>
    <td>Enthält ein einzelnes Leerzeichen.</td>
  </tr>
  <tr id="Tab">
    <td>A_Tab</td>
    <td>Enthält ein einzelnes Tabulatorzeichen.</td>
  </tr>
</table>
<h3 id="prop">Skript-Eigenschaften</h3>
<table class="info">
  <tr id="Args">
    <td>A_Args</td>
    <td><strong>Liest/Schreibt</strong> einen <a href="Objects.htm#Usage_Simple_Arrays">Array</a> mit Befehlszeilenparametern. Weitere Informationen findet man unter "<a href="Scripts.htm#cmd">Befehlszeilenparameter an ein Skript übergeben</a>".</td>
  </tr>
  <tr id="WorkingDir">
    <td>A_WorkingDir</td>
    <td><p><strong>Liest/Schreibt</strong> das aktuelle Arbeitsverzeichnis, wo das Skript standardmäßig auf Dateien zugreift. Der letzte umgekehrte Schrägstrich ist nicht enthalten, sofern es nicht das Stammverzeichnis ist. Zwei Beispiele: <code>C:\</code> und <code>C:\Meine Dokumente</code>.</p>
    <p>Alternativ kann mit <a href="commands/SetWorkingDir.htm">SetWorkingDir</a> das Arbeitsverzeichnis geändert werden.</p>
    <p>Das Arbeitsverzeichnis des Skripts ist standardmäßig immer A_ScriptDir, egal wie das Skript gestartet wurde.</p></td>
  </tr>
  <tr id="InitialWorkingDir">
    <td>A_InitialWorkingDir</td>
    <td>Das anfängliche Arbeitsverzeichnis richtet sich danach, wie das Skript gestartet wurde. Startet man das Skript beispielsweise über eine Verknüpfung (z. B. via Startmenü), wird sein initiales Arbeitsverzeichnis durch das Feld "Ausführen in" im Eigenschaftsfenster dieser Verknüpfung bestimmt.</td>
  </tr>
  <tr id="ScriptDir">
    <td>A_ScriptDir</td>
    <td>Der vollständige Pfad des Verzeichnisses, wo das aktuelle Skript zu finden ist. Der letzte umgekehrte Schrägstrich wird weggelassen (auch bei Stammverzeichnissen).</td>
  </tr>
  <tr id="ScriptName">
    <td>A_ScriptName</td>
    <td><strong>Lesen/Schreiben:</strong> Der Standardtitel für MsgBox, InputBox, FileSelect, DirSelect und GuiCreate. Wenn dieser Variable keinen Wert zugewiesen wird, gilt standardmäßig der Dateiname des aktuellen Skripts, ohne Pfad, z. B. MeinSkript.ahk.</td>
  </tr>
  <tr id="ScriptFullPath">
    <td>A_ScriptFullPath</td>
    <td>Der vollständige Pfad des aktuellen Skripts, z. B. C:\Meine Dokumente\MeinSkript.ahk.</td>
  </tr>
  <tr id="ScriptHwnd">
    <td>A_ScriptHwnd</td>
    <td>Die eindeutige ID (HWND/Handle) des versteckten Skript-Hauptfensters.</td>
  </tr>
  <tr id="LineNumber">
    <td>A_LineNumber</td>
    <td><p>Die Nummer der aktuell ausgeführten Zeile innerhalb des Skripts (oder die Zeile aus einer <a href="commands/_Include.htm">#Include-Datei</a>). Diese Zeilennummer kann man auch in <a href="commands/ListLines.htm">ListLines</a> finden; sie kann nützlich zum Melden eines Fehlers sein, z. B.: <code>MsgBox "Eine Zeile konnte nicht in die Log-Datei geschrieben werden (Zeilennummer " A_LineNumber ")"</code>.</p>
    <p>Die Zeilennummern eines <a href="Scripts.htm#ahk2exe">kompilierten Skripts</a> können sich von den Zeilennummern der unkompilierten Version unterscheiden, weil bei der Kompilierung das Skript und seine <a href="commands/_Include.htm">#Include-Dateien</a> in eine große Skriptdatei umgewandelt werden.</p></td>
  </tr>
  <tr id="LineFile">
    <td>A_LineFile</td>
    <td>Der vollständige Pfad der Datei, auf der sich <a href="#LineNumber">A_LineNumber</a> bezieht, und prinzipiell das gleiche ist wie <a href="#ScriptFullPath">A_ScriptFullPath</a>, sofern die Zeile nicht zu einer <a href="commands/_Include.htm">#Include-Datei</a> eines unkompilierten Skripts gehört.</td>
  </tr>
  <tr id="ThisFunc">
    <td>A_ThisFunc</td>
    <td>Der Name der <a href="Functions.htm">benutzerdefinierten Funktion</a>, die gerade ausgeführt wird (ansonsten leer); zum Beispiel: MeineFunktion. Siehe auch: <a href="commands/IsFunc.htm">IsFunc</a></td>
  </tr>
  <tr id="ThisLabel">
    <td>A_ThisLabel</td>
    <td>Der Name des <a href="misc/Labels.htm">Labels</a> (Subroutine), das gerade ausgeführt wird (ansonsten leer); zum Beispiel: MeinLabel. A_ThisLabel wird aktualisiert, wann immer das Skript <a href="commands/Gosub.htm">Gosub</a>/<a href="commands/Return.htm">Return</a> oder <a href="commands/Goto.htm">Goto</a> ausführt. A_ThisLabel wird auch aktualisiert, wenn automatisch-aufgerufene Labels wie <a href="commands/SetTimer.htm">Timer</a>, <a href="objects/GuiOnEvent.htm#Threads">GUI-Threads</a>, <a href="commands/Menu.htm">Menüpunkte</a>, <a href="Hotkeys.htm">Hotkeys</a> und <a href="Hotstrings.htm">Hotstrings</a> erfolgen. A_ThisLabel wird nicht aktualisiert, wenn die Skriptausführung in eines der oben genannten Label "gelangt"; in diesem Fall behält A_ThisLabel seinen vorherigen Wert. Siehe auch: <a href="#ThisHotkey">A_ThisHotkey</a> und <a href="commands/IsLabel.htm">IsLabel</a></td>
  </tr>
  <tr id="AhkVersion">
    <td>A_AhkVersion</td>
    <td>Enthält die Version des AutoHotkey-Programms, mit dem das Skript ausgeführt wird, z. B. 1.0.22. In einem <a href="Scripts.htm#ahk2exe">kompilierten Skript</a> wird die Version des AutoHotkey-Programms zurückgegeben, mit der das Skript ursprünglich kompiliert worden ist. Aufgrund der Struktur der Versionsnummer kann ein Skript mit "&gt;" oder "&gt;=" überprüfen, ob A_AhkVersion größer als eine bestimmte Versionsnummer ist: <code>if (A_AhkVersion &gt;= "1.0.25.07")</code>.</td>
  </tr>
  <tr id="AhkPath">
    <td>A_AhkPath</td>
    <td><p>Bei unkompilierten Skripten: Der vollständige Pfad der EXE-Datei, mit der das aktuelle Skript gerade ausgeführt wird. Zum Beispiel: C:\Program Files\AutoHotkey\AutoHotkey.exe</p>
    <p>Bei <a href="Scripts.htm#ahk2exe">kompilierten Skripten</a>: Das gleiche wie oben, allerdings wird das AutoHotkey-Verzeichnis mithilfe des Registry-Eintrags <em>HKEY_LOCAL_MACHINE\SOFTWARE\AutoHotkey\InstallDir</em> ermittelt. Wenn es so einen Eintrag nicht gibt, wird A_AhkPath leer gemacht.</p></td>
  </tr><!--tr id="IsUnicode">
    <td>A_IsUnicode</td>
    <td>Contains 1 if strings are Unicode (16-bit) and an empty string (which is considered <a href="#Boolean">false</a>) if strings are ANSI (8-bit). The format of strings depends on the version of AutoHotkey.exe which is used to run the script, or if it is compiled, which bin file was used to compile it.</td>
  </tr-->
  
  <tr id="IsCompiled">
    <td>A_IsCompiled</td>
    <td>Enthält eine 1, wenn das Skript als <a href="Scripts.htm#ahk2exe">kompilierte EXE-Datei</a> ausgeführt wird, oder eine leere Zeichenkette (das als <a href="#Boolean">falsch</a> angesehen wird), wenn das nicht der Fall ist.</td>
  </tr>
</table>
<h3 id="date">Datum und Zeit</h3>
<table class="info">
  <tr id="YYYY">
    <td>A_YYYY</td>
    <td>Das aktuelle 4-stellige Jahr (z. B. 2004). Synonym für A_Year. Hinweis: Wenn der Zeit- oder Datumswert in einem Format angezeigt werden soll, das deinem Gebietsschema oder deiner Sprache entspricht, dann verwende <code><a href="commands/FormatTime.htm">FormatTime</a>()</code> (Zeit und langes Datum) oder <code><a href="commands/FormatTime.htm">FormatTime</a>(, "LongDate")</code> (ermittelt ein Datum im langen Format).</td>
  </tr>
  <tr id="MM">
    <td>A_MM</td>
    <td>Der aktuelle zweistellige Monat (01-12). Synonym für A_Mon.</td>
  </tr>
  <tr id="DD">
    <td>A_DD</td>
    <td>Der aktuelle zweistellige Tag des Monats (01-31). Synonym für A_MDay.</td>
  </tr>
  <tr id="MMMM">
    <td>A_MMMM</td>
    <td>Der aktuelle vollständige Monatsname in der aktuellen Sprache des Benutzers, z. B. Juli</td>
  </tr>
  <tr id="MMM">
    <td>A_MMM</td>
    <td>Der aktuelle abgekürzte Monatsname in der aktuellen Sprache des Benutzers, z. B. Jul</td>
  </tr>
  <tr id="DDDD">
    <td>A_DDDD</td>
    <td>Der aktuelle vollständige Wochentagsname in der aktuellen Sprache des Benutzers, z. B. Sonntag</td>
  </tr>
  <tr id="DDD">
    <td>A_DDD</td>
    <td>Der aktuelle abgekürzte Wochentagsname in der aktuellen Sprache des Benutzers, z. B. So</td>
  </tr>
  <tr id="WDay">
    <td>A_WDay</td>
    <td>Der aktuelle einstellige Wochentag (1-7). In allen Gebietsschemen ist Tag 1 der Sonntag.</td>
  </tr>
  <tr id="YDay">
    <td>A_YDay</td>
    <td>Der aktuelle Tag im Jahr (1-366). Der Wert wird nicht mit Nullen aufgefüllt, z. B. wird 9 abgerufen, nicht 009. Ein Wert kann wie folgt mit Nullen aufgefüllt werden: <code><a href="commands/FormatTime.htm">FormatTime</a>(, "YDay0")</code>.</td>
  </tr>
  <tr id="YWeek">
    <td>A_YWeek</td>
    <td>Das aktuelle Jahr + Wochennummer (z. B. 200453) gemäß ISO 8601. Um das Jahr von der Woche zu trennen, verwende <a href="commands/SubStr.htm">SubStr</a>. Genaue Definition von A_YWeek: Wenn die Woche, die den 1. Januar hat, vier oder mehr Tage des neuen Jahres enthält, wird sie als Woche 1 angesehen. Ansonsten ist sie die letzte Woche des vorherigen Jahres und die nachfolgende Woche die Woche 1.</td>
  </tr>
  <tr id="Hour">
    <td>A_Hour</td>
    <td>Die aktuelle zweistellige Stunde (00-23) im 24-Stunden-Format. Das folgende Beispiel zeigt, wie die Zeit im 12-Stunden-Format sowie die Indikatoren AM bzw. PM abgerufen werden können: <code><a href="commands/FormatTime.htm">FormatTime</a>(, "h:mm:ss tt")</code></td>
  </tr>
  <tr id="Min">
    <td>A_Min</td>
    <td><p>Die aktuelle zweistellige Minute (00-59).</p></td>
  </tr>
  <tr id="Sec">
    <td>A_Sec</td>
    <td>Die aktuelle zweistellige Sekunde (00-59).</td>
  </tr>
  <tr id="MSec">
    <td>A_MSec</td>
    <td>Die aktuelle dreistellige Millisekunde (000-999). Das folgende Beispiel zeigt, wie die führenden Nullen entfernt werden können: <code>Millisekunden := A_MSec + 0</code>.</td>
  </tr>
  <tr id="Now">
    <td>A_Now</td>
    <td>Die aktuelle Ortszeit im <a href="commands/FileSetTime.htm#YYYYMMDD">YYYYMMDDHH24MISS</a>-Format. Hinweis: Die Berechnung von Datum- und Zeit kann mithilfe von <a href="commands/DateAdd.htm">DateAdd</a> und <a href="commands/DateDiff.htm">DateDiff</a> durchgeführt werden. Außerdem kann <a href="commands/FormatTime.htm">FormatTime</a> einen Datum- und/oder Zeitwert in einem Format anzeigen lassen, das deinem Gebietsschema oder deiner Sprache entspricht.</td>
  </tr>
  <tr id="NowUTC">
    <td>A_NowUTC</td>
    <td>Die koordinierte Weltzeit (UTC) im <a href="commands/FileSetTime.htm#YYYYMMDD">YYYYMMDDHH24MISS</a>-Format. UTC ist grundsätzlich das gleiche wie Greenwich Mean Time (GMT).</td>
  </tr>
  <tr id="TickCount">
    <td>A_TickCount</td>
    <td><p>Ruft die Anzahl der Millisekunden ab, die seit dem Systemstart verstrichen sind. Die verstrichene Zeit kann man messen, indem man A_TickCount in eine Variable speichert und diese Variable dann von dem neuesten A_TickCount-Wert subtrahiert. Zum Beispiel:</p>
        <pre>Startzeit := A_TickCount
Sleep 1000
Laufzeit := A_TickCount - Startzeit
MsgBox Laufzeit " Millisekunden sind verstrichen."</pre>
<p>Schaue dir <a href="commands/DllCall.htm#QPC">QueryPerformanceCounter()</a> an, wenn du eine höhere Genauigkeit als die 10 ms von A_TickCount benötigst.</p>
</td>
  </tr>
</table>
<h3 id="settings">Skript-Einstellungen</h3>
<table class="info">
  <tr id="IsSuspended">
    <td>A_IsSuspended</td>
    <td>Enthält eine 1, wenn das Skript via <a href="commands/Suspend.htm">Suspend</a> gesperrt wurde, ansonsten 0.</td>
  </tr>
  <tr id="IsPaused">
    <td>A_IsPaused</td>
    <td>Enthält eine 1, wenn der <a href="misc/Threads.htm">Thread</a> direkt unterhalb des aktuellen Threads <a href="commands/Pause.htm">pausiert</a> wurde. Ansonsten enthält sie eine 0.</td>
  </tr>
  <tr id="IsCritical">
    <td>A_IsCritical</td>
    <td>Enthält eine 0, wenn <a href="commands/Critical.htm">Critical</a> im <a href="misc/Threads.htm">aktuellen Thread</a> ausgeschalten ist. Ansonsten enthält sie ein Integer größer als Null - also die verwendete <a href="commands/Critical.htm#Interval">Meldungsüberprüfungsfrequenz</a> von Critical. Der aktuelle Status von Critical kann mithilfe von <code>Alt_IsCritical := A_IsCritical</code> gespeichert und später mit <code>A_IsCritical := Alt_IsCritical</code> wiederhergestellt werden.</td>
  </tr>
  <tr id="TitleMatchMode">
    <td>A_TitleMatchMode</td>
    <td><strong>Liest/Schreibt</strong> den aktuellen Modus von <a href="commands/SetTitleMatchMode.htm">SetTitleMatchMode</a>: 1, 2, 3 oder RegEx.</td>
  </tr>
  <tr id="TitleMatchModeSpeed">
    <td>A_TitleMatchModeSpeed</td>
    <td><strong>Liest/Schreibt</strong> die aktuelle Übereinstimmungsgeschwindigkeit (fast oder slow) von <a href="commands/SetTitleMatchMode.htm">SetTitleMatchMode</a>.</td>
  </tr>
  <tr id="DetectHiddenWindows">
    <td>A_DetectHiddenWindows</td>
    <td><strong>Liest/Schreibt</strong> den aktuellen Modus (On oder Off) von <a href="commands/DetectHiddenWindows.htm">DetectHiddenWindows</a>.</td>
  </tr>
  <tr id="DetectHiddenText">
    <td>A_DetectHiddenText</td>
    <td><strong>Liest/Schreibt</strong> den aktuellen Modus (On or Off) von <a href="commands/DetectHiddenText.htm">DetectHiddenText</a>.</td>
  </tr>
  <tr id="StringCaseSense">
    <td>A_StringCaseSense</td>
    <td><strong>Liest/Schreibt</strong> den aktuellen Modus (On, Off, oder Locale) von <a href="commands/StringCaseSense.htm">StringCaseSense</a>.</td>
  </tr>
  <tr id="FileEncoding">
    <td>A_FileEncoding</td>
    <td><strong>Liest/Schreibt</strong> die Standardcodierung für verschiedene Funktionen; siehe <a href="commands/FileEncoding.htm">FileEncoding</a>.</td>
  </tr>
  <tr id="SendMode">
    <td>A_SendMode</td>
    <td><strong>Liest/Schreibt</strong> den aktuellen Modus (Event, Input, Play oder InputThenPlay) von <a href="commands/SendMode.htm">SendMode</a>.</td>
  </tr>
  <tr id="SendLevel">
    <td>A_SendLevel</td>
    <td><strong>Liest/Schreibt</strong> die aktuelle <a href="commands/SendLevel.htm">SendLevel</a>-Einstellung (ein Integer zwischen 0 und 100).</td>
  </tr>
  <tr id="StoreCapslockMode">
    <td>A_StoreCapslockMode</td>
    <td><strong>Liest/Schreibt</strong> den aktuellen Modus (On oder Off) von <a href="commands/SetStoreCapslockMode.htm">SetStoreCapslockMode</a>.</td>
  </tr>
  <tr id="KeyDelay">
    <td>A_KeyDelay<br>
    
    A_KeyDuration</td>
    <td><strong>Liest/Schreibt</strong> die aktuelle Verzögerung oder Dauer von <a href="commands/SetKeyDelay.htm">SetKeyDelay</a> (immer dezimal, niemals hexadezimal).</td>
  </tr>
  <tr id="KeyDelayPlay">
    <td>A_KeyDelayPlay<br>
    
    A_KeyDurationPlay</td>
    <td><strong>Liest/Schreibt</strong> die aktuelle Verzögerung oder Dauer von <a href="commands/SetKeyDelay.htm">SetKeyDelay</a> für den <a href="commands/Send.htm#SendPlayDetail">SendPlay</a>-Modus (immer dezimal, niemals hexadezimal).</td>
  </tr>
  <tr id="WinDelay">
    <td>A_WinDelay</td>
    <td><strong>Liest/Schreibt</strong> die aktuelle Verzögerung von <a href="commands/SetWinDelay.htm">SetWinDelay</a> (immer dezimal, nicht hexadezimal).</td>
  </tr>
  <tr id="ControlDelay">
    <td>A_ControlDelay</td>
    <td><strong>Liest/Schreibt</strong> die aktuelle Verzögerung von <a href="commands/SetControlDelay.htm">SetControlDelay</a>.</td>
  </tr>
  <tr id="MouseDelay">
    <td>A_MouseDelay<br>
    
    A_MouseDelayPlay</td>
    <td><strong>Liest/Schreibt</strong> die aktuelle Verzögerung von <a href="commands/SetMouseDelay.htm">SetMouseDelay</a> (immer dezimal, nicht hexadezimal). A_MouseDelay ist für den traditionellen SendEvent-Modus, und A_MouseDelayPlay für <a href="commands/Send.htm#SendPlayDetail">SendPlay</a>.</td>
  </tr>
  <tr id="DefaultMouseSpeed">
    <td>A_DefaultMouseSpeed</td>
    <td><strong>Liest/Schreibt</strong> die aktuelle Geschwindigkeit von <a href="commands/SetDefaultMouseSpeed.htm">SetDefaultMouseSpeed</a>.</td>
  </tr>
  <tr id="CoordMode">
    <td>A_CoordModeToolTip<br>
    
    A_CoordModePixel<br>
    
    A_CoordModeMouse<br>
    
    A_CoordModeCaret<br>
    
    A_CoordModeMenu</td>
    <td><strong>Liest/Schreibt</strong> den aktuellen Modus (Window, Client oder Screen) von <a href="commands/CoordMode.htm">CoordMode</a>.</td>
  </tr>
  <tr id="RegView">
    <td>A_RegView</td>
    <td><strong>Liest/Schreibt</strong> die aktuelle Registry-Ansicht von <a href="commands/SetRegView.htm">SetRegView</a>.</td>
  </tr>
  <tr id="IconHidden">
    <td>A_IconHidden</td>
    <td>Enthält eine 1, wenn das Infobereichssymbol gerade versteckt ist, ansonsten 0. Das Symbol kann mithilfe von <a href="commands/_NoTrayIcon.htm">#NoTrayIcon</a> oder der <a href="commands/Menu.htm">Menu</a>-Funktion versteckt werden.</td>
  </tr>
  <tr id="IconTip">
    <td>A_IconTip</td>
    <td>Enthält den Text des ToolTips, den man via <code><a href="commands/Menu.htm">Menu</a> "Tray", "Tip"</code> für das Infobereichssymbol definiert hat. Ansonsten ist diese Variable leer.</td>
  </tr>
  <tr id="IconFile">
    <td>A_IconFile</td>
    <td>Enthält den vollständigen Pfad der Symboldatei, die man via <code><a href="commands/Menu.htm">Menu</a> "Tray", "Icon"</code> für das Infobereichssymbol definiert hat. Ansonsten ist diese Variable leer. <strong>Bekannte Einschränkung:</strong> Dieser Pfad kann falsch sein, wenn man einen relativen Pfad einer DLL-Systemdatei übergeben hat; zum Beispiel <code>Menu "Tray", "Icon", "user32.dll", 2</code>.</td>
  </tr>
  <tr id="IconNumber">
    <td>A_IconNumber</td>
    <td>Leer, wenn A_IconFile leer ist. Ansonsten enthält diese Variable die Nummer des Symbols von A_IconFile (üblicherweise 1).</td>
  </tr>
</table>
<h3>Abwesenheit des Benutzers</h3>
<table class="info">
  <tr id="TimeIdle">
    <td>A_TimeIdle</td>
    <td>Ruft die Anzahl der Millisekunden ab, die seit der letzten Eingabe (Tastatur, Maus usw.) verstrichen sind. Diese Variable ist nützlich, um herauszufinden, ob der Benutzer abwesend ist. Physische Benutzereingaben sowie künstlich erzeugte Eingaben von <strong>beliebigen</strong> Programmen oder Skripten (z. B. die <a href="commands/Send.htm">Send</a>- oder <a href="commands/MouseMove.htm">MouseMove</a>-Funktion) werden diesen Wert wieder auf 0 setzen. Dieser Wert erhöht sich in der Regel um 10, deshalb sollte man verhindern zu überprüfen, ob er genau mit einem anderen Wert übereinstimmt. Überprüfe stattdessen, ob dieser Wert größer oder kleiner als ein anderer Wert ist. Zum Beispiel:
<pre>if A_TimeIdle &gt; 600000
    MsgBox "Die letzte Eingabeaktivität erfolgte vor ca. 10 Minuten."</pre></td>
  </tr>
  <tr id="TimeIdlePhysical">
    <td>A_TimeIdlePhysical</td>
    <td><p>Diese Variable verhält sich wie A_TimeIdle, aber ignoriert künstliche Tastatureingaben und/oder Mausklicks, wann immer der entsprechende Hook (<a href="commands/_InstallKeybdHook.htm">Tastatur</a> oder <a href="commands/_InstallMouseHook.htm">Maus</a>) installiert wird; das heißt, dass die Variable nur auf physische Ereignisse reagiert. Dadurch wird verhindert, dass simulierte Tastatureingaben und Mausklicks fälschlicherweise die Anwesenheit des Benutzers vortäuschen. Wenn beide Hooks fehlen, hat diese Variable die gleiche Bedeutung wie A_TimeIdle. Wenn nur ein einziger Hook installiert ist, werden nur seine physischen Eingaben Einfluss auf A_TimeIdlePhysical haben (der andere/nicht-installierte Hook, sowohl physisch als auch künstlich, hat keine Wirkung).</p></td>
  </tr>
</table>
<h3 id="h">Hotkeys, Hotstrings und benutzerdefinierte Menüpunkte</h3>
<table class="info">
  <tr id="ThisMenuItem">
    <td>A_ThisMenuItem</td>
    <td>Der Name des zuletzt ausgewählten <a href="commands/Menu.htm">benutzerdefinierten Menüpunkts</a> (ansonsten leer).</td>
  </tr>
  <tr id="ThisMenu">
    <td>A_ThisMenu</td>
    <td>Enthält den Namen des Menüs, wo A_ThisMenuItem ausgewählt wurde.</td>
  </tr>
  <tr id="ThisMenuItemPos">
    <td>A_ThisMenuItemPos</td>
    <td>Eine Nummer, die die <u>aktuelle</u> Position von A_ThisMenuItem in A_ThisMenu kennzeichnet. Der erste Menüpunkt ist 1, der Zweite ist 2 und so weiter. Trennlinien haben auch eine Nummer. Diese Variable ist leer, wenn A_ThisMenuItem auch leer ist oder nicht länger in A_ThisMenu vorkommt. Sie ist auch leer, wenn A_ThisMenu selbst nicht mehr existiert.</td>
  </tr>
  <tr id="ThisHotkey">
    <td>A_ThisHotkey</td>
    <td><p>Der zuletzt ausgeführte <a href="Hotkeys.htm">Hotkey</a> oder <a href="Hotstrings.htm">nicht-automatisch-ersetzende Hotstring</a> (ansonsten leer), z. B. #z. Dieser Wert ändert sich, wenn der <a href="misc/Threads.htm">aktuelle Thread</a> von einem anderen Hotkey unterbrochen wird, deshalb solltest du diesen Wert in eine andere Variable speichern, wenn du ihn später noch brauchst.</p>
      <p>Ein Hotkey kann man via <a href="commands/Hotkey.htm">Hotkey-Funktion</a> oder <a href="Hotkeys.htm">Doppelpunkt-Label</a> erstellen. Wenn man ein Hotkey das erste Mal erstellt, wird ihm ein dauerhafter Name zugewiesen, der die aktuelle Taste und Anordnung der Modifkatorzeichen beinhaltet. Diesen Namen teilen sich alle <a href="commands/_IfWinActive.htm#variant">Varianten</a> des Hotkeys.</p>
      <p>Siehe auch: <a href="#ThisLabel">A_ThisLabel</a></p></td>
  </tr>
  <tr id="PriorHotkey">
    <td>A_PriorHotkey</td>
    <td>Verhält sich wie A_ThisHotkey, aber bezieht sich auf den zuvor ausgeführten Hotkey. Ansonsten ist sie leer.</td>
  </tr>
  <tr id="PriorKey">
    <td>A_PriorKey</td>
    <td>Der Name der vorletzten gedrückten Taste, oder eine leere Zeichenkette, wenn kein geeigneter Tastendruck im Tastenverlauf gefunden werden kann. Alle via Skript erzeugten Eingaben werden ignoriert. Damit diese Variable von Nutzen ist, muss der <a href="commands/_InstallKeybdHook.htm">Tastatur</a>- oder <a href="commands/_InstallMouseHook.htm">Maus-Hook</a> installiert und der <a href="commands/KeyHistory.htm">Tastenverlauf</a> aktiviert sein.</td>
  </tr>
  <tr id="TimeSinceThisHotkey">
    <td>A_TimeSinceThisHotkey</td>
    <td>Ruft die Anzahl der Millisekunden ab, die seit dem letzten Drücken von A_ThisHotkey verstrichen sind. Sie wird -1 sein, wann immer A_ThisHotkey leer ist.</td>
  </tr>
  <tr id="TimeSincePriorHotkey">
    <td>A_TimeSincePriorHotkey</td>
    <td>Ruft die Anzahl der Millisekunden ab, die seit dem letzten Drücken von A_PriorHotkey verstrichen sind. Sie wird -1 sein, wann immer A_PriorHotkey leer ist.</td>
  </tr>
  <tr id="EndChar">
    <td>A_EndChar</td>
    <td>Das <a href="Hotstrings.htm#EndChars">Endungszeichen</a>, das der Benutzer zuletzt gedrückt hat, um einen <a href="Hotstrings.htm">nicht-automatisch-ersetzenden Hotstring</a> auszulösen. Wenn kein Endungszeichen notwendig war (wegen der *-Option), wird diese Variable leer gemacht.</td>
  </tr>
</table>
<h3 id="os">Betriebssystem und Benutzerinformationen</h3>
<table class="info">
  <tr id="ComSpec">
    <td>A_ComSpec</td>
    <td>Enthält den Pfad der Windows-Konsole, welcher auch in der ComSpec-Umgebungsvariable zu finden ist (z. B. C:\Windows\system32\cmd.exe). Diese Variable wird oft in Verbindung mit <a href="commands/Run.htm">Run/RunWait</a> verwendet.</td>
  </tr>
  <tr id="Temp">
    <td>A_Temp</td>
    <td>Der vollständige Pfad des Ordners, der dazu bestimmt ist, temporäre Dateien zu beinhalten (z. B. C:\DOCUME~1\Benutzername\LOCALS~1\Temp). Dieser Pfad wird von einem der folgenden Standorte abgerufen (in dieser Reihenfolge): 1) <a href="#env">Umgebungsvariable</a> TMP, TEMP oder USERPROFILE; 2) Windows-Verzeichnis.</td>
  </tr>
  <tr id="OSVersion">
    <td>A_OSVersion</td>
    <td>
    <p>Die Versionsnummer des Betriebssystems im Format "<em>Haupt</em>.<em>Neben</em>.<em>Build</em>". Windows 7 SP1 ist beispielsweise 6.1.7601.</p>
    <p>Wenn du in den Eigenschaften der AutoHotkey-Datei oder des kompilierten Skripts die Kompatibilitätseinstellungen änderst, wird das Betriebssystem bzw. A_OSVersion eine andere Versionsnummer melden.</p>
    </td>
  </tr>
  <tr id="Is64bitOS">
    <td>A_Is64bitOS</td>
    <td>Enthält 1 (wahr), wenn das System im 64-Bit-Format ist, ansonsten 0 (falsch).</td>
  </tr>
  <tr id="PtrSize">
    <td>A_PtrSize</td>
    <td>Enthält die Größe eines Pointers in Bytes. Dieser Wert ist entweder eine 4 oder eine 8, abhängig davon, ob die verwendete AutoHotkey-Datei im 32- oder 64-Bit-Format ist.</td>
  </tr>
  <tr id="Language">
    <td>A_Language</td>
    <td>Die Standardsprache des Systems als <a href="misc/Languages.htm">vierstelliger Code</a>.</td>
  </tr>
  <tr id="ComputerName">
    <td>A_ComputerName</td>
    <td>Der Netzwerkname des Computers.</td>
  </tr>
  <tr id="UserName">
    <td>A_UserName</td>
    <td>Der Anmeldename des Benutzers, der das Skript gestartet hat.</td>
  </tr>
  <tr id="WinDir">
    <td>A_WinDir</td>
    <td>Das Windows-Verzeichnis. Zum Beispiel: C:\Windows</td>
  </tr>
  <tr id="ProgramFiles">
    <td>A_ProgramFiles</td>
    <td>
      <p>Der Programme-Ordner (z. B. <code>C:\Programme</code> oder <code>C:\Programme (x86)</code>). Diese Built-In-Variable entspricht prinzipiell der <a href="#env">Umgebungsvariable</a> <code>ProgramFiles</code>.</p>
      <p>Auf <a href="#Is64bitOS">64-Bit-Systemen</a> (und nicht 32-Bit-Systemen) gilt Folgendes:</p>
      <ul>
        <li>Wenn die skript-ausführende EXE-Datei im 32-Bit-Format ist, gibt A_ProgramFiles den Pfad des Ordners "Programme (x86)" zurück.</li>
        <li>Bei 32-Bit-Prozessen enthält die <a href="#env">Umgebungsvariable</a> <code>ProgramW6432</code> den Pfad der 64-Bit-Version des Programme-Ordners. In Windows 7 und höher gilt das auch für 64-Bit-Prozesse.</li>
        <li>Die Umgebungsvariable <code>ProgramFiles(x86)</code> enthält den Pfad der 32-Bit-Version des Programme-Ordners.</li>
      </ul>
    </td>
  </tr>
  <tr id="AppData">
    <td>A_AppData</td>
    <td>Der vollständige Pfad des Ordners mit anwendungsspezifischen Daten des aktuellen Benutzers. Zum Beispiel: C:\Dokumente und Einstellungen\Benutzername\Anwendungsdaten</td>
  </tr>
  <tr id="AppDataCommon">
    <td>A_AppDataCommon</td>
    <td>Der vollständige Pfad des Ordners mit anwendungsspezifischen Daten aller Benutzer.</td>
  </tr>
  <tr id="Desktop">
    <td>A_Desktop</td>
    <td>Der vollständige Pfad des Ordners mit den Desktop-Dateien des aktuellen Benutzers.</td>
  </tr>
  <tr id="DesktopCommon">
    <td>A_DesktopCommon</td>
    <td>Der vollständige Pfad des Ordners mit den Desktop-Dateien aller Benutzer.</td>
  </tr>
  <tr id="StartMenu">
    <td>A_StartMenu</td>
    <td>Der vollständige Pfad des Ordners mit den Startmenü-Dateien des aktuellen Benutzers.</td>
  </tr>
  <tr id="StartMenuCommon">
    <td>A_StartMenuCommon</td>
    <td>Der vollständige Pfad des Ordners mit den Startmenü-Dateien aller Benutzer.</td>
  </tr>
  <tr id="Programs">
    <td>A_Programs</td>
    <td>Der vollständige Pfad des Programmordners im Startmenü des aktuellen Benutzers.</td>
  </tr>
  <tr id="ProgramsCommon">
    <td>A_ProgramsCommon</td>
    <td>Der vollständige Pfad des Programmordners im Startmenü aller Benutzer.</td>
  </tr>
  <tr id="Startup">
    <td>A_Startup</td>
    <td>Der vollständige Pfad des Autostart-Ordners im Startmenü des aktuellen Benutzers.</td>
  </tr>
  <tr id="StartupCommon">
    <td>A_StartupCommon</td>
    <td>Der vollständige Pfad des Autostart-Ordners im Startmenü aller Benutzer.</td>
  </tr>
  <tr id="MyDocuments">
    <td>A_MyDocuments</td>
    <td>Der vollständige Pfad des Ordners "Eigene Dokumente" des aktuellen Benutzers. In Gegensatz zu allen anderen ähnlichen Variablen ist hier der letzte umgekehrte Schrägstrich nicht enthalten, wenn sich der Ordner im Stammverzeichnis eines Laufwerks befindet. Also beispielsweise M: anstatt M:\</td>
  </tr>
  <tr id="IsAdmin">
    <td>A_IsAdmin</td>
    <td><p>Wenn der aktuelle Benutzer Administratorrechte hat, enthält diese Variable eine 1. Ansonsten enthält sie eine 0.</p>
    <p id="RequireAdmin">Mit <a href="commands/Run.htm#RunAs">Run *RunAs</a> kann man das Skript mit Adminrechten neu starten lassen (oder anzeigen lassen, dass der Benutzer Adminrechte benötigt). Beachte aber, dass ein mit Adminrechten gestartetes Skript dazu führt, dass alle Programme, die das Skript startet, auch Adminrechte haben werden. In <a href="FAQ.htm#uac">der FAQ</a> findest du eine mögliche Alternative.</p>
    </td>
  </tr>
  <tr id="Screen">
    <td><p>A_ScreenWidth<br>
    
    A_ScreenHeight</p></td>
    <td><p>Die Breite und Höhe des primären Anzeigegeräts in Pixel (z. B. 1024 und 768).</p>
      <p>Mit <a href="commands/SysGet.htm">SysGet</a> können die Abmessungen von anderen Anzeigegeräten abgerufen werden.</p>
      <p>Das folgende Beispiel zeigt, wie die Breite und Höhe des gesamten Desktops ermittelt werden kann (selbst wenn er sich über mehrere Anzeigegeräte erstrecken sollte):</p>
<pre>
VirtuelleBreite := <a href="commands/SysGet.htm">SysGet</a>(78)
VirtuelleHöhe := <a href="commands/SysGet.htm">SysGet</a>(79)
</pre>
    <p>Mit <a href="commands/SysGet.htm">SysGet</a> kann man auch den Arbeitsbereich eines Anzeigegeräts ermitteln. Dieser Bereich kann kleiner sein als der Gesamtbereich des Anzeigegeräts, weil die Abmessungen von der Taskleiste und anderen registrierten Desktopsymbolleisten abgezogen werden.</p></td>
  </tr>
  <tr id="ScreenDPI">
    <td>A_ScreenDPI</td>
    <td>Die Anzahl der Pixel pro logischem Inch entlang der Bildschirmbreite. Bei einem Multi-Anzeigegerät-System gilt dieser Wert für alle Anzeigegeräte. Bei vielen Systemen ist das 96; abhängig von der Textgrößeneinstellung (DPI) des Systems. Siehe auch GUI's <a href="commands/GuiCreate.htm#DPIScale">-DPIScale</a>-Option.</td>
  </tr>
  <tr id="IPAddress">
    <td>A_IPAddress1 bis 4</td>
    <td>Die IP-Adressen der ersten 4 Netzwerkadaptern im Computer.</td>
  </tr>
</table>
<h3>Sonstiges</h3>
<table class="info">
  <tr id="Cursor">
    <td>A_Cursor</td>
    <td><p>Der Typ des aktuell angezeigten Mauszeigers. Die Variable wird eines der folgenden Wörter enthalten: AppStarting, Arrow, Cross, Help, IBeam, Icon, No, Size, SizeAll, SizeNESW, SizeNS, SizeNWSE, SizeWE, UpArrow, Wait, Unknown. Die Großbuchstaben nach Size sind Himmelsrichtungen, z. B. NESW = NorthEast+SouthWest (Nordosten+Südwesten). Die handförmigen Mauszeiger (Zeigen und Greifen) sind als Unknown klassifiziert.</p></td>
  </tr>
  <tr id="Caret">
    <td>A_CaretX<br>
    
    A_CaretY</td>
    <td><p>Die aktuellen X- und Y-Koordinaten der Texteinfügemarke. Die Koordinaten beziehen sich auf das aktive Fenster. <a href="commands/CoordMode.htm">CoordMode</a> kann verwendet werden, um den ganzen Bildschirm einzubeziehen. Wenn es kein aktives Fenster gibt oder wenn die Position der Einfügemarke nicht ermittelt werden kann, sind diese Variablen leer.</p>
      <p>Das folgende Skript zeigt dir in einem sich selbst aktualisierenden ToolTip die Position der Einfügemarke an, während du die Einfügemarke verschiebst. Beachte, dass einige Fenster (z. B. bestimmte Versionen von MS Word) immer die gleiche Position der Einfügemarke melden, egal auf welcher Position sie wirklich ist.</p>
<pre>
SetTimer "BeobachteEinfügemarke", 100
BeobachteEinfügemarke() {
    ToolTip "X" A_CaretX " Y" A_CaretY, A_CaretX, A_CaretY - 20
}
</pre>
    </td>
  </tr>
  <tr id="EventInfo">
    <td>A_EventInfo</td>
    <td><p>Enthält zusätzliche Informationen über die folgenden Ereignisse:</p>
      <ul>
        <li><a href="Hotkeys.htm#Wheel">Mausrad-Hotkeys</a> (WheelDown/Up/Left/Right)</li>
        <li><a href="commands/RegisterCallback.htm">RegisterCallback</a></li>
      </ul>
<p>Hinweis: Im Gegensatz zu Variablen wie A_ThisHotkey behält jeder <a href="misc/Threads.htm">Thread</a> seinen eigenen Wert für A_EventInfo. Das heißt, dass die ursprünglichen/richtigen Werte auch dann noch zur Verfügung stehen, wenn ein Thread unterbrochen und dann fortgesetzt wird.</p>
      <p><strong>Lesen/Schreiben:</strong> A_EventInfo kann auch vom Skript gesetzt werden, aber akzeptiert werden nur vorzeichenlose Integer innerhalb eines Pointer-Bereichs (32-Bit oder 64-Bit, je nach Version von AutoHotkey).</p></td>
  </tr>
  <tr>
    <td>Clipboard</td>
    <td><strong>Liest/Schreibt</strong> den Inhalt der systeminternen Zwischenablage. Siehe <a href="misc/Clipboard.htm">Clipboard</a> für mehr Details.</td>
  </tr>
  <tr>
    <td>ClipboardAll</td>
    <td><strong>Liest nur</strong> den gesamten Inhalt der Zwischenablage (einschließlich Formatierung und Text). Siehe <a href="misc/Clipboard.htm#ClipboardAll">ClipboardAll</a>.</td>
  </tr>
  <tr>
    <td>ErrorLevel</td>
    <td><strong>Liest/Schreibt</strong> <a href="misc/ErrorLevel.htm">ErrorLevel</a>.</td>
  </tr>
  <tr id="LastError">
    <td>A_LastError</td>
    <td><p><strong>Lesen/Schreiben:</strong> Diese Variable ist üblicherweise das Ergebnis der Systemfunktion GetLastError(), nachdem das Skript bestimmte Funktionen aufgerufen hat, oder das HRESULT des letzten Aufrufs eines COM-Objekts. Siehe <a href="commands/DllCall.htm#LastError">DllCall</a> oder <a href="commands/Run.htm#LastError">Run/RunWait</a> für Details.</p>
    <p>Das Speichern eines Wertes in A_LastError bewirkt zudem, dass die Systemfunktion SetLastError() aufgerufen wird.</p></td>
  </tr>
</table>
<h3 id="loop">Loop</h3>
<table class="info">
  <tr id="Index">
    <td>A_Index</td>
    <td><strong>Liest/Schreibt</strong> den aktuellen Schleifendurchlauf (ein 64-Bit-Integer). Zum Beispiel enthält diese Variable die Nummer 1, wenn das Skript den Schleifenkörper zum ersten Mal ausführt. Weitere Informationen können in <a href="commands/Loop.htm">Loop</a> oder <a href="commands/While.htm">While-Schleife</a> gefunden werden.</td>
  </tr>
  <tr>
    <td>A_LoopFileName, etc.</td>
    <td>Diese und andere verwandte Variablen sind nur innerhalb einer <a href="commands/LoopFile.htm">Dateimuster-Schleife</a> gültig.</td>
  </tr>
  <tr>
    <td>A_LoopRegName, etc.</td>
    <td>Diese und andere verwandte Variablen sind nur innerhalb einer <a href="commands/LoopReg.htm">Registry-Schleife</a> gültig.</td>
  </tr>
  <tr>
    <td>A_LoopReadLine</td>
    <td>Siehe <a href="commands/LoopReadFile.htm">Datei-lesende Schleife</a>.</td>
  </tr>
  <tr>
    <td>A_LoopField</td>
    <td>Siehe <a href="commands/LoopParse.htm">Parsende Schleife</a>.</td>
  </tr>
</table>

<h2 id="env">Umgebungsvariablen vs. normale Variablen</h2>
<p>Umgebungsvariablen werden vom Betriebssystem verwaltet. Du kannst dir eine Liste von Umgebungsvariablen anzeigen lassen, wenn du in der Windows-Konsole SET eingibst und ENTER drückst. Mit <a href="commands/EnvGet.htm">EnvGet</a> oder <a href="commands/EnvSet.htm">EnvSet</a> kann eine Umgebungsvariable abgerufen oder gesetzt werden.</p>
<p>Mit <a href="commands/EnvSet.htm">EnvSet</a> kann eine neue Umgebungsvariable erstellt oder der Inhalt einer vorhandenen Umgebungsvariable geändert werden. Allerdings sind solche Ergänzungen und Änderungen privater Natur; sie können vom Rest des Systems nicht erkannt werden. Bei Programmen (oder Skripten), die via <a href="commands/Run.htm">Run</a> oder <a href="commands/Run.htm">RunWait</a> gestartet werden, gilt eine Ausnahme: Sie erben sowohl die Umgebungsvariablen des übergeordneten Skripts als auch die privaten Umgebungsvariablen.</p>

<h2 id="cap">Kapazität und Speicher einer Variable</h2>
<ul>
  <li>Wenn die neue zu übergebende Zeichenkette die aktuelle Länge der Variable überschreitet, wird der reservierte Systemspeicher dieser Variable automatisch erweitert.</li>
  <li>Um den Speicher einer großen Variable freizugeben, weist man ihr nichts zu (z. B. <code>Var := ""</code>).</li>
  <li>Es können beliebig viele Variablen erstellt werden. Das Programm kann mit mehreren Millionen Variablen umgehen, ohne dass es an Performance einbüßt.</li>
  <li>Bei Funktionen und Ausdrücken, die numerische Eingabewerte akzeptieren, haben Gleitkommazahlen eine Genauigkeit von 15 Ziffern. Integer können vorzeichenbehaftete 64-Bit-Werte sein, in einem Bereich von -9223372036854775808 (-0x8000000000000000) bis 9223372036854775807 (0x7FFFFFFFFFFFFFFF). Alle anderen Integer-Konstanten, die diesen Bereich überschreiten, werden nicht unterstützt und liefern widersprüchliche Ergebnisse. Arithmetische Operationen mit Integern werden bei Überlauf umgekehrt (z. B. 0x7FFFFFFFFFFFFFFF + 1 = -0x8000000000000000).</li>
</ul>
</body>
</html>
