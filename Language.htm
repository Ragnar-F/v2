<!DOCTYPE HTML>
<html lang="de">
<head>
<title>Skriptsprache | AutoHotkey v2</title>
<meta name="description" content="Erfahren Sie mehr über die Sprache wie Kommentare, Ausdrücke, Ablaufsteuerungsanweisungen, Struktur eines Skripts, etc." />
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="robots" content="noindex, nofollow">
<link href="static/theme.css" rel="stylesheet" type="text/css" />
<script src="static/content.js" type="text/javascript"></script>
<script src="static/ga.js" type="text/javascript"></script>
</head>
<body>
<h1>Skriptsprache</h1>
<p>Ein AutoHotkey-Skript ist im Grunde eine Reihe von Instruktionen, die das Programm befolgen muss und in einer benutzerdefinierten Sprache geschrieben ist, die nur AutoHotkey versteht. Diese Sprache weist einige Ähnlichkeiten mit anderen Skriptsprachen auf, hat aber auch ihre eigenen Stärken und Schwächen. Dieses Dokument beschreibt die Sprache und versucht zudem, häufig auftretende Problemfälle aufzuzeigen.</p>
<p class="note">Unter <a href="Concepts.htm">Konzepte und Konventionen</a> finden Sie eine allgemeinere Erklärung der verschiedenen Konzepte, auf die AutoHotkey basiert.</p>

<h2>Inhaltsverzeichnis</h2>
<ul>
  <li><a href="#general-conventions">Allgemeine Konventionen</a></li>
  <li><a href="#comments">Kommentare</a></li>
  <li><a href="#expressions">Ausdrücke (Expressions)</a>
  <ul>
    <li><a href="#strings">Zeichenketten / Text</a></li>
    <li><a href="#variables">Variablen</a></li>
    <li><a href="#operators">Operatoren</a></li>
    <li><a href="#function-calls">Funktionsaufrufe</a>
    <ul>
      <li><a href="#function-call-statements">Funktionsaufrufanweisungen</a></li>
      <li><a href="#optional-parameters">Optionale Parameter</a></li>
    </ul></li>
    <li><a href="#operators-for-objects">Operatoren für Objekte</a></li>
    <li><a href="#expression-statements">Ausdrucksanweisungen</a></li>
  </ul></li>
  <li><a href="#control-flow">Ablaufsteuerungsanweisungen</a>
  <ul>
    <li><a href="#control-flow-vs">Ablaufsteuerung vs. andere Anweisungen</a></li>
    <li><a href="#loop-statement">Loop-Anweisung</a></li>
    <li><a href="#not-control-flow">Keine Ablaufsteuerung</a></li>
  </ul></li>
  <li><a href="#structure-of-a-script">Aufbau eines Skripts</a>
  <ul>
    <li><a href="#auto-execute-section">Automatischer Ausführungsbereich</a></li>
    <li><a href="#subroutines">Subroutinen</a></li>
    <li><a href="#user-defined-functions">Benutzerdefinierte Funktionen</a></li>
    <li><a href="#-include">#Include</a></li>
  </ul></li>
  <li><a href="#misc">Verschiedenes</a>
  <ul>
    <li><a href="#dynamic-variables">Dynamische Variablen</a>
    <ul>
      <li><a href="#pseudo-arrays">Pseudo-Arrays</a></li>
      <li><a href="#associative-pseudo-arrays">Assoziative Pseudo-Arrays</a></li>
    </ul></li>
    <li><a href="#labels">Label</a></li>
  </ul></li>
</ul><!-- TODO:
Directives
Declarations
Class definitions
Methods?
-->


<h2 id="general-conventions">Allgemeine Konventionen</h2>
<p><strong>Namen:</strong> Variablen- und Funktionsnamen sind nicht Groß-/Kleinschreibung-sensitiv (zum Beispiel wäre <code>AktuellesDatum</code> das gleiche wie <code>aktuellesdatum</code>). Einzelheiten wie maximale Länge und verwendbare Zeichen finden Sie unter <a href="Concepts.htm#names">Namen</a>.</p>
<p><strong>Keine typisierten Variablen:</strong> Variablen haben keinen explizit definierten Typ; stattdessen kann ein beliebiger Wert in eine beliebige Variable (außer interne Variable) gespeichert werden. Zahlen können je nach Situation automatisch in Zeichenketten (Text) umgewandelt werden und umgekehrt.</p>
<p><strong>Deklarationen sind optional:</strong> Im Normalfall müssen Variablen nicht deklariert werden (in <a href="Functions.htm">Funktionen</a> gibt es Ausnahmen); Variablen werden erstellt, sobald sie verwendet werden (und enthalten zu Beginn eine leere Zeichenkette).</p>
<p><strong>Leer- und Tabulatorzeichen werden größtenteils ignoriert:</strong> Einrückungen (führende Leer- und Tabulatorzeichen) sind wichtig, um den Code besser lesbar zu machen, allerdings werden sie nicht vom Programm benötigt und werden in der Regel ignoriert. Leer- und Tabulatorzeichen werden <em>grundsätzlich</em> am Ende einer Zeile und innerhalb eines Ausdrucks (außer zwischen Anführungszeichen) ignoriert. Allerdings sind solche Zeichen in einigen Fällen signifikant:</p>
<ul>
  <li><a href="#function-calls">Funktions</a>- und Methodenaufrufe verlangen, dass zwischen dem Funktions-/Methodennamen und <code>(</code> kein Leerzeichen steht.</li>
  <li>Leerzeichen werden zum Verketten von Elementen benötigt.</li>
  <li>Zwischen zwei Operatoren sind eventuell Leerzeichen erforderlich, um Mehrdeutigkeiten zu vermeiden.</li>
  <li>Einzeilige <a href="#comments">Kommentare</a> benötigen ein führendes Leerzeichen, wenn sie nicht am Zeilenanfang stehen.</li>
</ul>
<p><strong>Zeilenumbrüche sind von Bedeutung:</strong> Zeilenumbrüche dienen in der Regel als Trennzeichen für Anweisungen und terminieren den vorherigen Funktionsaufruf oder eine andere Anweisung. (Eine <em>Anweisung</em> ist einfach gesagt das kleinste eigenständige Element der Sprache, das eine ausführende Aktion ausdrückt.) Die Ausnahme davon ist die Zeilenfortsetzung (siehe unten).</p>
<p><strong>Zeilenfortsetzung:</strong> Lange Zeilen können in mehreren kurzen Zeilen aufgeteilt werden, um die Übersichtlichkeit und Wartbarkeit des Skripts zu erhöhen. Dies erfolgt prä-prozedural; das heißt, dass sie im eigentlichen Sinne nicht zur Sprache gehört. Es gibt drei Methoden:</p>
<ul>
  <li><a href="Scripts.htm#continuation-line">Fortsetzungspräfix</a>: Zeilen, die mit einem <a href="Variables.htm#operators">Ausdrucksoperator</a> beginnen (außer ++ und --), werden mit der vorherigen Zeile verbunden. Zeilen werden immer zusammengeführt, egal ob die Zeile tatsächlich einen Ausdruck enthält.</li>
  <li><a href="Scripts.htm#continuation-expr">Fortsetzung durch Umschließen</a>: Ein Teilausdruck, der mit (), [] oder {} umschlossen ist, kann in den meisten Fällen automatisch mehrere Zeilen umfassen.</li>
  <li><a href="Scripts.htm#continuation-section">Fortsetzungsbereich</a>: Ein Bereich mit mehreren Zeilen, der mit <code>(</code> beginnt und <code>)</code> endet, wird mit der Zeile darüber verbunden (beide Symbole müssen am Anfang einer Zeile stehen, mit oder ohne Leerzeichen).</li>
</ul>
 

<h2 id="comments">Kommentare</h2>
<p><em>Kommentare</em> sind Textbereiche innerhalb des Skripts, die vom Programm ignoriert werden. Sie werden in der Regel eingesetzt, um Erklärungen hinzuzufügen oder Teile des Codes zu deaktivieren.</p>
<p>Um in Skripten etwas zu kommentieren, muss am Anfang einer Zeile ein Semikolon gesetzt werden. Zum Beispiel:</p>
<pre><em>; Diese ganze Zeile ist ein Kommentar.</em></pre>
<p>Kommentare können auch am Ende einer Zeile stehen - in diesem Fall muss auf der linken Seite des Semikolons mindestens ein Leer- oder Tabulatorzeichen erfolgen. Zum Beispiel:</p>
<pre>Run "Notepad"  <em>; Dieser Kommentar befindet sich auf derselben Zeile wie der Funktionsaufruf.</em></pre>
<p>Mithilfe der Symbole <code><em>/*</em></code> und <code><em>*/</em></code> können ganze Bereiche auskommentiert werden, <em>allerdings müssen die Symbole am Anfang einer Zeile stehen</em> (oder <code><em>*/</em></code> am Anfang oder Ende einer Zeile). Zum Beispiel:</p>
<pre><em>/*
MsgBox "Diese Zeile ist auskommentiert (deaktiviert)."
MsgBox "Häufiger Fehler:" */ " Dies beendet nicht den Kommentar."
MsgBox "Diese Zeile ist auskommentiert."
*/</em>
MsgBox "Diese Zeile ist nicht auskommentiert."
<em>/* Dies ist auch gültig, allerdings kann kein anderer Code auf diese Zeile stehen. */</em>
</pre>
<p>Kommentare werden beim Starten eines Skripts ignoriert, daher haben sie keinerlei Einfluss auf die Performance oder Speicherauslastung.</p>

<h2 id="expressions">Ausdrücke (Expressions)</h2>
<p><strong><em>Ausdrücke</em></strong> sind Kombinationen aus einem oder mehreren <a href="Concepts.htm#values">Werten</a>, <a href="Concepts.htm#variables">Variablen</a>, <a href="#operators">Operatoren</a> und <a href="#function-calls">Funktionsaufrufen</a>. Zum Beispiel sind <code>10</code>, <code>1+1</code> und <code>MeineVar</code> gültige Ausdrücke. Ein Ausdruck nimmt in der Regel einen oder mehrere Eingabewerte, führt eine oder mehrere Operationen durch, und erzeugt einen Ausgabewert. Der Vorgang zum Herausfinden des Wertes eines Ausdrucks nennt man <em>Auswertung</em>. Der Ausdruck <code>1+1</code> wird beispielsweise zu der Zahl 2 <em>ausgewertet</em>.</p>
<p>Einfache Ausdrücke können zu immer komplexeren Ausdrücken zusammengesetzt werden können. Wenn <code>Rabatt/100</code> beispielsweise einen Rabattprozentsatz in eine Bruchzahl umwandelt, könnte man mit <code>1 - Rabatt/100</code> eine Bruchzahl errechnen, die den verbleibenden Betrag repräsentiert, und mit <code>Preis * (1 - Rabatt/100)</code> den Nettopreis errechnen.</p>
<p><em>Werte</em> sind <a href="Concepts.htm#numbers">Zahlen</a>, <a href="Concepts.htm#objects">Objekte</a> oder <a href="Concepts.htm#strings">Zeichenketten</a>. Ein <em>literaler</em> Wert ist ein Wert, der physisch in das Skript geschrieben wird; einer, den man sehen kann, wenn man auf den Code schaut.</p>

<h3 id="strings">Zeichenketten / Text</h3>
<p class="note">Eine allgemeinere Erklärung zu Zeichenketten finden Sie unter <a href="Concepts.htm#strings">Zeichenketten (Strings)</a>.</p>
<p>Eine <em><em>Zeichenkette</em></em> ist einfach nur ein Textwert. In einem Ausdruck muss direkt geschriebener Text in Hochkommas oder Anführungszeichen gesetzt werden, um ihn von einem Variablennamen oder einem anderen Ausdruck zu unterscheiden. Dieser Zustand wird oft als <em>in Anführungszeichen gesetzte, direkt geschriebene Zeichenkette</em> oder einfach nur <em>in Anführungszeichen gesetzte Zeichenkette</em> bezeichnet. Zum Beispiel: <code>"Dies ist eine in Anführungszeichen gesetzte Zeichenkette."</code> oder <code>'diese auch'</code>.</p>
<p>Um ein <em>tatsächliches</em> Anführungszeichen innerhalb einer in Anführungszeichen gesetzte Zeichenkette einzufügen, können Sie entweder die <a href="misc/EscapeChar.htm#quote">Escapesequenzen</a> <code>`"</code> oder <code>`'</code> verwenden oder das Zeichen mit den gegenteiligen Anführungszeichen umschließen. Zum Beispiel: <code>'Sie sagte: "Ein Apfel täglich."'</code>.</p>
<p>In Anführungszeichen gesetzte Zeichenketten können auch andere <a href="misc/EscapeChar.htm">Escapesequenzen</a> wie z. B. <code>`t</code> (Tabulator), <code>`n</code> (LF-Zeilenumbruchszeichen) und <code>`r</code> (CR-Zeilenumbruchszeichen) enthalten.</p>

<h3 id="variables">Variablen</h3>
<p class="note">Eine grundlegende Erklärung und allgemeine Details zu Variablen finden Sie unter <a href="Concepts.htm#variables">Variablen</a>.</p>
<p>Um <em>Variablen</em> in einem Ausdruck zu nutzen, schreibt man einfach den Namen der Variable. Zum Beispiel: <code>A_ScreenWidth/2</code>. Allerdings können Variablen nicht in einer in Anführungszeichen gesetzten Zeichenkette verwendet werden. Stattdessen greift man auf eine Vorgehensweise zurück, die sich <a href="Variables.htm#concat"><em>Verkettung</em></a> nennt, um Variablen und andere Werte zu kombinieren. Es gibt zwei Wege, um Werte in einem Ausdruck zu <em>verketten</em>:</p>
<ul>
  <li>Implizite Verkettung: <code>"Der Wert ist " MeineVar</code></li>
  <li>Explizite Verkettung: <code>"Der Wert ist " . MeineVar</code></li>
</ul>
<p>Implizite Verkettung wird auch <em>Auto-Verkettung</em> genannt. In beiden Fällen müssen die Leerzeichen vor der Variable und der Punkt vorhanden sein.</p>
<p>Die <a href="commands/Format.htm">Format</a>-Funktion kann auch für diesen Zweck genutzt werden. Zum Beispiel:</p>
<pre>MsgBox Format("Sie verwenden AutoHotkey v{1} {2}-Bit.", A_AhkVersion, A_PtrSize*8)
</pre>
<p>Um einer Variable einen Wert zuzuweisen, nutzt man den <a href="Variables.htm#AssignOp">Zuweisungsoperator</a> <code>:=</code>, wie z. B. in <code>MeineVar := "Beliebiger Text"</code>.</p>
<p><em>Prozentzeichen</em> innerhalb eines Ausdrucks werden genutzt, um <a href="#dynamic-variables">dynamische Variablenreferenzen</a> und <a href="Functions.htm#DynCall">dynamische Funktionsaufrufe</a> zu erzeugen, allerdings werden sie selten benötigt.</p>

<h3 id="operators">Operatoren</h3>
<p><em>Operatoren</em> haben die Form eines Symbols oder einer Gruppe von Symbolen, wie z. B. <code>+</code> oder <code>:=</code>, oder eines der Wörter <code>and</code>, <code>or</code>, <code>not</code>, <code>is</code>, <code>in</code> oder <code>contains</code>. Sie nehmen einen, zwei oder drei Eingabewerte und geben einen Ausgabewert zurück. Ein Wert oder Teilausdruck, der als Eingabe für einen Operator dient, wird als <em>Operand</em> bezeichnet.</p>
<ul>
  <li><em>Unäre</em> (einstellige) Operatoren werden je nach Operator entweder vor oder nach einem einzelnen Operanden geschrieben. Zum Beispiel: <code>-x</code> oder <code>not TasteIstUnten</code>.</li>
  <li><em>Binäre</em> (zweistellige) Operatoren werden zwischen ihre beiden Operanden geschrieben. Zum Beispiel: <code>1+1</code> oder <code>2 * 5</code>.</li>
  <li>AutoHotkey hat nur einen <em>ternären</em> (dreistelligen) Operator, der die Form <a href="Variables.htm#ternary"><code>Bedingung ? WertWennTrue : WertWennFalse</code></a> hat.</li>
</ul>
<p>Einige unäre und binäre Operatoren teilen sich die gleichen Symbole - in diesem Fall hängt die Bedeutung des Operators davon ab, ob er vor, nach oder zwischen zwei Werten geschrieben wird. Zum Beispiel führt <code>x-y</code> eine Subtraktion durch, während <code>-x</code> das Vorzeichen von <code>x</code> invertiert (einen positiven Wert von einem negativen Wert erzeugen und umgekehrt).</p>
<p>Operatoren gleicher Priorität wie Multiplizieren (<code>*</code>) und Dividieren (<code>/</code>) werden von links nach rechts ausgewertet, sofern nicht anders in der <a href="Variables.htm#operators">Operatorentabelle</a> angegeben. Ein Operator mit niedrigerer Priorität wie Addieren (<code>+</code>) wird erst ausgewertet, wenn ein höherer Operator wie Multiplizieren (<code>*</code>) ausgewertet wurde. Zum Beispiel würde <code>3 + 2 * 2</code> als <code>3 + (2 * 2)</code> ausgewertet werden. Mit runden Klammern können die Prioritäten überschrieben werden. Zum Beispiel: <code>(3 + 2) * 2</code></p>

<h3 id="function-calls">Funktionsaufrufe</h3>
<p class="note">Eine allgemeine Erläuterung zu Funktionen und verwandter Fachbegriffe finden Sie unter <a href="Concepts.htm#functions">Funktionen</a>.</p>
<p><em>Funktionen</em> nehmen eine unterschiedliche Anzahl von Eingabewerten, führen eine Aktion oder Berechnung durch und geben dann ein Ergebnis via <a href="Concepts.htm#return-a-value"><em>Return</em></a> zurück. Die Eingabewerte einer Funktion werden als <a href="Concepts.htm#parameters"><em>Parameter</em></a> oder <em>Argumente</em> bezeichnet. Um eine Funktion <a href="Concepts.htm#call"><em>aufzurufen</em></a>, schreibt man einfach ihren Namen, gefolgt von den Parametern, die in Klammern gesetzt sind. <code>GetKeyState("Shift")</code> beispielsweise gibt 1 zurück (wird zu dieser Zahl ausgewertet), wenn die <kbd>Umschalt</kbd>-Taste gedrückt gehalten wird, oder 0, wenn nicht.</p>
<p class="warning"><strong>Hinweis:</strong> Zwischen dem Funktionsnamen und der runden Startklammer darf kein Leerzeichen stehen.
</p>
<p>Für Programmieranfänger mag die Forderung nach Klammern zunächst kryptisch oder umständlich erscheinen, aber gerade sie ermöglichen es, einen Funktionsaufruf mit anderen Operationen zu kombinieren. Zum Beispiel wird der Ausdruck <code>GetKeyState("Shift", "P") and GetKeyState("Ctrl", "P")</code> erst eine 1 zurückgeben, wenn beide Tasten physisch gedrückt gehalten werden.</p>
<p>Funktionsnamen und Variablennamen sind voneinander getrennt. Zum Beispiel kann <code>Round</code> sowohl ein Variablen- als auch ein Funktionsname sein; das heißt, dass <code>Round := 1</code> keinerlei Auswirkung auf <code>Round(n)</code> haben wird.</p>
<p>Im Gegensatz zu normalen <a href="Functions.htm#Global">globalen Variablen</a> können Funktionen standardmäßig aus anderen Funktionen heraus aufgerufen werden. <a href="Functions.htm#nested">Verschachtelte Funktionen</a> (eine Funktion, die in einer anderen Funktion <em>definiert</em> ist) sind jedoch nur via Name innerhalb der umschließenden Funktion zugänglich.</p>

<h4 id="function-call-statements">Funktionsaufrufanweisungen</h4>
<p>Wenn der Rückgabewert der Funktion nicht benötigt wird und der Funktionsname am Zeilenanfang geschrieben wird (oder in anderen Kontexten, wo eine <a href="Concepts.htm#statement">Anweisung</a> erlaubt ist, wie z. B. nach einem <code>else</code> oder einem <a href="Hotkeys.htm">Hotkey-Label</a>), können die Klammern weggelassen werden. In diesem Fall wird der Rest der Zeile als Parameterliste der Funktion übernommen. Zum Beispiel:</p>
<pre>Ergebnis := MsgBox("Hierfür sind Klammern erforderlich.",, "OKCancel")
MsgBox "Hierfür nicht. Das Ergebnis war " Ergebnis "."</pre>
<p>Die runden Klammern können auch beim Aufrufen einer <a href="Concepts.htm#methods">Methode</a> weggelassen werden, wenn das Zielobjekt entweder eine Variable oder eine direkt benannte Eigenschaft ist, wie z. B. <code>meineVar.meineMethode</code> oder <code>meineVar.meineEigenschaft.meineMethode</code>.</p>

<h4 id="optional-parameters">Optionale Parameter</h4>
<p>Optionale Parameter können einfach leer gelassen werden, allerdings ist das trennende Komma weiterhin notwendig, es sei denn, alle nachfolgenden Parameter werden ebenfalls weggelassen. Zum Beispiel kann die <a href="commands/Run.htm">Run</a>-Funktion ein bis vier Parameter akzeptieren. Alle folgenden Zeilen sind gültig:</p>
<pre>
Run "notepad.exe", "C:\"
Run "notepad.exe",, "Min"
Run("notepad.exe", , , notepadPID)
</pre>

<h3 id="operators-for-objects">Operatoren für Objekte</h3>
<p>Es gibt noch andere Symbole, die in Ausdrücken verwendet werden, die nicht ganz in eine der oben genannten Kategorien passen oder die die Bedeutung anderer Teile des Ausdrucks beeinflussen, wie unten beschrieben. Diese Symbole beziehen sich alle irgendwie auf <em>Objekte</em>. Eine vollständige Erläuterung dessen, was jedes Konstrukt tut, würde die Einführung weiterer Konzepte erfordern, die nicht in den Geltungsbereich dieses Abschnitts fallen.</p>
<p><code>Alpha.Beta</code> wird oft als <em>Objektelementzugriff</em> bezeichnet. <em>Alpha</em> ist eine gewöhnliche Variable und kann mit einem Funktionsaufruf oder einem anderen Teilausdruck, der ein Objekt zurückgibt, ersetzt werden. Beim Auswerten wird das Objekt mit der Anfrage konfrontiert, entweder den Wert oder die Eigenschaft <em>Beta</em> abzurufen, diesen Wert in die Eigenschaft <em>Beta</em> zu speichern oder die Methode namens <em>Beta</em> aufzurufen. Das heißt, dass <em>Beta</em> ein Name ist, der eine Bedeutung für das Objekt hat; es ist keine lokale oder globale Variable.</p>
<p><code>Alpha.Beta()</code> ist ein <em>Methodenaufruf</em>, wie oben beschrieben. Die runden Klammern können in bestimmten Fällen weggelassen werden; siehe <a href="#function-call-statements">Funktionsaufrufanweisungen</a>.</p>
<p><code>Alpha.Beta[Param]</code> ist eine spezielle Form des Objektelementzugriffs, die zusätzliche Parameter in die Anfrage einbezieht. Während <em>Beta</em> ein einfacher Name ist, ist <em>Param</em> eine gewöhnliche Variable oder ein Teilausdruck, oder eine Liste von Teilausdrücken, die durch Kommas getrennt sind (wie in der Parameterliste einer Funktion). <a href="Functions.htm#VariadicCall">Variadische Aufrufe</a> sind erlaubt.</p>
<p><code>Alpha.%vBeta%</code>, <code>Alpha.%vBeta%[Param]</code> und <code>Alpha.%vBeta%()</code> sind ebenfalls Objektelementzugriffe, aber <em>vBeta</em> ist eine Variable oder ein Teilausdruck. Dadurch kann der Name der Eigenschaft oder Methode ermittelt werden, während das Skript ausgeführt wird. Solche Methodenaufrufe benötigen runde Klammern.</p>
<p><code>Alpha[Index]</code> greift auf die <em>Standardeigenschaft</em> von <code>Alpha</code> zu und übergibt <code>Index</code> als Parameter. <em>Alpha</em> und <em>Index</em> sind in diesem Fall Variablen, die mit praktisch jedem Teilausdruck ersetzt werden könnten. Diese Syntax wird in der Regel genutzt, um ein Element eines <a href="objects/Array.htm">Arrays</a> oder eines <a href="objects/Map.htm">Map</a>-Objekts abzurufen.</p>
<p id="array-literal"><code>[A, B, C]</code> erzeugt ein <a href="objects/Array.htm">Array</a> mit den anfänglichen Inhalten von A, B und C (in diesem Fall alle Variablen), wobei A das Element 1 ist.</p>
<p id="object-literal"><code>{Eigenschaft1: Wert1, Eigenschaft2: Eigenschaft2}</code> erstellt ein <a href="objects/Object.htm">Objekt</a> mit den direkt geschriebenen Eigenschaften <em>Eigenschaft1</em> und <em>Eigenschaft2</em>. Ein Wert kann später mit dem oben beschriebenen <em>Objektelementzugriff</em> abgerufen werden.</p>
<p class="warning"><strong>Hinweis:</strong> Es sollten nur direkt geschriebene <a href="Concepts.htm#names">Namen</a> auf der linken Seite von <code>:</code> verwendet werden. Momentan sind andere Teilausdrücke erlaubt, aber dies ist ein Überbleibsel aus der Zeit, als Objekte als assoziative Arrays verwendet wurden, und wird wahrscheinlich geändert.</p>
<p><code>MeineFunk(Params*)</code> ist ein <a href="Functions.htm#VariadicCall">variadischer Funktionsaufruf</a>. Das Sternchen muss unmittelbar vor der runden Endklammer am Ende der Parameterliste der Funktion stehen. <em>Params</em> muss eine Variable oder ein Teilausdruck, der ein <a href="objects/Array.htm">Array</a> oder ein anderes enumerierbares Objekt zurückgibt, sein. Obwohl <code>Params*</code> nicht überall erlaubt ist, kann es in einem direkt geschriebenen Array (<code>[A, B, C, AnzufügendesArray*]</code>) oder in der Parameterliste einer Eigenschaft (<code>Alpha.Beta[Params*]</code> oder <code>Alpha[Params*]</code>) verwendet werden.</p>

<h3 id="expression-statements">Ausdrucksanweisungen</h3>
<p>Nicht alle Ausdrücke sollten allein auf einer Zeile stehen. Zum Beispiel würde eine Zeile, die nur aus <code>21*2</code> oder <code>"Etwas Text"</code> besteht, keinen Sinn ergeben. Die <em>Ausdrucksanweisung</em> ist ein eigenständiger Ausdruck, der in der Regel für seine Nebenwirkungen verwendet wird. Die meisten Ausdrücke mit Nebenwirkungen können auf diese Weise verwendet werden, daher ist es grundsätzlich nicht notwendig, sich die Details dieses Abschnitts zu merken.</p>
<p>Die folgenden Typen von Ausdrücken können als Anweisungen verwendet werden:</p>
<p>Zuweisungen, wie in <code>x := y</code>, Verbundzuweisungen wie <code>x += y</code>, und Inkrement-/Dekrementoperatoren wie <code>++x</code> und <code>x--</code>.</p>
<p class="warning"><strong>Bekannte Einschränkung:</strong> Bei <code>x++</code> und <code>x--</code> darf derzeit kein Leerzeichen zwischen Variablenname und Operator stehen.</p>
<p>Funktionsaufrufe wie <code>MeineFunk(Params)</code>. Nach einem alleinstehenden Funktionsaufruf kann jedoch keine geschweifte Startklammer <code>{</code> (am Zeilenende oder auf der nächsten Zeile) erfolgen, da dies als Funktionsdeklaration fehlinterpretiert werden würde.</p>
<p>Methodenaufrufe wie <code>MeinObj.MeineMethode()</code>.</p>
<p>Objektelementzugriff via eckige Klammern, wie z. B. <code>MeinObj[Index]</code>, das Nebenwirkungen wie ein Funktionsaufruf haben kann.</p>
<p>Ternäre Ausdrücke wie <code>x ? AufrufenWennTrue() : AufrufenWennFalse()</code>.</p>
<p class="warning"><strong>Bekannte Einschränkung:</strong> Aufgrund von Mehrdeutigkeiten bei <a href="#function-call-statements">Funktionsaufrufanweisungen</a> sollten Bedingungen, die mit einem Variablennamen und Leerzeichen beginnen (aber auch andere Operatoren enthalten), in runden Klammern gesetzt werden. <code>(x + 1) ? y : z</code> und <code>x+1 ? y : z </code> beispielsweise sind Ausdruckszuweisungen, während <code>x + 1 ? y : z</code> eine Funktionsaufrufanweisung ist.</p>
<p>Ausdrücke, die mit <code>(</code> beginnen. In der Regel muss jedoch auf der gleichen Zeile ein entsprechendes <code>)</code> stehen, sonst wird die Zeile als Anfang eines <a href="Scripts.htm#continuation">Fortsetzungsbereichs</a> interpretiert.</p>
<p>Ausdrücke, die mit einer Doppeldereferenzierung beginnen, wie z. B. <code>%VarName% := 1</code>. Dies ist in erster Linie auf die Komplexität der Implementierung zurückzuführen.</p>
<p>Ausdrücke, die mit den oben genannten Elementen beginnen (aber nicht mit den unten genannten), sind aus praktischen Gründen ebenfalls erlaubt. Zum Beispiel ist <code>MeineFunk()+1</code> momentan erlaubt, obwohl <code>+1</code> keine Wirkung hat und das Ergebnis verworfen wird. Solche Ausdrücke können in Zukunft durch eine erweiterte Fehlerprüfung ungültig werden.</p>
<p><a href="#function-call-statements">Funktionsaufrufanweisungen</a> sind ähnlich wie Ausdrucksanweisungen, aber technisch gesehen keine reinen Ausdrücke. Zum Beispiel: <code>MsgBox "Hallo, Welt!"</code>, <code>meineGui.Show</code> oder <code>x.y.z "meine Parameter"</code>.</p>

<h2 id="control-flow">Ablaufsteuerungsanweisungen</h2>
<p class="note">Eine allgemeine Erläuterung zur Ablaufsteuerung finden Sie unter <a href="Concepts.htm#control-flow">Ablaufsteuerung</a>.</p>
<p>Um <a href="Concepts.htm#statement">Anweisungen</a> zu einem <a href="commands/Block.htm"><em>Block</em></a> zusammenzufassen, umschließt man sie mit geschweiften Klammern <code>{}</code>, wie in C, JavaScript und anderen ähnlichen Sprachen, allerdings müssen die Klammern in der Regel am Anfang einer Zeile stehen. Ablaufsteuerungsanweisungen können auf einen ganzen Block oder nur auf eine einzelne Anweisung angewendet werden.</p>
<p>Der <a href="Concepts.htm#cf-body">Körper</a> einer Ablaufsteuerungsanweisung besteht immer aus einer einzigen <em>Gruppe</em> von Anweisungen. Ein Block zählt als eine Gruppe von Anweisungen, ebenso wie eine Ablaufsteuerungsanweisung und ihr Körper. Die folgenden verwandten Anweisungen werden ebenfalls mit ihren Körpern gruppiert: <code>If</code> mit <code>Else</code>; <code>Loop</code>/<code>For</code> mit <code>Until</code>; <code>Try</code> mit <code>Catch</code> und/oder <code>Finally</code>. Wenn also eine Gruppe dieser Anweisungen als Ganzes verwendet wird, muss sie nicht immer mit geschweiften Klammern umschlossen werden (einige Programmierstile enthalten jedoch aus Gründen der Übersichtlichkeit immer die geschweiften Klammern).</p>
<p>Ablaufsteuerungsanweisungen, die einen Körper haben und deshalb immer eine nachfolgende Anweisung oder eine Gruppe von Anweisungen haben müssen: <code>If</code>, <code>Else</code>, <code>Loop</code>, <code>While</code>, <code>For</code>, <code>Try</code>, <code>Catch</code> und <code>Finally</code>.</p>
<p id="control-flow-list">Es gibt die folgenden Ablaufsteuerungsanweisungen:</p>
<ul>
  <li>Ein <a href="commands/Block.htm">Block</a> (gekennzeichnet durch ein Paar von geschweiften Klammern) gruppiert null oder mehr Anweisungen, um als eine einzige Anweisung zu fungieren.</li>
  <li>Eine <a href="commands/If.htm">If-Anweisung</a> führt ihren Körper aus, wenn eine Bedingung erfüllt ist. Sie kann mit einer nachfolgenden <a href="commands/Else.htm">Else</a>-Anweisung verbunden werden, die nur ausgeführt wird, wenn eine Bedingung nicht erfüllt ist.</li>
  <li><a href="commands/Goto.htm">Goto</a> springt zu einem bestimmten Label und setzt dort die Ausführung fort.</li>
  <li><a href="commands/Gosub.htm">Gosub</a> ruft eine <a href="#subroutines">Subroutine</a> auf.</li>
  <li><a href="commands/Return.htm">Return</a> lässt eine <a href="#subroutines">Subroutine</a> oder Funktion einen Wert zurückgeben.</li>
  <li>Eine <a href="#loop-statement">Loop-Anweisung</a> (<a href="commands/Loop.htm">Loop</a>, <a href="commands/While.htm">While</a> oder <a href="commands/For.htm">For</a>) führt ihren Körper wiederholt aus.
  <ul>
    <li><a href="commands/Break.htm">Break</a> verlässt (terminiert) eine Schleife.</li>
    <li><a href="commands/Continue.htm">Continue</a> überspringt den Rest der aktuellen Schleife und beginnt einen neuen Durchlauf.</li>
    <li><a href="commands/Until.htm">Until</a> lässt eine Schleife terminieren, wenn ein Ausdruck als True gewertet wird. Der Ausdruck wird nach jedem Schleifendurchlauf ausgewertet.</li>
  </ul></li>
  <li><a href="commands/Switch.htm">Switch</a> führt eine Case-Anweisung aus einer Liste von Kandidaten aus, die sich gegenseitig ausschließen.</li>
  <li>Ausnahmebehandlung:
  <ul>
    <li><a href="commands/Try.htm">Try</a> schützt seinen Körper vor Laufzeitfehlern und Ausnahmen, die von der Throw-Anweisung ausgelöst werden.</li>
    <li><a href="commands/Catch.htm">Catch</a> führt seinen Körper aus, nachdem eine Ausnahme innerhalb einer Try-Anweisung ausgelöst wurde (und nur, wenn eine Ausnahme ausgelöst wurde).</li>
    <li><a href="commands/Finally.htm">Finally</a> führt seinen Körper aus, wenn die Ablaufsteuerung den Körper einer Try- oder Catch-Anweisung verlässt.</li>
    <li><a href="commands/Throw.htm">Throw</a> löst eine Ausnahme aus, um von Tray/Catch behandelt zu werden oder um ein Fehlerdialogfenster anzuzeigen.</li>
  </ul></li>
</ul>

<h3 id="control-flow-vs">Ablaufsteuerung vs. andere Anweisungen</h3>
<p>Ablaufsteuerungsanweisungen unterscheiden sich von <a href="#function-call-statements">Funktionsaufrufanweisungen</a> in mehrfacher Hinsicht:</p>
<ul>
  <li>Die geschweifte Startklammer eines <a href="commands/Block.htm">Blocks</a> kann auf derselben Zeile am Ende der Anweisung <a href="commands/If.htm">If</a>, <a href="commands/Else.htm">Else</a>, <a href="#loop-statement">Loop</a>, <a href="commands/While.htm">While</a>, <a href="commands/For.htm">For</a>, <a href="commands/Try.htm">Try</a>, <a href="commands/Catch.htm">Catch</a> oder <a href="commands/Finally.htm">Finally</a> geschrieben werden (im Prinzip jede Ablaufsteuerungsanweisung, die einen <a href="Concepts.htm#cf-body">Körper</a> hat). Dies wird als One True Brace (OTB) Style bezeichnet.</li>
  <li><a href="commands/Else.htm">Else</a>, <a href="commands/Try.htm">Try</a> und <a href="commands/Finally.htm">Finally</a> erlauben auf ihrer rechten Seite eine beliebige gültige Anweisung, da sie keine Parameter sondern einen <a href="Concepts.htm#cf-body">Körper</a> benötigen.</li>
  <li><a href="commands/If.htm">If</a>, <a href="commands/While.htm">While</a>, <a href="commands/Return.htm">Return</a>, <a href="commands/Until.htm">Until</a>, <a href="commands/Loop.htm">Loop <em>Anzahl</em></a>, <a href="commands/Goto.htm">Goto</a> und <a href="commands/Gosub.htm">Gosub</a> erlauben die Verwendung einer runden Startklammer unmittelbar nach dem Namen, um die gesamte Parameterliste zu umschließen. Sie sehen zwar wie Funktionsaufrufe aus, sind es aber nicht und können auch nicht innerhalb eines Ausdrucks verwendet werden. Zum Beispiel: <code>if(Ausdruck)</code>.</li>
  <li>Ablaufsteuerungsanweisungen können nicht durch Definieren einer gleichnamigen Funktion überschrieben werden.</li>
</ul>

<h3 id="loop-statement">Loop-Anweisung</h3>
<p>Es gibt verschiedene Typen von Loop-Anweisungen:</p>
<ul>
  <li><a href="commands/Loop.htm">Loop <em>Anzahl</em></a> führt eine Anweisung wiederholt aus - entweder eine bestimmte Anzahl von Wiederholungen oder bis ein Break auftritt.</li>
  <li><a href="commands/LoopReg.htm">Loop Reg</a> ruft die Inhalte eines bestimmten Registry-Subkeys einzeln ab.</li>
  <li><a href="commands/LoopFiles.htm">Loop Files</a> ruft bestimmte Dateien oder Ordner einzeln ab.</li>
  <li><a href="commands/LoopParse.htm">Loop Parse</a> ruft Teile (Felder) einer Zeichenkette einzeln ab.</li>
  <li><a href="commands/LoopRead.htm">Loop Read</a> ruft die Zeilen einer Textdatei einzeln ab.</li>
  <li><a href="commands/While.htm">While</a> führt eine Anweisung wiederholt aus, bis ein bestimmter Ausdruck als falsch gewertet wird. Der Ausdruck wird vor jedem Schleifendurchlauf ausgewertet.</li>
  <li><a href="commands/For.htm">For</a> führt eine Anweisung einmal für jeden Wert oder jedes Wertepaar aus, das von einem Enumerator zurückgegeben wird, wie z. B. für jedes Key-Wert-Paar in einem Objekt.</li>
</ul>
<p><a href="commands/Break.htm">Break</a> verlässt (terminiert) eine Schleife und bewirkt dadurch, dass die Zeile nach dem Schleifenkörper angesprungen wird.</p>
<p><a href="commands/Continue.htm">Continue</a> überspringt den Rest der aktuellen Schleife und beginnt einen neuen Durchlauf.</p>
<p><a href="commands/Until.htm">Until</a> lässt eine Schleife terminieren, wenn ein Ausdruck als True gewertet wird. Der Ausdruck wird nach jedem Schleifendurchlauf ausgewertet.</p>
<p>Ein <a href="#labels">Label</a> kann genutzt werden, um eine Schleife für <a href="commands/Continue.htm">Continue</a> und <a href="commands/Break.htm">Break</a> zu "benennen". Dies ermöglicht dem Skript, von einer inneren Schleife heraus den aktuellen Durchlauf einer äußeren Schleife zu überspringen oder die äußere Schleife zu unterbrechen, ohne <a href="commands/Goto.htm">Goto</a> verwenden zu müssen.</p>
<p>Die interne Variable <strong>A_Index</strong> enthält die Nummer des aktuellen Schleifendurchlaufs. Sie enthält eine 1, wenn der Schleifenkörper das erste Mal durchgeführt wurde. Beim zweiten Mal enthält sie eine 2; und so weiter. Wenn eine innere Schleife von einer äußeren Schleife umschlossen ist, hat die innere Schleife Vorrang. A_Index funktioniert in jeder Schleifenvariante, aber außerhalb einer Schleife enthält sie eine 0.</p>
<p>Einige Schleifentypen haben noch andere interne Variablen, die Informationen über das aktuelle Schleifenelement liefern (Registry-Key/Wert, Datei, Teilzeichenkette oder Textzeile). Solche Variablen haben Namen, die mit <strong>A_Loop</strong> beginnen, wie z. B. A_LoopFileName und A_LoopReadLine. Ihre Werte gehören immer der zuletzt gestarteten (aber noch nicht gestoppten) Schleife des entsprechenden Typs. A_LoopField beispielsweise gibt die aktuelle Teilzeichenkette der innersten Parsing-Schleife zurück, auch wenn sie innerhalb einer Datei- oder Registry-Schleife verwendet wird.</p>
<pre>t := "Spalte 1`tSpalte 2`nWert 1`tWert 2"
Loop Parse t, "`n"
{
    Reihentext := A_LoopField
    Reihennummer := A_Index  <em>; Für die Verwendung in der zweiten Schleife unten speichern.</em>
    Loop Parse Reihentext, "`t"
    {
        MsgBox Reihennummer ":" A_Index " = " A_LoopField
    }
}
</pre>
<p>Schleifenvariablen können auch außerhalb des Schleifenkörpers verwendet werden, wie z. B. in einer Funktion oder Subroutine, die aus einer Schleife heraus aufgerufen wird.</p>

<h3 id="not-control-flow">Keine Ablaufsteuerung</h3>
<p>Da Direktiven, Label (einschließlich Hotkeys und Hotstrings) und Deklarationen ohne Zuweisungen bereits verarbeitet werden, während das Skript aus der Datei geladen wird, unterliegen sie nicht der Ablaufsteuerung. Das heißt, dass sie bedingungslos wirksam werden, bevor das Skript überhaupt Ablaufsteuerungsanweisungen ausführt. Die <a href="commands/_If.htm">#If</a>-Direktive kann ebenfalls die Ablaufsteuerung nicht beeinflussen; sie legt lediglich die Kriterien für die im Code angegebenen Hotkey- und Hotstring-Label fest. Die Kriterien eines Hotkeys werden jedes Mal ausgewertet, wenn er gedrückt wird, und nicht, wenn die Ausführung auf die #If-Direktive trifft.</p>

<h2 id="structure-of-a-script">Aufbau eines Skripts</h2>

<h3 id="auto-execute-section">Automatischer Ausführungsbereich</h3>
<p>Das Skript startet, sofern es erfolgreich geladen wurde, bei der ersten Zeile und endet, wenn es entweder ein <a href="commands/Return.htm">Return</a>, <a href="commands/ExitApp.htm">Exit</a>, den ersten <a href="Hotkeys.htm">Hotkey-/Hotstring-Label</a> im Skript oder das physische Ende des Skripts erreicht hat (je nachdem was zuerst kommt). Dieser oberste Bereich des Skripts wird auch als <em>automatischer Ausführungsbereich</em> bezeichnet, aber tatsächlich ist er nur eine <a href="#subroutines">Subroutine</a>, die nach dem Programmstart aufgerufen wird.</p>
<p class="warning"><strong>Hinweis:</strong> Während das <em>erste</em> Hotkey/Hotstring-Label im Skript die gleiche Wirkung wie <a href="commands/Return.htm">Return</a> hat, haben andere Hotkeys und Label dies nicht.</p>
<p>Der automatische Ausführungsbereich wird oft genutzt, um Einstellungen zu konfigurieren, die für jeden neu gestarteten <a href="misc/Threads.htm">Thread</a> gelten. Weitere Informationen finden Sie unter <a href="Scripts.htm#auto">Der oberste Bereich des Skripts</a>.</p>

<h3 id="subroutines">Subroutinen</h3>
<p>Eine <em>Subroutine</em> (oder Sub) ist ein wiederverwendbarer Codeblock, der <em>aufgerufen</em> werden kann, um eine Aufgabe durchzuführen.</p>
<p>Skripte verwenden Subroutinen, um zu definieren, was passieren soll, wenn ein bestimmter Hotkey gedrückt wird oder ein anderes Ereignis eintritt. Skripte können Subroutinen auch direkt aufrufen, indem sie <a href="commands/Gosub.htm">Gosub</a> verwenden.</p>
<p>Es kann ein beliebiges <a href="#labels">Label</a> als Startpunkt einer Subroutine bestimmt werden. Eine Subroutine hat keinen explizit markierten Endpunkt, sondern endet, wenn die Kontrolle via <a href="commands/Return.htm">Return</a> an den Aufrufer der Subroutine zurückgegeben wird oder wenn der Thread beendet wird. Zum Beispiel:</p>
<pre>Gosub Label1

Label1:
MsgBox A_ThisLabel
return
</pre>
<p>Beachten Sie, dass aufgrund der Tatsache, dass Label wirkungslos sind, wenn sie während einer normalen Ausführung erreicht werden, das Mitteilungsfenster in diesem Beispiel zweimal angezeigt wird: einmal beim Ausführen der Subroutine und nochmals, nachdem die Subroutine ihr Return erreicht hat. Deshalb ist wichtig zu wissen, dass es nicht möglich ist, eine Subroutine innerhalb einer anderen Subroutine zu definieren, da der "Körper" der inneren Subroutine automatisch ausgeführt und dann via <em>Return</em> beendet wird, wodurch die äußere Subroutine beendet wird.</p>
<p>Subroutinen sollten in der Regel getrennt von allen anderen Codeblöcken definiert werden, aber sie können auch <a href="Functions.htm#gosub">innerhalb einer Funktion definiert</a> werden, um der Subroutine den Zugriff auf die statischen Variablen dieser Funktion (und lokale Variablen, aber nur während der Ausführung der Funktion) zu ermöglichen.</p>
<p class="warning"><strong>Hinweis:</strong> Subroutinen, die innerhalb einer Funktion definiert sind, haben gewisse Einschränkungen hinsichtlich der Verwendung von lokalen Variablen und <a href="#dynamic-variables">dynamischen Variablenreferenzen</a>. Weitere Informationen finden Sie unter <a href="Functions.htm#gosub">Verwenden von Subroutinen innerhalb einer Funktion</a>.
</p>

<h3 id="user-defined-functions">Benutzerdefinierte Funktionen</h3>
<p>Grundsätzlich ist eine <a href="Functions.htm">Funktion</a> so etwas wie eine Subroutine. In der AutoHotkey-Dokumentation bezieht sich "Subroutine" jedoch in der Regel auf die Art der Subroutine, die via Label definiert ist (siehe oben).</p>
<p>Benutzerdefinierte Funktionen unterscheiden sich von Subroutinen dadurch, dass sie <em>Parameter akzeptieren</em> und <em>einen Wert zurückgeben</em> können, und dass sie <a href="Functions.htm#Local">lokale Variablen</a> haben können. Sie können entweder durch einen <a href="#function-calls">Funktionsaufruf</a> innerhalb des Skripts oder durch das Programm selbst aufgerufen werden, z. B. wenn eine Funktion an <a href="commands/Hotkey.htm">Hotkey</a> oder <a href="commands/SetTimer.htm">SetTimer</a> übergeben wurde.</p>
<p>Funktionen werden mit einer Syntax definiert, die einem Funktionsaufruf ähnelt, gefolgt von einem Codeblock, der mit geschweiften Klammern umschlossen ist:</p>
<pre>MeineFunktion(ErsterParameter, Zweiter, ByRef Dritter, Vierter:="")
{
    ...
    return "ein Wert"
}
</pre>
<p>Wie bei Funktionsaufrufen auch, darf zwischen dem Funktionsnamen und der runden Startklammer kein Leerzeichen stehen.</p>
<p>Der Zeilenumbruch zwischen der runden Endklammer und der geschweiften Startklammer ist optional. Es kann eine beliebige Anzahl von Leerraumzeichen oder Kommentaren zwischen den beiden sein.</p>
<p><a href="Functions.htm#ByRef">ByRef</a> zeigt an, dass der Parameter eine Variablenreferenz akzeptiert, wodurch dieser Parameter ein Alias für jede Variable sein kann, die der Aufrufer übergibt. Wenn der Aufrufer keine Variable übergibt, verhält sich der Parameter wie eine normale lokale Variable. ByRef-Parameter können auch optional sein.</p>
<p>Um einen <a href="Functions.htm#optional">optionalen</a> Parameter anzugeben, fügt man nach dem Parameternamen <code>:=</code> an, gefolgt von einer direkt geschriebenen, in Anführungszeichen gesetzte Zeichenkette, einer Zahl, <code>True</code> oder <code>False</code>.</p>
<p>Die Funktion kann <a href="Functions.htm#return">einen Wert via Return zurückgeben</a>. Wenn sie das nicht tut, gibt sie standardmäßig eine leere Zeichenkette zurück.</p>
<p>Eine Funktion kann nicht innerhalb einer anderen Funktion definiert werden. Ansonsten spielt die Position einer Funktionsdefinition keine Rolle; jede im Skript definierte Funktion kann von überall her aufgerufen werden.</p>
<p class="note">Einzelheiten finden Sie unter <a href="Functions.htm">Funktionen</a>.</p>

<h3 id="-include">#Include</h3>
<p>Die <a href="commands/_Include.htm">#Include</a>-Direktive veranlasst das Skript, sich so zu verhalten, als wäre der Inhalt einer bestimmten Datei an genau dieser Stelle vorhanden. Dies wird oft verwendet, um Code in separaten Dateien aufzuteilen oder um Skriptbibliotheken anderer Benutzer zu nutzen.</p>
<p class="warning"><strong>Hinweis:</strong> In den folgenden Abschnitten werden einige Punkte aufgeführt, die viele Leute verwirrend finden.
</p>
<p>Wenn Sie #Include verwenden, sollten Sie beachten, welchen Effekt der Inhalt der Datei haben würde, wenn er an dieser Stelle platziert werden würde, da #Include denselben Effekt hat. Zum Beispiel:</p>
<ul>
  <li>
<p>#Include sollte grundsätzlich nicht in der Mitte einer Subroutine oder Funktion verwendet werden.</p>
</li>
  <li>
<p>Die Verwendung von #Include im <a href="#auto-execute-section">automatischen Ausführungsbereich</a> des Skripts sollte wohl überlegt sein, da der automatische Ausführungsbereich im Grunde nur eine Subroutine ist. Die Ausführung einer Subroutine stoppt, wenn sie ein <code>return</code> erreicht, unabhängig davon, in welcher Datei sich das <code>return</code> befindet. Wenn die Datei einen Hotkey/Hotstring enthält, kann sie auch als der <em>erste</em> Hotkey/Hotstring des Skripts betrachtet werden, der als <code>return</code> fungiert.</p>
</li>
  <li>
<p>Das Skript hat nur einen <a href="#auto-execute-section">automatischen Ausführungsbereich</a>, nicht pro Datei.</p>
</li>
</ul>
<p>#Include kann innerhalb des <a href="#auto-execute-section">automatischen Ausführungsbereichs</a> sicher verwendet werden, wenn die einzubeziehende Datei nur Funktionsdefinitionen enthält, da Funktionsdefinitionen (aber keine Funktionsaufrufe) während der Ausführung übersprungen werden. Um zu verhindern, dass eine Datei andere Codezeilen ausführt und dadurch den automatischen Ausführungsbereich unterbricht, überspringt man mithilfe von <a href="commands/Goto.htm">Goto</a> den Inhalt dieser Datei.</p>
<p>Im Gegensatz zu C/C++ macht #Include nichts, wenn die Datei bereits von einer früheren Direktive eingebunden wurde. Um den Inhalt einer Datei mehrfach einzubinden, nutzt man <a href="commands/_Include.htm">#IncludeAgain</a>.</p>
<p>Skriptdateien, die Funktionen enthalten, können <em>automatisch</em> ohne #Include eingebunden werden, wenn sie in einem Standardverzeichnis gespeichert und entsprechend benannt sind. Der Effekt ist das gleiche wie, als würde man #Include am Ende der Hauptskriptdatei nutzen. Weitere Informationen finden Sie unter <a href="Functions.htm#lib">Funktionsbibliotheken</a>.</p>

<h2 id="misc">Verschiedenes</h2>

<h3 id="dynamic-variables">Dynamische Variablen</h3>
<p>Eine <em>dynamische Variablenreferenz</em> nimmt einen Textwert und interpretiert ihn als Namen einer Variable.</p>
<p>Die bekannteste Form einer dynamischen Variablenreferenz nennt sich <em>Doppelreferenzierung</em> oder <em>double-deref</em>. Bevor man eine Doppelreferenzierung durchführen kann, muss der Name der Zielvariable in einer zweiten Variable gespeichert sein. Diese zweite Variable kann genutzt werden, um der Zielvariable indirekt einen Wert via Doppelreferenzierung zuzuweisen. Zum Beispiel:</p>
<pre>Ziel := 42
ZweiteVar := "Ziel"
MsgBox  ZweiteVar   <em>; Normale (einfache) Variablenreferenz =&gt; Ziel</em>
MsgBox %ZweiteVar%  <em>; Doppelreferenzierung =&gt; 42</em>
</pre>
<p>Momentan muss <code>ZweiteVar</code> im zweiten Fall immer einen Variablennamen enthalten; beliebige Ausdrücke werden nicht unterstützt.</p>
<p>Eine dynamische Variablenreferenz kann auch einen oder mehrere direkt geschriebene Texte und den Inhalt einer oder mehrerer Variablen zu einem einzigen Variablennamen zusammenfügen. Dazu schreibt man einfach die Bestandteile des Namens und die mit Prozentzeichen umschlossenen Variablen der Reihe nach ohne Leerzeichen auf. Zum Beispiel: <code>MeinArray%A_Index%</code> oder <code>MeinRaster%X%_%Y%</code>. Mit dieser Methode kann man auf <em>Pseudo-Arrays</em> zugreifen, wie unten beschrieben.</p>
<p>Diese Techniken können auch auf Eigenschaften und Methoden von Objekten angewendet werden. Zum Beispiel:</p>
<pre>Farbe := {}
for n, Komponente in ["Rot", "Grün", "Blau"]
    Farbe.%Komponente% := Random(0, 255)
MsgBox Farbe.Rot "," Farbe.Grün "," Farbe.Blau</pre>

<h4 id="pseudo-arrays">Pseudo-Arrays</h4>
<p>Ein <em>Pseudo-Array</em> ist eigentlich nur ein Haufen einzelner Variablen, deren Namensmuster es aber möglich machen, sie wie Elemente eines Arrays zu verwenden. Zum Beispiel:</p>
<pre>
MeinArray1 := "A"
MeinArray2 := "B"
MeinArray3 := "C"
Loop 3
    MsgBox MeinArray%A_Index%  <em>; Zeigt A, dann B, dann C.</em>
</pre>
<p>Da es sich bei den einzelnen Elementen um normale Variablen handelt, kann man zwar einen Wert zuweisen oder abrufen, aber keine Elemente <em>entfernen</em> oder <em>einfügen</em>. Aufgrund der Tatsache, dass das Pseudo-Array eigentlich nicht existiert, kann es nicht an eine Funktion übergeben oder von einer Funktion zurückgegeben werden, oder als Ganzes kopiert werden. Aus diesen Gründen ist es in der Regel ratsam, <a href="Objects.htm#Usage_Simple_Arrays">normale Arrays</a> wenn möglich zu verwenden.</p>

<h4 id="associative-pseudo-arrays">Assoziative Pseudo-Arrays</h4>
<p>Der "Index", mit dem der endgültige Variablenname gebildet wurde, muss nicht numerisch sein; er kann auch ein Buchstabe oder Schlüsselwort sein, um das Pseudo-Array ähnlich zu einem <a href="Objects.htm#Usage_Associative_Arrays">assoziativen Array</a> oder einem <a href="Objects.htm">Objekt</a> zu machen.</p>

<h3 id="labels">Label</h3>
<p>Ein Label identifiziert eine Codezeile. Es dient als Ziel von <a href="commands/Goto.htm">Goto</a> oder formt eine <a href="#subroutines">Subroutine</a>. Es gibt drei verschiedene Labeltypen: Normale benannte Label, <a href="Hotkeys.htm">Hotkey</a>-Label und <a href="Hotstrings.htm">Hotstring</a>-Label.</p>
<p>Normale Label bestehen aus einem Namen, gefolgt von einem Doppelpunkt.</p>
<pre>das_ist_ein_Label:
</pre>
<p>Hotkey-Label bestehen aus einem Hotkey, gefolgt von zwei Doppelpunkten.</p>
<pre>^a::
</pre>
<p>Hotstring-Label bestehen aus einem Doppelpunkt, null oder mehr <a href="Hotstrings.htm#Options">Optionen</a>, einem weiteren Doppelpunkt, einer Abkürzung und zwei Doppelpunkten.</p>
<pre>:*:bzw::
</pre>
<p>Grundsätzlich darf, außer Leerraumzeichen und Kommentare, kein anderer Code auf der Zeile eines Labels stehen. Allerdings:</p>
<ul>
  <li>Direkt nach einem Hotkey-Label kann ein Funktionsaufruf oder eine andere Anweisung erfolgen, um einen <em>einzeiligen</em> Hotkey zu erstellen. Mit anderen Worten: Wenn ein Funktionsaufruf, eine Zuweisung oder ein Ausdruck auf der Zeile eines Hotkey-Labels vorhanden ist, verhält es sich so, als ob danach ein <code>return</code> angegeben wurden wäre.</li>
  <li>Ein Hotkey, der rechts neben den zwei Doppelpunkten einen <a href="KeyList.htm">Tastennamen</a> stehen hat, ist eigentlich eine <a href="misc/Remap.htm"><em>Neubelegung</em></a>, also eine Kurzschreibweise für ein <a href="misc/Remap.htm#actually">Hotkey-Paar</a>. <code>a::b</code> beispielsweise erstellt Hotkeys und Labels für <code>*a</code> und <code>*a Up</code>, aber erstellt kein Label mit dem Namen <code>a</code>.</li>
  <li>Ein Hotstring, der rechts neben den letzten zwei Doppelpunkten Text stehen hat, ist ein <em>automatisch-ersetzender</em> Hotstring. Automatisch-ersetzende Hotstrings werden nicht als Label angesehen.</li>
</ul>
<p>Weitere Informationen finden Sie unter <a href="misc/Labels.htm">Label</a>.</p>

</body>
</html>
