<!DOCTYPE HTML>
<html>
<head>
<title>Funktionen</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="robots" content="noindex, nofollow">
<link href="static/theme.css" rel="stylesheet" type="text/css" />
<script src="static/content.js" type="text/javascript"></script>
<script src="static/ga.js" type="text/javascript"></script>
</head>

<body>
<h1>Funktionen</h1>

<h2>Inhaltsverzeichnis</h2>
<ul>
  <li><a href="#intro">Einführung und einfache Beispiele</a></li>
  <li><a href="#param">Parameter</a></li>
  <li><a href="#optional">Optionale Parameter</a></li>
  <li><a href="#return">Rückgabewerte an den Aufrufer</a></li>
  <li><a href="#Variadic">Variadische Funktionen</a></li>
  <li><a href="#Locals">Lokale Variablen</a></li>
  <li><a href="#DynCall">Dynamisches Aufrufen einer Funktion</a></li>
  <li><a href="#ShortCircuit">Logische Kurzschlussauswertung</a></li>
  <li><a href="#gosub">Verwenden von Subroutinen innerhalb einer Funktion</a></li>
  <li><a href="#remarks">Return, Exit und allgemeine Bemerkungen</a></li>
  <li><a href="#include">Skripte mittels #Include auf die gleichen Funktionen zugreifen lassen</a></li>
  <li><a href="#lib">Libraries mit Funktionen: Standard- und Benutzer-Library</a></li>
  <li><a href="#BuiltIn">Built-in-Funktionen</a></li>
</ul>
<h2 id="intro">Einführung und einfache Beispiele</h2>
<p id="define">Eine Funktion ist prinzipiell das gleiche wie eine Subroutine (<a href="commands/Gosub.htm">GoSub</a>), außer dass sie Parameter (Eingabewerte) von ihrem Aufrufer entgegennehmen kann. Darüber hinaus kann eine Funktion optional einen Wert an den Aufrufer zurückgeben. Das folgende Beispiel zeigt, wie eine einfache Funktion zwei Zahlen entgegennimmt und deren Summe zurückgibt:</p>
<pre>Addieren(x, y)
{
    <a href="commands/Return.htm">return</a> x + y
}</pre>
<p>So etwas nennt man auch eine <em>Funktionsdefinition</em>, weil es eine Funktion mit dem Namen "Addieren" erstellt (Groß- und Kleinschreibung ist egal) und festlegt, dass jeder, der sie aufruft, genau zwei Parameter (x und y) bereitstellen muss. Um die Funktion aufzurufen, speichert man ihr Ergebnis mithilfe des <a href="commands/SetExpression.htm">Doppelpunkt-Gleich-Operators</a> (<strong><a href="commands/SetExpression.htm">:=</a></strong>) in eine Variable. Zum Beispiel:</p>
<pre>Var := Addieren(2, 3)  <em>; Speichert die Zahl 5 in Var.</em></pre>
<p>Man kann eine Funktion auch aufrufen, ohne ihren Rückgabewert speichern zu müssen:</p>
<pre>Addieren(2, 3)
Addieren 2, 3  <em>; Runde Klammern können weggelassen werden, wenn die Anweisung am Anfang einer Zeile steht.</em></pre>
<p>In diesem Fall aber wird der zurückgegebene Wert der Funktion verworfen; wenn die Funktion nur einen Rückgabewert erzeugen würde, wäre ihr Aufruf daher sinnlos.</p>
<p>Innerhalb eines Ausdrucks wird ein Funktionsaufruf in den Rückgabewert der Funktion "umgewandelt". Der Rückgabewert kann in eine Variable gespeichert werden, wie oben gezeigt, oder kann wie folgt direkt benutzt werden:</p>
<pre>if <a href="commands/InStr.htm">InStr</a>(MeineVar, "Fuchs")
    MsgBox "Die Variable MeineVar enthält das Wort Fuchs."</pre>

<h2 id="param">Parameter</h2>
<p>Beim Definieren einer Funktion werden die Parameter neben dem Funktionsnamen in runden Klammern aufgelistet (Leerzeichen zwischen dem Namen und der runden Startklammer sind nicht erlaubt). Braucht die Funktion keine Parameter, können die runden Klammern leer gelassen werden; zum Beispiel: <code>ErmittleAktuellenZeitstempel()</code>.</p>
<p id="ByRef"><strong>ByRef-Parameter</strong>: Innerhalb der Funktion werden Parameter grundsätzlich wie <a href="#Locals">lokale Variablen</a> behandelt, sofern sie nicht wie folgt als <em>ByRef</em>-Parameter definiert werden:</p>
<pre>Tauschen(ByRef Links, ByRef Rechts)
{
    temp := Links
    Links := Rechts
    Rechts := temp
}</pre>
<p>Das Benutzen von <em>ByRef</em> bewirkt, dass die angegebene Variable mit dem Parameter verbunden wird. Das heißt, dass der Parameter und die Variable des Aufrufers auf den gleichen Inhalt im Arbeitsspeicher verweisen. Auf diese Weise kann die Tauschen-Funktion die Variablen des Aufrufers ändern, indem sie den Inhalt der <em>Links</em>-Variable in die <em>Rechts</em>-Variable verschiebt, und umgekehrt.</p>
<p>Würde man <em>ByRef</em> hingegen nicht verwenden, wären <em>Links</em> und <em>Rechts</em> nur Kopien der Variablen des Aufrufers - die Tauschen-Funktion hätte keine externe Auswirkung.</p>
<p>Da <a href="commands/Return.htm">Return</a> nur einen einzigen Wert an den Funktionsaufrufer zurückgeben kann, ist <em>ByRef</em> gut dafür geeignet, zusätzliche Ergebnisse zurückzugeben. Bringe den Aufrufer einfach dazu, eine Variable zu übergeben (üblicherweise leer), in der die Funktion einen Wert speichern kann.</p>
<p>Beim Übergeben langer Zeichenketten an eine Funktion ist <em>ByRef</em> leistungsfähiger und außerdem platzsparend, weil keine Kopie der Zeichenkette gemacht werden muss. Ebenso ist <em>ByRef</em>, wenn man eine lange Zeichenkette an den Aufrufer zurücksenden will, leistungsfähiger als <code>Return LangeZeichenkette</code>.</p>
<p>Übergibt man etwas anderes als eine veränderbare Variable an einen ByRef-Parameter, verhält sich die Funktion so, als wäre das Schlüsselwort "ByRef" nicht vorhanden. Zum Beispiel würde <code>Tauschen(A_Index, i)</code> den Wert von <i>A_Index</i> in <i>i</i> speichern, aber den gespeicherten Wert in <i>Links</i> verwerfen, sobald die <i>Tauschen</i>-Funktion fertig ist.</p>
<p>Mit der <a href="#IsByRef">IsByRef</a>-Funktion kann festgestellt werden, ob der Aufrufer eine Variable für einen bestimmten ByRef-Parameter bereitgestellt hat.</p>
<p>Bekannte Einschränkungen:</p>
<ul>
  <li>Es ist nicht möglich, Objekteigenschaften (z. B. <code>foo.bar</code>), <a href="misc/Clipboard.htm">Clipboard</a> oder andere <a href="Variables.htm#BuiltIn">Built-In-Variablen</a> an eine Funktion via Verweis zu übergeben. Stattdessen wird sich die Funktion so verhalten, als hätte man <em>ByRef</em> weggelassen.</li>
  <li id="recurse">Theoretisch kann eine Funktion sich selbst rekursiv aufrufen. Wenn sie sich jedoch selbst ihre eigenen <a href="#Locals">lokalen Variablen</a> oder Nicht-ByRef-Parameter per <em>ByRef</em> übergibt, wird der <em>ByRef</em>-Parameter des neuen Ablegers auf seine eigene lokale Variable mit selben Namen verweisen, anstatt auf dem Namen des vorherigen Ablegers. Allerdings tritt dieses Problem nicht auf, wenn eine Funktion sich selbst eine <a href="#Global">globale Variable</a>, <a href="#static">statische Variable</a> oder einen <em>ByRef</em>-Parameter übergibt.</li>
  <li>Wenn ein Parameter bei einem Funktionsaufruf in eine Variable aufgelöst wird (z. B. <code>Var</code> oder <code>++Var</code> oder <code>Var *= 2</code>), können andere Parameter auf der linken oder rechten Seite diese Variable ändern, bevor sie an die Funktion übergeben wird. Zum Beispiel würde <code>Funktion(Var, Var++)</code> unerwartet eine 0 und 1 übergeben, wenn <em>Var</em> zu Beginn 0 ist, selbst wenn der erste Parameter der Funktion nicht als <em>ByRef</em> markiert ist. Da dieses Verhalten unlogisch ist, könnte es in einer zukünftigen Version geändert werden.</li>
  <li>ByRef werden nicht direkt in Funktionen unterstützt, die von COM-Clienten aufgerufen werden, oder beim Aufrufen von COM-Methoden. Stattdessen wird das Skript ein <a href="commands/ComObject.htm#ByRef">Wrapper-Objekt</a> übergeben müssen oder empfangen, das den <a href="commands/ComObjType.htm">VarTyp</a> und die Adresse des Wertes enthält.</li>
</ul>
<h2 id="optional">Optionale Parameter</h2>
<p>Bei einer Funktionsdefinition können die Parameter als optional gekennzeichnet werden. Dazu muss ein Zuweisungsoperator und ein Standardwert angefügt werden. Im folgenden Beispiel ist der Z-Parameter als optional gekennzeichnet:</p>
<pre>Add(X, Y, Z := 0) {
    return X + Y + Z
}</pre>
<p>Übergibt der Aufrufer <strong>drei</strong> Parameter an die obere Funktion, wird der Standardwert von Z ignoriert. Wenn der Aufrufer aber nur <strong>zwei</strong> Parameter übergibt, wird in Z automatisch der Wert 0 gespeichert.</p>
<p id="missing">Es ist nicht möglich, alleinstehende optionale Parameter in der Mitte der Parameterliste zu verwenden. Das heißt, dass alle Parameter, die auf der rechten Seite des ersten optionalen Parameters vorkommen, auch als optional gekennzeichnet werden müssen. Beim Aufrufen der Funktion können die optionale Parameter in der Mitte der Parameterliste weggelassen werden, wie unten gezeigt:</p>
<pre>Funktion(1,, 3)
Funktion(X, Y:=2, Z:=0) {  <em>; Beachte, dass Z in diesem Fall weiterhin optional sein muss.</em>
    MsgBox X ", " Y ", " Z
}</pre>
<p id="OptionalByRef"> <a href="#ByRef">ByRef-Parameter</a> unterstützen auch Standardwerte; zum Beispiel: <code>Funktion(ByRef p1 := "")</code>. Jedes Mal, wenn der Aufrufer einen solchen Parameter weglässt, erstellt die Funktion eine lokale Variable, die den Standardwert enthält; das heißt, dass die Funktion sich so verhält, als würde das Schlüsselwort "ByRef" fehlen.</p>
<p>Als Standardwert eines Parameters sind folgende Werte zulässig: <code>True</code>, <code>False</code>, ein literaler Integer, eine literale Gleitkommazahl oder eine literale Zeichenkette wie "fox" oder "".</p>
<h2 id="return">Rückgabewerte an den Aufrufer</h2>
<p>Wie man bereits in der <a href="#intro">Einführung</a> lesen konnte, kann eine Funktion dazu gebracht werden, einen Wert per <a href="commands/Return.htm">Return</a> an ihren Aufrufer zurückzugeben.</p>
<pre>
MsgBox returnTest()

returnTest() {
  return 123
}
</pre>
<p>Wenn noch mehr Ergebnisse von einer Funktion zurückgegeben werden sollen, kann man auch <a href="#ByRef">ByRef</a> verwenden:</p>
<pre>
returnByRef(A,B,C)
MsgBox A "," B "," C

returnByRef(ByRef Wert1, ByRef Wert2, ByRef Wert3)
{
  Wert1 := "A"
  Wert2 := 100
  Wert3 := 1.1
  return
}
</pre>
<p>Mithilfe von Objekten und Arrays können mehrere Werte oder sogar benannte Werte zurückgegeben werden:</p>
<pre>
Test1 := returnArray1()
MsgBox Test1[1] "," Test1[2]

Test2 := returnArray2()
MsgBox Test2[1] "," Test2[2]

Test3 := returnObject()
MsgBox Test3.id "," Test3.val

returnArray1() {
  Test := [123,"ABC"]
  return Test
}

returnArray2() {
  x := 456
  y := "EFG"
  return [x, y]
}

returnObject() {
  Test := {id: 789, val: "HIJ"}
  return Test
}
</pre>
<h2 id="Variadic">Variadische Funktionen</h2>
<p>Bei einer Funktionsdefinition kann ein Sternchen nach dem letzten Parameter angegeben werden, um die Funktion als variadisch zu kennzeichnen, so dass sie eine beliebige Anzahl an Parametern akzeptieren kann:</p>
<pre>Verbinden(sep, <b class="blue">params*</b>) {
    for index,param in params
        str .= param . sep
    return SubStr(str, 1, -StrLen(sep))
}
MsgBox Verbinden("`n", "eins", "zwei", "drei")</pre>
<p>Ruft man eine variadische Funktion auf, sind überschüssige Parameter über ein Objekt zugreifbar, das im letzten Parameter der Funktion gespeichert ist. Der erste überschüssige Parameter ist <code>params[1]</code>, der Zweite ist <code>params[2]</code> und so weiter. Da es ein Standard-<a href="objects/Object.htm">Objekt</a> ist, kann mit <code>params.<a href="objects/Object.htm#Length">Length</a>()</code> die Parameteranzahl ermittelt werden.</p>
<p>Hinweise:</p>
<ul>
  <li>Der "variadische" Parameter kann nur am Ende der formalen Parameterliste verwendet werden.</li>
  <li><a href="misc/RegExCallout.htm">RegEx-Callouts</a> können nicht variadisch sein; der "variadische" Parameter wird zwar toleriert, aber leer gelassen.</li>
  <li><a href="commands/RegisterCallback.htm">Callbacks</a> übergeben überschüssige Parameter <a href="commands/RegisterCallback.htm#Indirect">per Adresse</a>, anstatt per Array.</li>
</ul>
<h3 id="VariadicCall">Variadische Funktionsaufrufe</h3>
<p>Während variadische Funktionen eine beliebige Parameteranzahl <i>akzeptieren</i> können, kann ein Array mit Parametern an <i>jede</i> Funktion durch Anwenden der gleichen Syntax beim Funktionsaufruf übergeben werden:</p>
<pre>Teilzeichenketten := ["eins", "zwei", "drei"]
MsgBox Verbinden("`n", <b class="blue">Teilzeichenketten*</b>)</pre>
<p>Hinweise:</p>
<ul>
  <li>Die Nummerierung der Parameter beginnt innerhalb des Quell-Arrays bei 1.</li>
  <li>Optionale Parameter können im Array ganz weggelassen werden.</li>
  <li>Das Array mit Parametern kann benannte Elemente beim Aufrufen einer benutzerdefinierten Funktion enthalten; in allen anderen Fällen werden benannte Elemente nicht unterstützt.</li>
  <li>Die Zielfunktion kann auch variadisch sein - in diesem Fall werden benannte Elemente kopiert, selbst wenn sie keine entsprechenden formalen Parameter haben.</li>
  <li>Diese Syntax kann auch zum Aufrufen einer Methode,oder zum Abrufen oder Setzen von Objekteigenschaften verwendet werden; zum Beispiel <code>Objekt.Eigenschaft[Params*]</code>.</li>
</ul>
<p>Bekannte Einschränkungen:</p>
<ul>
  <li>Nur der Parameter, der ganz rechts vorkommt, kann auf diese Weise erweitert werden. Zum Beispiel wird <code>Funktion(x, y*)</code> unterstützt, aber nicht <code>Funktion(x*, y)</code>.</li>
  <li>Es dürfen keine Leerraumzeichen zwischen dem Sternchen (<code>*</code>) und dem Endzeichen der Parameterliste vorkommen.</li>
</ul>
<h2 id="Locals">Lokale und globale Variablen</h2>
<h3>Lokale Variablen</h3>
<p>Lokale Variablen gelten nur für eine einzige Funktion und sind nur in dieser sichtbar. Daher kann eine lokale Variable den gleichen Namen haben wie eine globale Variable, aber mit unterschiedlichem Inhalt. Separate Funktionen können ohne Probleme die gleichen Variablennamen benutzen.</p>
<p>Alle lokalen Variablen, die nicht <a href="#static">statisch</a> sind, werden automatisch freigegeben (leer gemacht), wenn die Funktion ihr Ende erreicht hat.</p>
<p>Variablen, die innerhalb einer Funktion abgerufen oder erstellt werden, sind standardmäßig lokal, aber es gibt folgende Ausnahmen:</p>
<ul>
  <li><a href="#SuperGlobal">Superglobale</a> Variablen, inklusive <a href="Objects.htm#Custom_Classes">Klassen</a>.</li>
  <li>Built-In-Variablen wie <a href="misc/Clipboard.htm">Clipboard</a>, <a href="misc/ErrorLevel.htm">ErrorLevel</a> und <a href="Variables.htm#TimeIdle">A_TimeIdle</a>.</li>
</ul>
<p>Zudem kann das Standardverhalten wie unten gezeigt überschrieben werden.</p>

<h3 id="Global">Globale Variablen</h3>
<p>Um innerhalb einer Funktion auf eine vorhandene globale Variable zu verweisen (oder eine neue zu erstellen), deklariere die Variable als global, bevor man sie verwendet. Zum Beispiel:</p>
<pre>LogZuDatei(TextZuLog)
{
    <strong>global</strong> LogDateiname  <em>; Dieser globalen Variable wurde bereits ein Wert außerhalb dieser Funktion zugewiesen.</em>
    FileAppend TextZuLog "`n", LogDateiname
}</pre>
<p id="AssumeGlobal"><strong>Global-behandelnder Modus</strong>: Muss eine Funktion viele globale Variablen erstellen oder auf sie zugreifen, kann die Funktion so definiert werden, dass sie all ihre Variablen (außer ihre Parameter) global behandelt. Dazu muss in der ersten Zeile das Wort "global" stehen. Zum Beispiel:</p>
<pre>SetzeStandardwerte()
{
    <strong>global</strong>
    MeineGlobal := 33  <em>; Speichert 33 in eine globale Variable und erstellt sie, falls notwendig.</em>
    local x, y:=0, z  <em>; Lokale Variablen müssen in diesem Modus deklariert werden, weil sie sonst global behandelt werden.</em>
}</pre>
<p>Dieser global-behandelnde Modus kann auch von einer Funktion verwendet werden, um ein globales <a href="misc/Arrays.htm">Pseudo-Array</a> zu erstellen - wie bei einer Schleife, die Werte per <code>Array%A_Index%</code> zuweist.</p>
<p id="SuperGlobal"><strong>Superglobale Variablen</strong>: Geschieht eine globale Deklaration außerhalb einer Funktion, gilt sie standardmäßig für alle Funktionen. Dadurch wird verhindert, dass die Variablen jedes Mal in einer Funktion neu deklariert werden müssen. Funktionsparameter oder lokale Variablen mit gleichem Namen haben Vorrang vor der globalen Variable. Variablen, die mit dem Schlüsselwort <a href="Objects.htm#Custom_Classes">class</a> erzeugt wurden, sind auch superglobal.</p>
<h3 id="static">Statische Variablen</h3>
<p>Statische Variablen sind im Prinzip immer lokal. Der Unterschied ist aber, dass ihre Werte zwischen den Funktionsaufrufen erhalten bleiben. Zum Beispiel:</p>
<pre>LogZuDatei(TextZuLog)
{
    <strong>static</strong> Zeilenanzahl := 0
    Zeilenanzahl += 1  <em>; Behandelt einen Zähler lokal (der Wert bleibt zwischen den Funktionsaufrufen erhalten).</em>
    global LogDateiname
    FileAppend Zeilenanzahl ": " TextZuLog "`n", LogDateiname
}</pre>
<p id="InitStatic">Eine statische Variable kann nicht nur deklariert, sondern auch initialisiert werden, indem man danach <code>:=</code> und ein <a href="Variables.htm#Expressions">Ausdruck</a> anfügt. Zum Beispiel: <code>static X:=0, Y:="fox"</code>. Jede statische Variable wird nur einmal initialisiert. Die Initialisierung von statischen Variablen erfolgt in der Reihenfolge ihrer aktuellen Position innerhalb der Skriptdatei, aber vor dem automatischen Ausführungsbereich des Skripts.</p>
<p id="AssumeStatic"><strong>Statisch-behandelnder Modus</strong>: Eine Funktion kann so definiert werden, dass sie all ihre Variablen (außer ihre Parameter) statisch behandelt. Dazu muss in der ersten Zeile das Wort "static" stehen. Zum Beispiel:</p>
<pre>ErmittleVomStatischenArray(Elementnummer)
{
    <strong>static</strong>
    static ErsterAufruf := true  <em>; Die Initialisierung einer statischen Deklaration wird nur einmal ausgeführt (beim Start).</em>
    if ErsterAufruf  <em>; Erstellt ein statisches Array beim ersten Aufruf, aber nicht mehr danach.</em>
    {
        ErsterAufruf := false
        Loop 10
            StatischesArray%A_Index% := "Wert #" . A_Index
    }
    return StatischesArray%Elementnummer%
}</pre>
<p>Im statisch-behandelnden Modus muss jede Variable, die nicht statisch sein soll, als lokal oder global deklariert werden.</p>
<h3>Mehr über lokale und globale Variablen</h3>
<p>Es ist möglich, mehrere Variablen auf der gleichen Zeile zu deklarieren, wenn sie wie folgt durch Kommas getrennt werden:</p>
<pre>global LogDateiname, MaxVersuche := 5
static GesamtVersuche := 0, VorherErgebnis</pre>
<p id="DeclareInit">Eine lokale oder globale Variable kann nicht nur deklariert, sondern auch initialisiert werden, indem man danach <code>:=</code> und ein <a href="Variables.htm#Expressions">Ausdruck</a> anfügt. Im Gegensatz zu <a href="#InitStatic">statischen Initialisierungen</a> werden die Initialisierungen von lokalen oder globalen Variablen bei jedem Funktionsaufruf ausgeführt, sofern sie von der Ablaufsteuerung erreicht werden. Das heißt, dass eine Zeile wie <code>local x := 0</code> den gleichen Effekt hat wie die zwei folgenden Zeilen: <code>local x</code>, gefolgt von <code>x := 0</code>.</p>
<p>Da die Wörter <em>local</em>, <em>global</em> und <em>static</em> unmittelbar beim Starten des Skripts verarbeitet werden, kann eine Variable nicht bedingt per <a href="commands/IfExpression.htm">IF-Anweisung</a> deklariert werden. Das heißt, dass eine Deklaration innerhalb eines IF- oder ELSE-<a href="commands/Block.htm">Blocks</a> bedingungslos für alle Zeilen zwischen der Deklaration und der geschweiften Endklammer der Funktion wirksam wird. Beachte zudem, dass es zurzeit nicht möglich ist, eine dynamische Variable wie <code>global Array%i%</code> zu deklarieren.</p>

<h2 id="DynCall">Dynamisches Aufrufen einer Funktion</h2>
<p>Eine Funktion (auch eine <a href="#BuiltIn">Built-in-Funktion</a>) kann mithilfe von Prozentzeichen dynamisch aufgerufen werden. Zum Beispiel würde <code>%Var%(x, "Fuchs")</code> die Funktion aufrufen, deren Name in <em>Var</em> enthalten ist. Ebenso würde <code>Funktion%A_Index%()</code> Funktion1(), Funktion2() und so weiter aufrufen, abhängig vom aktuellen Wert in A_Index.</p>
<p><em>Var</em> in <code>%Var%()</code> kann einen Funktionsnamen oder ein <a href="objects/Functor.htm">Funktionsobjekt</a> enthalten. Falls die Funktion nicht existiert, wird stattdessen die __Call-Meta-Funktion des <a href="Objects.htm#Default_Base_Object">Standard-base-Objekts</a> aufgerufen (und wenn diese Methode undefiniert ist, wie immer die __Call-Meta-Funktion aufgerufen).</p>
<p>Kann die Funktion aufgrund einer der unten genannten Gründe nicht aufgerufen werden, wird eine <a href="commands/Catch.htm#RuntimeErrors">Ausnahme</a> ausgelöst:</p>
<ul>
  <li>Aufrufen einer nicht-existierenden Funktion, das mithilfe von <code>If <a href="#IsFunc">IsFunc</a>(VariableMitFunktionsname)</code> verhindert werden kann. Die <a href="#define">Definition</a> der aufgerufenen Funktion (außer <a href="#BuiltIn">Built-in-Funktionen</a>) muss explizit im Skript vorkommen (zum Beispiel über <a href="commands/_Include.htm">#Include</a> oder einem nicht-dynamischen Aufruf einer <a href="#lib">Library-Funktion</a>).</li>
  <li>Übergeben von zu wenigen Parametern, das verhindert werden kann, wenn der Rückgabewert von <a href="#IsFunc">IsFunc</a> überprüft wird (das ist die Anzahl der Pflichtparameter plus 1). Hinweis: Die Übergabe von zu vielen Parametern wird toleriert; jeder zusätzliche Parameter wird vollständig ausgewertet (einschließlich aller Funktionsaufrufe) und dann verworfen.</li>
</ul>
<p>Beachte, dass ein dynamischer Aufruf einer Funktion etwas langsamer ist als ein normaler Aufruf, weil normale Aufrufe aufgelöst (nachgeschlagen) werden, bevor das Skript seine Ausführung beginnt.</p>
<h2 id="ShortCircuit">Logische Kurzschlussauswertung</h2>
<p>Sobald <em>AND, OR</em> und der <a href="Variables.htm#ternary">ternäre Operator</a> innerhalb eines <a href="Variables.htm#Expressions">Ausdrucks</a> verwendet werden, schließen sie sich kurz, um die Performance zu erhöhen (egal ob Funktionsaufrufe vorhanden sind oder nicht). Beim Kurzschließen werden nur Bereiche des Ausdrucks ausgewertet, die Einfluss auf das Endergebnis haben. Im folgenden Beispiel wird gezeigt, wie genau das funktioniert:</p>
<pre>if (FarbName &lt;&gt; "" AND not FindeFarbe(FarbName))
    MsgBox FarbName " konnte nicht gefunden werden."</pre>
<p>Wenn die <em>FarbName</em>-Variable leer sein sollte, wird die FindeFarbe()-Funktion niemals aufgerufen, weil die linke Seite von <em>AND</em> als <em>falsch</em> gewertet wird, wodurch die rechte Seite nicht mehr in der Lage wäre, das Endergebnis auf <em>wahr</em> zu bringen.</p>
<p>Dieses Verhalten führt dazu, dass Nebeneffekte von einer Funktion (wie das Ändern des Inhalts einer globalen Variable) nie auftreten werden, wenn diese Funktion auf der rechten Seite von <em>AND</em> oder <em>OR</em> aufgerufen wird.</p>
<p>Beachte außerdem, dass die Kurzschlussauswertung verschachtelte <em>AND</em>s und <em>OR</em>s stufenweise durchgeht. Im Ausdruck des folgenden Beispiels würde nur der Vergleich ganz links erfolgen, wann immer <em>FarbName</em> leer ist, weil die linke Seite dann ausreichen würde, um das Endergebnis mit Sicherheit zu bestimmen:</p>
<pre>if (FarbName = "" <u>OR</u> FindeFarbe(FarbName, Region1) <u>OR</u> FindeFarbe(FarbName, Region2))
    break   <em>; Nichts zu durchsuchen oder Übereinstimmung gefunden.</em></pre>
<p>Wie die Beispiele oben zeigen, sollten lange (zeitaufwendige) Funktionen generell auf der rechten Seite von <em>AND</em> oder <em>OR</em> aufgerufen werden, um die Performance zu erhöhen. Diese Technik kann auch dazu genutzt werden, das Aufrufen einer Funktion zu verhindern, wenn ein ungeeigneter Wert (z. B. eine leere Zeichenkette) an einen ihrer Parameter übergeben wird.</p>
<p>Beim <a href="Variables.htm#ternary">ternären Bedingungsoperator (?:)</a> erfolgt auch eine Kurzschließung durch Ignorieren der verlierenden Abzweigung.</p>
<h2 id="gosub">Verwenden von Subroutinen innerhalb einer Funktion</h2>
<p>Eine Funktion kann keine <a href="#define">Definitionen</a> von anderen Funktionen enthalten. Subroutinen sind aber möglich. Sie können, wie jede andere Subroutine auch, per <a href="commands/Gosub.htm">GoSub</a> gestartet und per <a href="commands/Return.htm">Return</a> beendet werden (in diesem Fall gilt das Return nicht für die Funktion, sondern für das GoSub).</p>
<p id="GosubPublic">Verwendet eine Funktion das <a href="commands/Gosub.htm">GoSub</a>, um zu einer öffentlichen Subroutine zu springen (die sich außerhalb der geschweiften Funktionsklammern befindet), sind alle Variablen außerhalb global und die funktions-eigenen <a href="#Locals">lokalen Variablen</a> nicht abrufbar, bis die Subroutine ihr Return erreicht hat. Allerdings wird A_ThisFunc weiterhin den Namen der Funktion enthalten.</p>
<p>Das <a href="commands/Goto.htm">Goto</a> kann nicht verwendet werden, um vom Inneren der Funktion nach außen zu springen. Allerdings kann eine Funktion per <a href="commands/Gosub.htm">GoSub</a> zu einer externen/öffentlichen Subroutine springen und von dort aus per Goto weiterspringen.</p>
<p>In der Regel sollte man auf <a href="commands/Goto.htm">Goto</a> verzichten. Dieser Befehl kann aber innerhalb einer Funktion nützlich sein, wo man auf eine andere Position springen muss. Diese Methode kann helfen, komplexe Funktionen zu vereinfachen, die mehrere Rückgabepunkte haben, bei denen zuvor einige Säuberungsaktionen durchgeführt werden müssen.</p>
<p>Eine Funktion kann extern-aufrufende Subroutinen wie <a href="commands/SetTimer.htm">Timer</a> und <a href="commands/Menu.htm">Menüpunkte</a> enthalten. Dies ist eine übliche Vorgehensweise, um sie in eine separate Datei zu packen und später via <a href="commands/_Include.htm">#Include</a> bereitzustellen, so dass sie den <a href="Scripts.htm#auto">automatischen Ausführungsbereich</a> des Skripts nicht stören können. Allerdings gelten folgende Einschränkungen:</p>
<ul>
  <li>Solche Subroutinen sollten nur <a href="#static">statische</a> und <a href="#Global">globale</a> Variablen verwenden (keine <a href="#Locals">lokalen</a>), wenn ihre Funktionen normal aufgerufen werden, weil ein Subroutinen-<a href="misc/Threads.htm">Thread</a>, der den Thread eines Funktionsaufrufs unterbricht (oder umgekehrt), in der Lage wäre, die Werte von lokalen Variablen zu ändern, wie sie vom unterbrochenen Thread gesehen werden. Jedes Mal, wenn eine Funktion zu ihrem Aufrufer zurückkehrt, werden all ihre lokalen Variablen leer gemacht, um deren Speicher freizugeben.</li>
  <li>Wenn eine Funktion von einem Subroutinen-<a href="misc/Threads.htm">Thread</a> betreten wird, werden alle Verweise auf <a href="misc/Arrays.htm">dynamische Variablen</a>, die von diesem Thread erstellt wurden, als <a href="#Global">globale Variablen</a> behandelt (einschließlich array-erstellende Funktionen). <a href="misc/Labels.htm">Lokale Label</a> hingegen können nicht dynamisch verwiesen werden.</li>
</ul>
<h2 id="remarks">Return, Exit und allgemeine Bemerkungen</h2>
<p>Erreicht der Ausführungsablauf innerhalb einer Funktion die geschweifte Endklammer der Funktion, ohne auf ein <a href="commands/Return.htm">Return</a> gestoßen zu sein, endet die Funktion und gibt ihren Aufrufer eine leere Zeichenkette zurück. Ein leerer Wert wird auch zurückgegeben, wenn der Parameter von <a href="commands/Return.htm">Return</a> explizit fehlt.</p>
<p>Wenn eine Funktion den <a href="misc/Threads.htm">aktuellen Thread</a> mit <a href="commands/Exit.htm">Exit</a> terminiert, erhält ihr Aufrufer überhaupt keinen Rückgabewert. Zum Beispiel: Die Anweisung <code>Var := Addieren(2, 3)</code> würde <code>Var</code> unverändert belassen, wenn <code>Add()</code> per Exit beendet wird. Das gleiche passiert, wenn die Funktion einen Laufzeitfehler verursacht, wie das <a href="commands/Run.htm">Ausführen</a> einer nicht-existierenden Datei (nur wenn <a href="commands/Run.htm#UseErrorLevel">UseErrorLevel</a> nicht aktiv ist).</p>
<p>Eine Funktion kann den Wert von <a href="misc/ErrorLevel.htm">ErrorLevel</a> ändern, um einen zusätzlichen Wert zurückzugeben, der sich leicht merken lässt.</p>
<p>Um eine Funktion mit einer oder mehreren leeren Zeichenketten aufzurufen, verwende zwei Anführungszeichen wie folgt: <code>FindeFarbe(FarbName, "")</code>.</p>
<p>Da das Aufrufen einer Funktion keinen neuen <a href="misc/Threads.htm">Thread</a> startet, werden von der Funktion geänderten Einstellungen wie <a href="commands/SendMode.htm">SendMode</a> oder <a href="commands/SetTitleMatchMode.htm">SetTitleMatchMode</a> auch für den Aufrufer wirksam.</p>
<p>Der Aufrufer einer Funktion kann nicht-existierende Variablen oder <a href="misc/Arrays.htm">Array</a>-Elemente an ihr übergeben, was nützlich für Funktionen ist, die den entsprechenden Parameter als <a href="#ByRef">ByRef</a> erwarten. Ruft man beispielsweise <code>ErmittleNächsteZeile(LeeresArray%i%)</code> auf, wird die Variable <code>LeeresArray%i%</code> automatisch als <a href="#Locals">lokale</a> oder globale Variable erstellt (abhängig davon, ob der Aufrufer sich in einer Funktion befindet und ob der <a href="#AssumeGlobal">global-behandelnder Modus</a> wirksam ist).</p>
<p>Wenn <a href="commands/ListVars.htm">ListVars</a> in einer Funktion verwendet wird, werden ihre <a href="#Locals">lokalen Variablen</a> und deren Inhalte angezeigt. Diese Sache kann dabei helfen, ein Skript zu debuggen.</p>
<h2>Stil und Namenskonventionen</h2>
<p>Man könnte komplexe Funktionen als besser lesbar und verwaltbar empfinden, wenn deren Variablen eindeutige Präfixe angefügt werden. Durch Hinzufügen von beispielsweise "p" oder "p_" am Anfang jeden Parameters ist seine besondere Art besser erkennbar, besonders wenn eine Funktion sehr viele <a href="#Locals">lokale Variablen</a> hat. Ebenso kann das Präfix "r" oder "r_" für <a href="#ByRef">ByRef-Parameter</a> und "s" oder "s_" für <a href="#static">statische Variablen</a> verwendet werden.</p>
<p>Bei Bedarf kann der "<a href="commands/Block.htm#otb">One True Brace Style</a>" verwendet werden, um Funktionen zu definieren. Zum Beispiel:</p>
<pre>Addieren(x, y) <strong>{</strong>
    return x + y
<strong>}</strong></pre>
<h2 id="include">Skripte mittels #Include auf die gleichen Funktionen zugreifen lassen</h2>
<p>Die <a href="commands/_Include.htm">#Include</a>-Direktive kann verwendet werden (<em>auch am Anfang des Skripts</em>), um Funktionen aus einer externen Datei zu laden.</p>
<p>Erklärung: Erreicht der Ausführungsablauf des Skripts eine Funktionsdefinition, wird er sie sofort überspringen und seine Ausführung bei der Zeile nach der geschweiften Endklammer fortsetzen. Daraus folgt, dass die Ausführung nie in eine Funktion geraten kann, oder dass das Vorhandensein von einer oder mehreren Funktionen am Anfang des Skripts den <a href="Scripts.htm#auto">automatischen Ausführungsbereich</a> beeinflussen könnten.</p>
<h2 id="lib">Libraries mit Funktionen: Standard- und Benutzer-Library</h2>
<p>Ein Skript kann eine Funktion aus einer externen Datei aufrufen, ohne dabei <a href="commands/_Include.htm">#Include</a> verwenden zu müssen. Damit dies funktioniert, muss eine Datei, die den gleichen Namen hat wie die Funktion, in einem der folgenden Library-Verzeichnissen vorkommen:</p>
<pre><a href="Variables.htm#ScriptDir">A_ScriptDir</a> "\Lib\"  <em>; Lokale Library.</em>
<a href="Variables.htm#MyDocuments">A_MyDocuments</a> "\AutoHotkey\Lib\"  <em>; Benutzer-Library.</em>
"Pfad-zur-gerade-laufenden-AutoHotkey.exe\Lib\"  <em>; Standard-Library.</em></pre>
<p>Ruft ein Skript beispielsweise die nicht-existierende Funktion <code>MeineFunktion()</code> auf, sucht das Programm nach einer Datei namens "MeineFunktion.ahk" in der Benutzer-Library. Wenn sie dort nicht gefunden werden kann, wird die Standard-Library durchsucht. Ergibt die Suche weiterhin keine Treffer und enthält der Funktionsname einen Unterstrich (z. B. <code>MeinPräfix_MeineFunktion</code>), sucht das Programm in beiden Libraries nach einer Datei namens <code>MeinPräfix.ahk</code> und lädt sie, falls sie existiert. Auf diese Weise kann <code>MeinPräfix.ahk</code> sowohl die Funktion <code>MeinPräfix_MeineFunktion</code> als auch andere verwandte Funktionen enthalten, deren Namen mit <code>MeinPräfix_</code> beginnen.</p>
<p>Zuerst wird die lokale Library durchsucht, danach die Benutzer- und Standard-Library.</p>
<p>Nur ein direkter Funktionsaufruf wie <code>MeineFunk()</code> kann eine Library automatisch einfügen lassen. Wenn die Funktion nur dynamisch oder indirekt aufgerufen wird, z. B. via Timer oder GUI-Ereignis, dann muss die Library explizit in das Skript eingefügt werden. Zum Beispiel: <code><a href="commands/_Include.htm">#Include</a> &lt;MeineFunk&gt;</code></p>
<p>In der Regel enthält eine Library-Datei nur eine einzelne Funktion, die den gleichen Namen hat wie die Datei. Sie kann aber auch private Funktionen und Subroutinen enthalten, die nur von ihr aufgerufen werden. Die Namen solcher Funktionen sollten jedoch gut durchdacht sein, da sie weiterhin im globalen Namensraum zur Verfügung stehen; das heißt, dass sie von überall im Skript aufgerufen werden können.</p>
<p>Verwendet eine Library-Datei <a href="commands/_Include.htm">#Include</a>, gilt als Arbeitsverzeichnis für #Include das Verzeichnis der Library-Datei. Der Vorteil davon ist, dass eine Weiterleitung zu einer größeren Library-Datei erstellt werden kann, die diese Funktion und andere dazugehörige Funktionen enthält.</p>
<p>Der <a href="Scripts.htm#ahk2exe">Skript-Compiler (ahk2exe)</a> unterstützt auch Library-Funktionen. Allerdings ist eine Kopie von AutoHotkey.exe im Verzeichnis oberhalb des Compiler-Verzeichnisses notwendig (was normalerweise der Fall ist). Wenn AutoHotkey.exe dort nicht vorhanden, wird der Compiler zwar weiterhin funktionieren, aber die Library-Funktionen werden nicht mehr automatisch eingefügt.</p>
<p>Funktionen, die auf diese Weise eingefügt werden, haben die gleiche Performance wie andere Funktionen, weil sie geladen werden, bevor das Skript seine Ausführung beginnt.</p>
<h2 id="BuiltIn">Built-in-Funktionen</h2>
<p>Jeder optionale Parameter, der am Ende der Parameterliste einer Built-in-Funktion vorkommt, kann komplett weggelassen werden. Zum Beispiel könnte man <code>WinExist("Unbenannt - Editor")</code> angeben, weil die Funktion ihre anderen drei Parameter als leere Werte ansieht.</p>
<p>Eine Built-in-Funktion wird überschrieben, wenn das Skript seine eigene Funktion mit dem gleichen Namen definieren würde. Zum Beispiel könnte man anstelle der normalen WinExist-Funktion eine selbstdefinierte Funktion verwenden. Allerdings kann danach die originale Funktion nicht mehr aufgerufen werden.</p>
<p>Externe Funktionen, die sich in DLL-Dateien befinden, können per <a href="commands/DllCall.htm">DllCall</a> aufgerufen werden.</p>
<p>Klicke unten auf den Namen einer bestimmten Built-In-Funktion, um mehr über sie zu erfahren.</p>
<h3>Häufig verwendete Funktionen</h3>
<table class="info">
  <tr>
    <th style="width:150px">Funktion</th>
    <th>Beschreibung</th>
  </tr>
  <tr id="DirExist">
    <td><a href="commands/FileExist.htm">DirExist</a></td>
    <td>Überprüft, ob ein Ordner vorhanden ist, und gibt seine Attribute zurück.</td>
  </tr>
  <tr id="FileExist">
    <td><a href="commands/FileExist.htm">FileExist</a></td>
    <td>Überprüft, ob eine Datei oder ein Ordner vorhanden ist, und gibt ihre/seine Attribute zurück.</td>
  </tr>
  <tr id="GetKeyState">
    <td><a href="commands/GetKeyState.htm">GetKeyState</a></td>
    <td>Gibt True (1) zurück, wenn die angegebene Taste unten ist, und False (0), wenn sie oben ist.</td>
  </tr>
  <tr id="InStr">
    <td><a href="commands/InStr.htm">InStr</a></td>
    <td>Sucht eine bestimmte Zeichenkette, beginnend von links oder rechts.</td>
  </tr>
  <tr id="RegExMatch">
    <td><a href="commands/RegExMatch.htm">RegExMatch</a></td>
    <td>Überprüft, ob ein Muster (regulärer Ausdruck) in einer Zeichenkette vorkommt.</td>
  </tr>
  <tr id="RegExReplace">
    <td><a href="commands/RegExReplace.htm">RegExReplace</a></td>
    <td>Ersetzt Vorkommen eines Musters (regulärer Ausdruck) innerhalb einer Zeichenkette.</td>
  </tr>
  <tr id="StrLen">
    <td><a href="commands/StrLen.htm">StrLen</a></td>
    <td>Ermittelt die Anzahl an Zeichen, die sich in einer Zeichenkette befinden.</td>
  </tr>
  <tr id="StrReplace">
    <td><a href="commands/StrReplace.htm">StrReplace</a></td>
    <td>Ersetzt Vorkommen der angegebenen Teilzeichenkette mit einer neuen Zeichenkette.</td>
  </tr>
  <tr id="StrSplit">
    <td><a href="commands/StrSplit.htm">StrSplit</a></td>
    <td>Teilt eine Zeichenkette in mehreren Teilzeichenketten auf, basierend auf die angegebenen Trennzeichen.</td>
  </tr>
  <tr id="SubStr">
    <td><a href="commands/SubStr.htm">SubStr</a></td>
    <td>Ermittelt ein oder mehrere Zeichen von der angegebenen Position innerhalb einer Zeichenkette.</td>
  </tr>
  <tr id="WinActive">
    <td><a href="commands/WinActive.htm">WinActive</a></td>
    <td>Überprüft, ob das angegebene Fenster existiert und zurzeit aktiv (im Vordergrund) ist, und gibt dessen Eindeutige ID (HWND) zurück.</td>
  </tr>
  <tr id="WinExist">
    <td><a href="commands/WinExist.htm">WinExist</a></td>
    <td>Überprüft, ob ein passendes Fenster existiert, und gibt die Eindeutige ID (HWND) des ersten passenden Fensters zurück.</td>
  </tr>
</table>
<h3>Verschiedene Funktionen</h3>
<table class="info">
  <tr>
    <th style="width:150px">Funktion</th>
    <th>Beschreibung</th>
  </tr>
  <tr id="Chr">
    <td><a href="commands/Chr.htm">Chr</a></td>
    <td>Gibt eine Zeichenkette zurück (üblicherweise ein einzelnes Zeichen), deren Zeichencode mit der angegebenen Nummer übereinstimmt.</td>
  </tr>
  <tr id="DllCall">
    <td><a href="commands/DllCall.htm">DllCall</a></td>
    <td>Ruft eine Funktion innerhalb einer DLL-Datei auf, wie z. B. eine API-Funktion von Windows.</td>
  </tr>
  <tr id="FileOpen">
    <td><a href="commands/FileOpen.htm">FileOpen</a></td>
    <td>Ermöglicht eine objektorientierte Dateibearbeitung.</td>
  </tr>
  <tr id="Func">
    <td><a href="commands/Func.htm">Func</a></td>
    <td>Ermittelt einen Verweis auf die angegebene Funktion.</td>
  </tr>
  <tr id="GetKeyName">
    <td><a href="commands/GetKey.htm">GetKeyName/VK/SC</a></td>
    <td>Ermittelt den Namen/Text, virtuellen Tastencode oder Scancode einer Taste.</td>
  </tr>
  <tr id="IsByRef">
    <td><a href="commands/IsByRef.htm">IsByRef</a></td>
    <td>Gibt eine Nummer ungleich 0 zurück, wenn ein ByRef-Parameter einer Funktion mit einer Variable übergeben wurde.</td>
  </tr>
  <tr id="IsFunc">
    <td><a href="commands/IsFunc.htm">IsFunc</a></td>
    <td>Gibt eine Nummer ungleich 0 zurück, wenn die angegebene Funktion im Skript vorkommt.</td>
  </tr>
  <tr id="IsLabel">
    <td><a href="commands/IsLabel.htm">IsLabel</a></td>
    <td>Gibt eine Nummer ungleich 0 zurück, wenn das angegebene Label im Skript vorkommt.</td>
  </tr>
  <tr id="IsObject">
    <td><a href="commands/IsObject.htm">IsObject</a></td>
    <td>Gibt eine Nummer ungleich 0 zurück, wenn der angegebene Wert ein Objekt ist.</td>
  </tr>
  <tr id="ListView">
    <td><a href="commands/ListView.htm#BuiltIn">ListView</a></td>
    <td>Funktion zum Hinzufügen, Einfügen, Modifizieren oder Löschen von ListView-Reihen/Spalten, oder zum Abrufen ihrer Daten.</td>
  </tr>
  <tr id="NumGet">
    <td><a href="commands/NumGet.htm">NumGet</a></td>
    <td>Gibt eine binäre Nummer zurück, die auf der angegebenen Adresse + Offset zu finden ist.</td>
  </tr>
  <tr id="NumPut">
    <td><a href="commands/NumPut.htm">NumPut</a></td>
    <td>Speichert eine binäre Nummer auf die angegebene Adresse + Offset.</td>
  </tr>
  <tr id="OnMessage">
    <td><a href="commands/OnMessage.htm">OnMessage</a></td>
    <td>Überwacht eine Meldung/ein Ereignis.</td>
  </tr>
  <tr id="Ord">
    <td><a href="commands/Ord.htm">Ord</a></td>
    <td>Gibt den Ordinalwert (numerischen Zeichencode) des ersten Zeichens in der angegebenen Zeichenkette zurück.</td>
  </tr>
  <tr id="StrPutGet">
    <td><a href="commands/StrPutGet.htm">StrGet</a></td>
    <td>Kopiert eine Zeichenkette aus einer Speicheradresse unter Beachtung des angegebenen Zeichensatzes.</td>
  </tr>
  <tr id="StrPutGet">
    <td><a href="commands/StrPutGet.htm">StrPut</a></td>
    <td>Kopiert eine Zeichenkette auf eine Speicheradresse unter Beachtung des angegebenen Zeichensatzes.</td>
  </tr>
  <tr id="RegisterCallback">
    <td><a href="commands/RegisterCallback.htm">RegisterCallback</a></td>
    <td>Erstellt eine Maschinencode-Adresse, die, wenn sie aufgerufen wird, den Aufruf an eine Funktion im Skript weiterleitet.</td>
  </tr>
  <tr id="TreeView">
    <td><a href="commands/TreeView.htm#BuiltIn">TreeView</a></td>
    <td>Funktionen zum Hinzufügen, Modifizieren oder Löschen von TreeView-Elementen, oder zum Abrufen ihrer Daten.</td>
  </tr>
  <tr id="Trim">
    <td><a href="commands/Trim.htm">Trim</a></td>
    <td>Entfernt Zeichen vom Anfang und/oder Ende einer Zeichenkette.</td>
  </tr>
  <tr id="VarSetCapacity">
    <td><a href="commands/VarSetCapacity.htm">VarSetCapacity</a></td>
    <td>Vergrößert die Aufnahmekapazität einer Variable oder gibt deren Speicher frei.</td>
  </tr>
</table>
<h3 id="Math">Mathematik</h3>
<table class="info">
  <tr>
    <th style="width:150px">Funktion</th>
    <th>Beschreibung</th>
  </tr>
  <tr id="Abs">
    <td><a href="commands/Math.htm#Abs">Abs</a></td>
    <td>Gibt den absoluten Wert von <em>Zahl</em> zurück.</td>
  </tr>
  <tr id="Ceil">
    <td><a href="commands/Math.htm#Ceil">Ceil</a></td>
    <td>Gibt <em>Zahl</em> zurück, welche auf den nächsten Integer aufgerundet ist (ohne .00-Suffix).</td>
  </tr>
  <tr id="Exp">
    <td><a href="commands/Math.htm#Exp">Exp</a></td>
    <td>Gibt <em>e</em> zurück (ungefähr 2.71828182845905), potenziert mit <em>N</em>.</td>
  </tr>
  <tr id="Floor">
    <td><a href="commands/Math.htm#Floor">Floor</a></td>
    <td>Gibt <em>Zahl</em> zurück, welche auf den nächsten Integer abgerundet ist (ohne .00-Suffix).</td>
  </tr>
  <tr id="Log">
    <td><a href="commands/Math.htm#Log">Log</a></td>
    <td>Gibt den Logarithmus (Basis 10) von <em>Zahl</em> zurück.</td>
  </tr>
  <tr id="Ln">
    <td><a href="commands/Math.htm#Ln">Ln</a></td>
    <td>Ermittelt den Logarithmus (Basis e) von <em>Zahl</em>.</td>
  </tr>
  <tr id="Mod">
    <td><a href="commands/Math.htm#Mod">Mod</a></td>
    <td>Gibt den Rest zurück, wenn <em>Dividend</em> durch <em>Divisor</em> geteilt wird.</td>
  </tr>
  <tr id="Round">
    <td><a href="commands/Math.htm#Round">Round</a></td>
    <td>Gibt <em>Zahl</em> zurück, welche auf <em>N</em> Dezimalstellen gerundet ist.</td>
  </tr>
  <tr id="Sqrt">
    <td><a href="commands/Math.htm#Sqrt">Sqrt</a></td>
    <td>Gibt die Quadratwurzel von <em>Zahl</em> zurück.</td>
  </tr>
  <tr>
    <td><span id="Sin"></span><span id="Cos"></span><span id="Tan"></span><a href="commands/Math.htm#Sin">Sin</a> / <a href="commands/Math.htm#Cos">Cos</a> / <a href="commands/Math.htm#Tan">Tan</a></td>
    <td>Gibt den trigonometrischen Sinus/Kosinus/Tangens von <em>Zahl</em> zurück.</td>
  </tr>
  <tr>
    <td><span id="ASin"></span><span id="ACos"></span><span id="ATan"></span><a href="commands/Math.htm#ASin">ASin</a> / <a href="commands/Math.htm#ACos">ACos</a> / <a href="commands/Math.htm#ATan">ATan</a></td>
    <td>Gibt den Arkussinus/Arkuskosinus/Arkustangens als Bogenmaß zurück.</td>
  </tr>
</table>
</body>
</html>
