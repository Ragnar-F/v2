<!DOCTYPE HTML>
<html lang="de">
<head>
<title>Funktionen - Definition &amp; Verwendung | AutoHotkey v2</title>
<meta name="description" content="Erfahren Sie mehr über Funktionen im Allgemeinen, Parameter, Rückgabewerte, interne Funktionen, variadische Funktionen, etc." />
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="robots" content="noindex, nofollow">
<link href="static/theme.css" rel="stylesheet" type="text/css" />
<script src="static/content.js" type="text/javascript"></script>
<script src="static/ga.js" type="text/javascript"></script>
</head>

<body>
<h1>Funktionen</h1>

<h2>Inhaltsverzeichnis</h2>
<ul>
  <li><a href="#intro">Einführung und einfache Beispiele</a></li>
  <li><a href="#param">Parameter</a></li>
  <li><a href="#optional">Optionale Parameter</a></li>
  <li><a href="#return">Werte an den Aufrufer zurückgeben</a></li>
  <li><a href="#Variadic">Variadische Funktionen</a></li>
  <li><a href="#Local">Lokale Variablen</a></li>
  <li><a href="#DynCall">Dynamisches Aufrufen einer Funktion</a></li>
  <li><a href="#ShortCircuit">Boolesche Kurzschlussauswertung</a></li>
  <li><a href="#nested">Verschachtelte Funktionen</a></li>
  <li><a href="#remarks">Return, Exit und allgemeine Bemerkungen</a></li>
  <li><a href="#include">Skripte mittels #Include auf die gleichen Funktionen zugreifen lassen</a></li>
  <li><a href="#lib">Funktionsbibliotheken: Standard- und Benutzerbibliothek</a></li>
  <li><a href="#BuiltIn">Interne Funktionen</a></li>
</ul>
<h2 id="intro">Einführung und einfache Beispiele</h2>
<p id="define">Eine Funktion ist so etwas Ähnliches wie eine Subroutine, allerdings mit dem Unterschied, dass eine Funktion zusätzlich mit Parametern (Eingabewerten) aufgerufen werden kann. Eine Funktion kann außerdem einen Wert direkt an ihren Aufrufer zurückgeben. Das folgende Beispiel ist eine einfache Funktion, die zwei Zahlen akzeptiert und ihre Summe zurückgibt:</p>
<pre>Addieren(x, y)
{
    <a href="commands/Return.htm">return</a> x + y
}</pre>
<p>So etwas nennt man auch eine <em>Funktionsdefinition</em>, weil es eine Funktion mit dem Namen "Addieren" erstellt (nicht Groß-/Kleinschreibung-sensitiv) und festlegt, dass jeder, der sie aufruft, genau zwei Parameter (x und y) bereitstellen muss. Um die Funktion aufzurufen, können Sie das Ergebnis der Funktion einer Variable mithilfe des <a href="commands/SetExpression.htm">Doppelpunkt-Gleich-Operators</a> (<strong><a href="commands/SetExpression.htm">:=</a></strong>) zuweisen. Zum Beispiel:</p>
<pre>Var := Addieren(2, 3)  <em>; Speichert die Zahl 5 in Var.</em></pre>
<p>Man kann eine Funktion auch aufrufen, ohne ihren Rückgabewert speichern zu müssen:</p>
<pre>Addieren(2, 3)
Addieren 2, 3  <em>; Runde Klammern können am Anfang einer Zeile weggelassen werden.</em></pre>
<p>In diesem Fall aber wird der zurückgegebene Wert der Funktion verworfen; diese Art von Aufruf ist nur sinnvoll, wenn die Funktion mehr als nur einen Rückgabewert zurückgibt.</p>
<p>Innerhalb eines Ausdrucks wird ein Funktionsaufruf ausgewertet und mit dem Rückgabewert der Funktion "ersetzt". Der Rückgabewert kann wie oben gezeigt in eine Variable gespeichert werden oder wie folgt direkt benutzt werden:</p>
<pre>if <a href="commands/InStr.htm">InStr</a>(MeineVar, "Fuchs")
    MsgBox "Die Variable MeineVar enthält das Wort Fuchs."</pre>

<h2 id="param">Parameter</h2>
<p>Die Parameter einer Funktion werden in die runden Klammern rechts neben dem Funktionsnamen eingefügt (zwischen dem Namen und der runden Startklammer sind keine Leerzeichen erlaubt). Wenn die Funktion keine Parameter akzeptiert, können die runden Klammern leer gelassen werden; zum Beispiel: <code>ErmittleAktuellenZeitstempel()</code>.</p>
<p id="ByRef"><strong>ByRef-Parameter</strong>: Innerhalb der Funktion werden Parameter grundsätzlich wie <a href="#Local">lokale Variablen</a> behandelt, es sei denn, sie werden wie im folgenden Beispiel als <em>ByRef</em>-Parameter definiert:</p>
<pre>Tauschen(ByRef Links, ByRef Rechts)
{
    temp := Links
    Links := Rechts
    Rechts := temp
}</pre>
<p>Das <em>ByRef</em> oben macht den Parameter zu einem Pseudonym für die Variable, die der Aufrufer übergeben hat. Das heißt, dass der Parameter und die Variable des Aufrufers auf den gleichen Inhalt im Speicher verweisen. Auf diese Weise kann die Tauschen-Funktion die Variablen des Aufrufers ändern, indem sie den Inhalt der <em>Links</em>-Variable in die <em>Rechts</em>-Variable verschiebt, und umgekehrt.</p>
<p>Würde man <em>ByRef</em> hingegen nicht verwenden, wären <em>Links</em> und <em>Rechts</em> nur Kopien der Variablen des Aufrufers - die Tauschen-Funktion hätte keine externe Auswirkung.</p>
<p><em>ByRef</em> kann als Ergänzung zu <a href="commands/Return.htm">Return</a> verwendet werden, um mehr als einen Wert zurückzugeben. Um das zu erreichen, definieren Sie eine Funktion mit ByRef-Parametern, damit der Aufrufer Variablen übergeben kann (üblicherweise leer), in der die Funktion einen Wert speichern kann.</p>
<p>Die Übergabe langer Zeichenketten an eine Funktion via <em>ByRef</em> ist leistungsfähiger und verhindert, dass die Zeichenketten doppelten Speicherplatz verbrauchen, weil von ihnen eine Kopie erstellt werden muss. Auch die Rückgabe von langen Zeichenketten an den Aufrufer via <em>ByRef</em> ist in der Regel performanter als so etwas wie <code>Return LangeZeichenkette</code>. Was die Funktion erhält, ist jedoch nicht eine Referenz zur Zeichenkette, sondern eine Referenz zur <em>Variable</em>. Zukünftige Verbesserungen könnten die Verwendung von ByRef für diese Zwecke überflüssig machen.</p>
<p>Übergibt man eine schreibgeschützte Variable an einen ByRef-Parameter, verhält sich die Funktion so, als wäre das Schlüsselwort "ByRef" nicht vorhanden. <code>Tauschen(A_Index, i)</code> beispielsweise speichert den Wert von <i>A_Index</i> in <i>i</i>, allerdings wird der Wert von <i>Links</i> wieder verworfen, wenn die <i>Tauschen</i>-Funktion fertig ist.</p>
<p>Mit der <a href="commands/IsByRef.htm">IsByRef</a>-Funktion kann festgestellt werden, ob der Aufrufer eine Variable für einen bestimmten ByRef-Parameter bereitgestellt hat.</p>
<p>Bekannte Einschränkungen:</p>
<ul>
  <li>Es ist nicht möglich, Objekteigenschaften (z. B. <code>foo.bar</code>), <a href="misc/A_Clipboard.htm">A_Clipboard</a> oder andere <a href="Variables.htm#BuiltIn">interne Variablen</a> an eine Funktion via Referenz zu übergeben. Stattdessen wird sich die Funktion so verhalten, als hätte man <em>ByRef</em> weggelassen.</li>
  <li>Variablen, die innerhalb eines Funktionsparameters aufgelöst werden müssen (z. B. <code>Var</code> oder <code>++Var</code> oder <code>Var *= 2</code>), können von links oder rechts befindlichen Parametern geändert werden, bevor sie an die Funktion übergeben werden. <code>MeineFunk(Var, Var++)</code> würde beispielsweise unerwartet 0 und 1 als Parameter übergeben, wenn <em>Var</em> zu Beginn 0 ist, auch dann, wenn der erste Parameter der Funktion kein <em>ByRef</em> ist. Dieses unlogische Verhalten wird eventuell in einer zukünftigen Version geändert.</li>
  <li>ByRef wird nicht direkt beim Aufrufen einer COM-Methode unterstützt. Stattdessen muss das Skript ein <a href="commands/ComObject.htm#ByRef">Wrapper-Objekt</a> übergeben, das den <a href="commands/ComObjType.htm">VarTyp</a> und die Adresse des Wertes enthält.</li>
</ul>
<h2 id="optional">Optionale Parameter</h2>
<p>Bei der Definition einer Funktion können ein oder mehrere Parameter als optional gekennzeichnet werden. Um das zu tun, müssen Sie <code>:=</code> anfügen, gefolgt vom Standardwert des Parameters, der Folgendes sein kann: <code>true</code>, <code>false</code>, <code>unset</code>, ein direkt geschriebener Integer, eine direkt geschriebene Floating-Point-Zahl oder eine direkt geschriebene, in Anführungszeichen gesetzte Zeichenkette wie "fox" oder "".</p>
<p>Die folgende Funktion hat einen Z-Parameter, der als optional gekennzeichnet ist:</p>
<pre>Addieren(X, Y, Z := 0) {
    return X + Y + Z
}</pre>
<p>Ruft man die Funktion mit <strong>drei</strong> Parametern auf, wird der Standardwert von Z ignoriert. Ruft man aber die Funktion nur mit <strong>zwei</strong> Parametern auf, wird der Z-Variable automatisch eine 0 zugewiesen.</p>
<p id="missing">Es ist nicht möglich, optionale Parameter in der Mitte der Parameterliste zu platzieren. Alle Parameter auf der rechten Seite des ersten optionalen Parameters müssen in diesem Fall auch optional sein. Allerdings könne optionale Parameter in der Mitte der Parameterliste weggelassen werden, wenn die Funktion aufgerufen wird. Zum Beispiel:</p>
<pre>MeineFunk(1,, 3)
MeineFunk(X, Y:=2, Z:=0) {  <em>; Beachten Sie, dass Z in diesem Fall weiterhin optional sein muss.</em>
    MsgBox X ", " Y ", " Z
}</pre>
<p id="OptionalByRef"><a href="#ByRef">ByRef-Parameter</a> können auch optional sein; zum Beispiel: <code>MeineFunk(ByRef p1 := "")</code>. Jedes Mal, wenn die Funktion ohne diesen Parameter aufgerufen wird, wird eine lokale Variable mit dem angegebenen Standardwert erstellt; das heißt, dass die Funktion sich so verhalten wird, als wäre das Schlüsselwort "ByRef" nicht vorhanden.</p>
<p id="unset"><strong>Unset:</strong> Um genau festzustellen, ob der Aufrufer einen Parameter weggelassen hat, geben Sie <code>unset</code> als Standardwert an und ermitteln Sie mit <a href="commands/IsSet.htm">IsSet</a>, ob der Parameter einen Wert erhalten hat, wie unten gezeigt:</p>
<pre>
MeineFunk(p := unset) {
    if IsSet(p)
        MsgBox "Aufrufer hat " p " übergeben"
    else
        MsgBox "Aufrufer hat nichts übergeben"
}

MeineFunk(42)
MeineFunk
</pre>

<h2 id="return">Werte an den Aufrufer zurückgeben</h2>
<p>Wie in der <a href="#intro">Einführung</a> bereits erwähnt, kann eine Funktion einen Wert via <a href="commands/Return.htm">Return</a> an ihren Aufrufer zurückgeben.</p>
<pre>
MsgBox returnTest()

returnTest() {
    return 123
}
</pre>
<p>Wenn Sie noch mehr Ergebnisse aus einer Funktion zurückgeben möchten, können Sie auch <a href="#ByRef">ByRef</a> nutzen:</p>
<pre>
returnByRef(A,B,C)
MsgBox A "," B "," C

returnByRef(ByRef val1, ByRef val2, ByRef val3)
{
    val1 := "A"
    val2 := 100
    val3 := 1.1
    return
}
</pre>
<p>Mithilfe von Objekten und Arrays können mehrere Werte oder sogar benannte Werte zurückgegeben werden:</p>
<pre>
Test1 := returnArray1()
MsgBox Test1[1] "," Test1[2]

Test2 := returnArray2()
MsgBox Test2[1] "," Test2[2]

Test3 := returnObject()
MsgBox Test3.id "," Test3.val

returnArray1() {
    Test := [123,"ABC"]
    return Test
}

returnArray2() {
    x := 456
    y := "EFG"
    return [x, y]
}

returnObject() {
    Test := {id: 789, val: "HIJ"}
    return Test
}
</pre>
<h2 id="Variadic">Variadische Funktionen</h2>
<p>Es ist möglich, den letzten Parameter in einer Funktionsdefinition mit einem Sternchen zu versehen, um eine Funktion variadisch zu machen, oder anders gesagt, um sie eine variable Anzahl von Parametern akzeptieren zu lassen:</p>
<pre>Verbinden(sep, <b class="blue">params*</b>) {
    for index,param in params
        str .= param . sep
    return SubStr(str, 1, -StrLen(sep))
}
MsgBox Verbinden("`n", "eins", "zwei", "drei")</pre>
<p>Wenn man eine variadische Funktion aufruft, werden alle überschüssigen Parameter in ein Objekt gespeichert, das im letzten Parameter der Funktion enthalten ist. Der erste überschüssige Parameter ist <code>params[1]</code>, der Zweite ist <code>params[2]</code> und so weiter. Da es sich hierbei um ein <a href="objects/Array.htm">Array</a> handelt, kann <code>params.<a href="objects/Array.htm#Length">Length</a></code> genutzt werden, um die Parameteranzahl zu ermitteln.</p>
<p>Der Versuch, eine nicht-variadische Funktion mit mehr Parametern als möglich aufzurufen, wird als Fehler erkannt. Schreiben Sie <code>*</code> als letzten Parameter (ohne Parametername), um eine Funktion beliebig viele Parameter akzeptieren zu lassen, <em>ohne</em> ein Array zum Speichern der überschüssigen Parameter zu erstellen.</p>
<p class="warning"><strong>Hinweis:</strong> Der "variadische" Parameter kann nur am Ende der formalen Parameterliste erfolgen.</p>

<h3 id="VariadicCall">Variadische Funktionsaufrufe</h3>
<p>Variadische Funktionen können mithilfe eines Arrays eine variable Anzahl von Parametern <i>akzeptieren</i>, während variadische Funktionsaufrufe verwendet werden können, um eine variable Anzahl von Parametern an eine <i>beliebige</i> Funktion mithilfe derselben Syntax zu übergeben:</p>
<pre>TeilZketten := ["eins", "zwei", "drei"]
MsgBox Verbinden("`n", <b class="blue">TeilZketten*</b>)</pre>
<p>Hinweise:</p>
<ul>
  <li>Das Objekt kann ein <a href="objects/Array.htm">Array</a> oder eine andere Art von enumerierbares Objekt (also ein Objekt mit einer <a href="Objects.htm#__Enum">__Enum</a>-Methode) oder <a href="objects/Enumerator.htm">Enumerator</a> sein. Wenn das Objekt kein Array ist, wird __Enum mit einem Zähler von 1 und der Enumerator mit nur jeweils einem Parameter aufgerufen.</li>
  <li><a href="objects/Array.htm">Array</a>-Elemente ohne Wert (wie z. B. das erste Element in <code>[,2]</code>) sind das gleiche wie, als würde man den Parameter weglassen; das heißt, dass der Standardwert des Parameters verwendet wird, wenn er optional ist, ansonsten wird eine Ausnahme ausgelöst.</li>
  <li>Wenn eine benutzerdefinierte Funktion direkt aufgerufen wird, kann das Objekt Parameterwerte über Eigenschaften übergeben, die den gleichen Namen wie die Parameter der Funktion haben. Obwohl das Objekt, wie oben erwähnt, enumerierbar sein muss, kann der Enumerator (der das Objekt selbst sein kann) null Elemente zurückgeben. Positionsparameter haben Vorrang vor Eigenschaften, und unbenutzte Eigenschaften werden ignoriert. Benannte Parameter werden beim Aufruf von Methoden oder internen Funktionen nicht unterstützt.</li>
  <li>Diese Syntax kann auch beim Aufrufen von Methoden oder beim Setzen oder Abrufen von Objekteigenschaften verwendet werden; zum Beispiel <code>Objekt.Eigenschaft[Params*]</code>.</li>
</ul>
<p>Bekannte Einschränkungen:</p>
<ul>
  <li>Nur der am weitesten rechts befindliche Parameter kann auf diese Weise erweitert werden. Zum Beispiel wird <code>MeineFunk(x, y*)</code> unterstützt, aber nicht <code>MeineFunk(x*, y)</code>.</li>
  <li>Zwischen dem Sternchen (<code>*</code>) und dem Symbol, das die Parameterliste beendet, dürfen keine Leerraumzeichen stehen.</li>
</ul>
<h2 id="Locals">Lokale und globale Variablen</h2>
<h3 id="Local">Lokale Variablen</h3>
<p>Lokale Variablen sind funktionsspezifisch und nur innerhalb dieser Funktion sichtbar. Folglich kann eine lokale Variable, die denselben Namen hat wie eine globale Variable, etwas anderes als die globale Variable enthalten. Verschiedene Funktionen können bedenkenlos die gleichen Variablennamen benutzen.</p>
<p>Alle lokalen Variablen, die nicht <a href="#static">statisch</a> sind, werden automatisch freigegeben (leer gemacht), wenn die Funktion ihr Ende erreicht hat, mit Ausnahme von Variablen, die an ein <a href="#closures">Closure</a> gebunden sind.</p>
<p>Interne Variablen wie <a href="misc/A_Clipboard.htm">A_Clipboard</a> und <a href="Variables.htm#TimeIdle">A_TimeIdle</a> sind nie lokal (sie sind von überall aus erreichbar) und können nicht neu deklariert werden. (Dies gilt nicht für interne Klassen wie <a href="objects/Object.htm">Object</a>; sie sind als <a href="#SuperGlobal">superglobale</a> Variablen definiert.)</p>
<p id="AssumeLocal">Funktionen sind standardmäßig im <strong>Assume-Local</strong>-Modus. Variablen, die innerhalb einer Assume-Local-Funktion zugegriffen oder erstellt werden, sind standardmäßig lokal, aber es gibt folgende Ausnahmen:</p>
<ul>
  <li><a href="#SuperGlobal">Superglobale</a> Variablen, inklusive <a href="Objects.htm#Custom_Classes">Klassen</a>.</li>
  <li>Innerhalb einer <a href="#nested">verschachtelten Funktion</a> kann man auf nicht-dynamische lokale und statische Variablen zugreifen, die von einer äußeren Funktion erzeugt wurden.</li>
</ul>
<p>Siehe unten, wie das Standardverhalten überschrieben werden kann (indem man die Variable deklariert oder den Modus der Funktion ändert).</p>
<p id="ForceLocal"><strong>Force-Local-Modus</strong>: Wenn die erste Zeile der Funktion das Wort "local" ist, werden alle Variablenreferenzen als lokal angesehen, es sei denn, sie werden <em>innerhalb</em> der Funktion als global deklariert. Im Gegensatz zum Standardmodus verhält sich der Force-Local-Modus wie folgt:</p>
<ul>
  <li>Superglobale Variablen (einschließlich Klassen) sind nur zugänglich, wenn sie innerhalb der Funktion deklariert werden.</li>
  <li>Wenn die Funktion innerhalb einer anderen Funktion definiert ist, kann man nicht auf die lokalen und statischen Variablen der äußeren Funktion zugreifen.</li>
  <li>Innerhalb einer Force-Local-Funktion kann nie die <em>LocalSameAsGlobal</em>-<a href="commands/_Warn.htm">Warnung</a> für Variablen ausgelöst wird.</li>
</ul>

<h3 id="Global">Globale Variablen</h3>
<p>Um innerhalb einer Funktion auf eine vorhandene globale Variable zu verweisen (oder eine neue zu erstellen), deklarieren Sie die Variable als globale Variable, bevor Sie sie verwenden. Zum Beispiel:</p>
<pre>InDateiLoggen(ZuLoggenderText)
{
    <strong>global</strong> LogDateiName  <em>; Dieser globalen Variable wurde bereits ein Wert außerhalb dieser Funktion zugewiesen.</em>
    FileAppend ZuLoggenderText "`n", LogDateiName
}</pre>
<p id="AssumeGlobal"><strong>Assume-Global-Modus</strong>: Muss eine Funktion viele globale Variablen erstellen oder auf sie zugreifen, kann die Funktion so definiert werden, dass sie all ihre Variablen (außer ihre Parameter) global behandelt. Dazu muss in der ersten Zeile das Wort "global" stehen. Zum Beispiel:</p>
<pre>StandardwerteSetzen()
{
    <strong>global</strong>
    GlobaleVar := 33  <em>; Speichert 33 in eine globale Variable und erstellt sie, falls notwendig.</em>
    local x, y:=0, z  <em>; Lokale Variablen müssen in diesem Modus deklariert werden, weil sie sonst global behandelt werden.</em>
}</pre>
<p>Dieser Assume-Global-Modus kann auch von einer Funktion verwendet werden, um ein globales <a href="misc/Arrays.htm">Pseudo-Array</a> zu erstellen - z. B. eine Schleife, die Werte in <code>Array%A_Index%</code> speichert.</p>
<p id="SuperGlobal"><strong>Superglobale Variablen</strong>: Geschieht eine globale Deklaration außerhalb einer Funktion, gilt sie standardmäßig für alle Funktionen (außer <a href="#ForceLocal">Force-Local</a>-Funktionen). Dadurch wird verhindert, dass die Variablen in jeder Funktion neu deklariert werden müssen. Allerdings haben Funktionsparameter oder lokale Variablen, die denselben Namen haben wie globale Variablen, Vorrang vor globale Variablen. Variablen, die mit dem Schlüsselwort <a href="Objects.htm#Custom_Classes">class</a> erzeugt wurden, sind auch superglobal.</p>
<h3 id="static">Statische Variablen</h3>
<p>Obwohl statische Variablen immer indirekt lokal sind, unterscheiden sie sich von lokalen Variablen, weil ihre Werte zwischen den Funktionsaufrufen erhalten bleiben. Zum Beispiel:</p>
<pre>InDateiLoggen(ZuLoggenderText)
{
    <strong>static</strong> GeloggteZeilen := 0
    GeloggteZeilen += 1  <em>; Behandelt einen Zähler lokal (der Wert bleibt zwischen den Funktionsaufrufen erhalten).</em>
    global LogDateiName
    FileAppend GeloggteZeilen ": " ZuLoggenderText "`n", LogDateiName
}</pre>
<p id="InitStatic">Es ist möglich, eine statische Variable bei ihrer Deklaration zu initialisieren. Fügen Sie einfach auf der rechten Seite des Variablennamens den Operator <code>:=</code> und einen beliebigen <a href="Variables.htm#Expressions">Ausdruck</a> an. Zum Beispiel: <code>static X:=0, Y:="fox"</code>. Statische Deklarationen werden genauso ausgewertet wie <a href="#Local">lokale</a> Deklarationen, außer dass nach erfolgreicher Auswertung einer statischen Initialisierung (oder einer Gruppe von verbundenen Initialisierungen) diese effektiv aus der Ablaufsteuerung entfernt und kein zweites Mal ausgeführt wird.</p>
<p id="AssumeStatic"><strong>Assume-Static-Modus</strong>: Eine Funktion kann so definiert werden, dass sie all ihre Variablen (außer ihre Parameter) statisch behandelt. Dazu muss in der ersten Zeile das Wort "static" stehen. Zum Beispiel:</p>
<pre>VomStatischenArrayAbrufen(ElementNummer)
{
    <strong>static</strong>
    static ErsterAufruf := true  <em>; Jede Initialisierung einer statischen Deklaration wird nur einmal ausgeführt.</em>
    if ErsterAufruf  <em>; Erstellt ein statisches Array beim ersten Aufruf, aber nicht mehr danach.</em>
    {
        ErsterAufruf := false
        Loop 10
            StatischesArray%A_Index% := "Wert #" . A_Index
    }
    return StatischesArray%ElementNummer%
}</pre>
<p>Im Assume-Static-Modus muss jede Variable, die nicht statisch sein soll, als lokal oder global deklariert werden (mit den gleichen Ausnahmen wie beim <a href="#AssumeLocal">Assume-Local-Modus</a>, sofern der <a href="#ForceLocal">Force-Local-Modus</a> nicht auch noch aktiv ist).</p>
<p>Der <a href="#ForceLocal">Force-Local-Modus</a> kann mit dem Assume-Static-Modus kombiniert werden, indem man <code>local</code> und dann <code>static</code> angibt, wie unten gezeigt. Dies ermöglicht es der Funktion, Force-Local-Regeln zu verwenden, aber standardmäßig Variablen als statische Variablen zu erstellen.</p>
<pre>global MeineVar := "Das ist global"
ForceStaticDemonstrieren()

ForceStaticDemonstrieren()
{
    local
    static
    MeineVar := "Dies ist statisch"
    ListVars
    MsgBox
}
</pre>
<h3>Mehr über lokale und globale Variablen</h3>
<p>Mehrere Variablen können mithilfe eines Kommas auf derselben Zeile deklariert werden. Zum Beispiel:</p>
<pre>global LogDateiName, MaxVersuche := 5
static GesamtVersuche := 0, VorherErgebnis</pre>
<p id="DeclareInit">Es ist möglich, eine Variable bei ihrer Deklaration auf derselben Zeile zu initialisieren. Fügen Sie einfach auf der rechten Seite des Variablennamens eine Zuweisung an. Im Gegensatz zu <a href="#InitStatic">statischen Initialisierungen</a> werden die Initialisierungen von lokalen oder globalen Variablen jedes Mal ausgeführt, wenn die Funktion aufgerufen wird. Eine Zeile wie <code>local x := 0</code> hätte also den gleichen Effekt wie, als würde man zwei einzelne Zeilen schreiben: <code>local x</code>, gefolgt von <code>x := 0</code>. Jeder <a href="Variables.htm#AssignOp">Zuweisungsoperator</a> kann verwendet werden, allerdings erfordert eine Verbundzuweisung wie <code>global Trefferanzahl += 1</code>, dass der Variable zuvor ein Wert zugewiesen wurde.</p>
<p>Da die Wörter <em>local</em>, <em>global</em> und <em>static</em> unmittelbar beim Starten des Skripts verarbeitet werden, kann eine Variable nicht mithilfe einer <a href="commands/If.htm">IF-Anweisung</a> deklariert werden. Das heißt, dass eine Deklaration innerhalb eines IF- oder ELSE-<a href="commands/Block.htm">Blocks</a> bedingungslos für die gesamte Funktion wirksam wird (aber alle in der Deklaration enthaltenen Initialisierungen sind immer noch bedingt). Eine dynamische Deklaration wie <code>global Array%i%</code> ist nicht möglich, da alle nicht-dynamischen Referenzen zu Variablen wie <code>Array1</code> oder <code>Array99</code> bereits in Adressen aufgelöst worden wären.</p>

<h2 id="DynCall">Dynamisches Aufrufen einer Funktion</h2>
<p>Eine Funktion (auch eine <a href="#BuiltIn">interne Funktion</a>) kann dynamisch via Prozentzeichen aufgerufen werden. <code>%Var%(x, "Fuchs")</code> beispielsweise wird aufgerufen, wenn <em>Var</em> den Namen oder die <a href="Objects.htm#Function_References">Referenz</a> einer gültigen Funktion enthält. <code>Funk%A_Index%()</code> kann hingegen Funk1(), Funk2() und so weiter aufrufen, je nachdem, welcher Wert in A_Index aktuell enthalten ist.</p>
<p><em>Var</em> in <code>%Var%()</code> kann einen Funktionsnamen oder ein <a href="objects/Functor.htm">Funktionsobjekt</a> enthalten. Enthält <em>Var</em> einen <a href="Objects.htm#primitive">primitiven Wert</a>, der kein gültiger Funktionsname ist, wird der Wert selbst aufgerufen. Normalerweise hat der Wert keine Call-Methode, deshalb wird eine Ausnahme ausgelöst.</p>
<p>Wenn die Funktion aus einem der folgenden Gründe nicht aufgerufen werden kann, wird eine <a href="commands/Catch.htm#RuntimeErrors">Ausnahme</a> ausgelöst:</p>
<ul>
  <li>Es wurde eine nicht-existierende Funktion aufgerufen. Dies kann oft verhindert werden, indem man <code>if <a href="commands/IsFunc.htm">IsFunc</a>(VarMitFunkName)</code> verwendet. Die <a href="#define">Definition</a> der aufgerufenen Funktion (außer <a href="#BuiltIn">interne Funktionen</a>) muss explizit im Skript angegeben sein (zum Beispiel über <a href="commands/_Include.htm">#Include</a> oder einem nicht-dynamischen Aufruf einer <a href="#lib">Bibliotheksfunktion</a>).</li>
  <li>Es wurden zu wenig oder zu viele Parameter übergeben. Dies kann oft verhindert werden, indem man die <a href="objects/Func.htm#MinParams">MinParams</a>-, <a href="objects/Func.htm#MaxParams">MaxParams</a>- und <a href="objects/Func.htm#IsVariadic">IsVariadic</a>-Eigenschaft der Funktion überprüft. Die Ausnahme wird jedoch ausgelöst, da diese Bedingung in der Regel bedeutet, dass die Funktion falsch aufgerufen wird. Der Aufrufer sollte grundsätzlich wissen, was jeder Parameter bedeutet und wie viele es sind, bevor er die Funktion aufruft.</li>
</ul>
<p>Beachten Sie, dass ein dynamischer Aufruf etwas langsamer ist als ein normaler Aufruf, weil normale Aufrufe aufgelöst (nachgeschlagen) werden, bevor das Skript seine Ausführung beginnt.</p>

<h2 id="ShortCircuit">Boolesche Kurzschlussauswertung</h2>
<p><em>AND, OR</em> und der <a href="Variables.htm#ternary">ternäre Operator</a> innerhalb eines <a href="Variables.htm#Expressions">Ausdrucks</a> reduzieren die Auswertung auf ein Minimum, um die Leistung zu erhöhen (egal ob Funktionsaufrufe vorhanden sind oder nicht). Beim Kurzschließen werden nur Bereiche des Ausdrucks ausgewertet, die Einfluss auf das Endergebnis haben. Im folgenden Beispiel wird gezeigt, wie genau das abläuft:</p>
<pre>if (FarbeName != "" AND not FindeFarbe(FarbeName))
    MsgBox FarbeName " konnte nicht gefunden werden."</pre>
<p>Wenn die <em>FarbeName</em>-Variable leer sein sollte, wird die FindeFarbe()-Funktion nie aufgerufen, weil die linke Seite von <em>AND</em> als <em>falsch</em> gewertet wird, wodurch die rechte Seite nicht mehr in der Lage wäre, das Endergebnis auf <em>wahr</em> zu bringen.</p>
<p>Dieses Verhalten führt dazu, dass die Nebeneffekte einer Funktion (wie das Ändern des Inhalts einer globalen Variable) nie auftreten werden, wenn diese Funktion auf der rechten Seite von <em>AND</em> oder <em>OR</em> aufgerufen wird.</p>
<p>Beachten Sie außerdem, dass die Kurzschlussauswertung verschachtelte <em>AND</em>s und <em>OR</em>s stufenweise abarbeitet. Wenn <em>FarbeName</em> z. B. im folgenden Ausdruck leer ist, wird nur der am weitesten links befindliche Vergleich durchgeführt, weil die linke Seite dann ausreichen würde, um das Endergebnis zweifelsfrei zu bestimmen:</p>
<pre>if (FarbeName = "" <u>OR</u> FindeFarbe(FarbeName, Region1) <u>OR</u> FindeFarbe(FarbeName, Region2))
    break   <em>; Nichts zu durchsuchen oder Übereinstimmung gefunden.</em></pre>
<p>Wie die Beispiele oben zeigen, sollten umfangreiche (zeitaufwendige) Funktionen in der Regel auf der rechten Seite von <em>AND</em> oder <em>OR</em> aufgerufen werden, um die Leistung zu erhöhen. Diese Technik kann auch genutzt werden, um das Aufrufen einer Funktion zu verhindern, wenn ihr ein Wert übergeben wurde, den sie für unpassend hält (z. B. eine leere Zeichenkette).</p>
<p>Der <a href="Variables.htm#ternary">ternäre Bedingungsoperator (?:)</a> wendet auch die Kurzschlussauswertung an, indem er nur die gewinnende Abzweigung auswertet.</p>

<h2 id="nested">Verschachtelte Funktionen</h2>
<p>Eine <em>verschachtelte</em> Funktion ist eine Funktion, die in einer anderen Funktion definiert ist. Zum Beispiel:</p>
<pre>
außen(x) {
    innen(y) {
        MsgBox(y, x)
    }
    innen("eins")
    innen("zwei")
}
außen("Titel")
</pre>
<p>Der Zugriff auf eine verschachtelte Funktion kann nicht außerhalb der äußeren Funktion erfolgen, aber überall innerhalb dieser Funktion, einschließlich innerhalb weiterer verschachtelten Funktionen.</p>
<p>Standardmäßig kann eine verschachtelte Funktion auf eine beliebige lokale Variable der äußeren Funktion zugreifen, solange die Variable <a href="#static">statisch</a> ist oder sowohl von der Ursprungsfunktion als auch von der verschachtelten Funktion oder einer ihrer eigenen verschachtelten Funktionen nicht-dynamisch referenziert wird. <a href="#Global">Globale</a> Deklarationen in der äußeren Funktion gelten auch für verschachtelte Funktionen, außer wenn sie mit dem <a href="#ForceLocal">Force-Local</a>-Modus überschrieben werden.</p>
<p>Wenn eine Funktion als <a href="#ForceLocal">Force-Local</a> oder <a href="#AssumeGlobal">Assume-Global</a> deklariert ist, sind alle lokalen oder statischen Variablen, die <em>außerhalb</em> dieser Funktion erstellt wurden, für die Funktion selbst oder eine ihrer verschachtelten Funktionen nicht direkt zugänglich. Eine verschachtelte Assume-Static-Funktion hingegen kann immer noch auf die Variablen der äußeren Funktion zugreifen, es sei denn, sie ist zusätzlich Force-Local.</p>
<p>Funktionen sind standardmäßig im <a href="#AssumeLocal">Assume-Local</a>-Modus, was auch für verschachtelte Funktionen gilt, sogar innerhalb einer <a href="#AssumeStatic">Assume-Static</a>-Funktion. Wenn die äußere Funktion jedoch im <a href="#AssumeGlobal">Assume-Global</a>-Modus ist, verhalten sich verschachtelte Funktionen so, als gelte standardmäßig Assume-Global, außer dass sie auf die lokalen und statischen Variablen der äußeren Funktion zugreifen können.</p>
<p><a href="commands/Func.htm">Func</a> kann genutzt werden, um eine Referenz zu einer verschachtelten Funktion zu ermitteln. Solche verschachtelten Funktionen können auch dann noch aufgerufen werden, wenn die äußeren Funktionen ihr Ende bereits erreicht haben. Verschachtelte Funktionen können auch via Name an interne Funktionen wie <a href="commands/SetTimer.htm">SetTimer</a> und <a href="commands/Sort.htm">Sort</a> übergeben werden.</p>

<h3 id="closures">Closures</h3>
<p>Ein <em>Closure</em> ist eine verschachtelte Funktion, die an eine Reihe von <em>freien Variablen</em> gebunden ist. Freie Variablen sind lokale Variablen der äußeren Funktion, auf die verschachtelte Funktionen zugreifen können. Closures ermöglichen es, dass eine oder mehrere verschachtelte Funktionen ihre Variablen mit der äußeren Funktion teilen, selbst wenn die äußere Funktion bereits ihr Ende erreicht hat.</p>
<p>Um ein Closure zu erstellen, übergeben Sie den Namen einer verschachtelten Funktion an <a href="commands/Func.htm">Func</a>. Zum Beispiel:</p>
<pre>
Begrüßer_erstellen(f)
{
    begrüße(Subjekt)  <em>; Dies wird wegen f ein Closure sein.</em>
    {
        MsgBox Format(f, Subjekt)
    }
    return Func("begrüße")  <em>; Erstellt und gibt ein Closure zurück.</em>
}

g := Begrüßer_erstellen("Hallo, {}!")
g.call(A_UserName)
g.call("Welt")
</pre>
<p>Ein Closure kann auch erstellt werden, wenn man den Namen einer verschachtelten Funktion an eine interne Funktion wie <a href="commands/SetTimer.htm">SetTimer</a> oder <a href="commands/Hotkey.htm">Hotkey</a> übergibt. Zum Beispiel:</p>
<pre>
app_hotkey(hotkey, app_titel, app_pfad)
{
    aktivieren()  <em>; Dies wird wegen app_titel und app_pfad ein Closure sein.</em>
    {
        if WinExist(app_titel)
            WinActivate
        else
            Run app_pfad
    }
    Hotkey hotkey, "aktivieren"
}
<em>; Win+N aktiviert oder startet Notepad.</em>
app_hotkey "#n", "ahk_class Notepad", "notepad.exe"
<em>; Win+W aktiviert oder startet WordPad.</em>
app_hotkey "#w", "ahk_class WordPadClass", "wordpad.exe"
</pre>
<p>Wenn eine Funktion freie Variablen erzeugt (also wenn verschachtelten Funktionen auf eine ihrer lokalen Variablen zugreifen), werden alle verschachtelten Funktionen dieser Funktion zu Closures. Das kommt daher, dass eine verschachtelte Funktion eine beliebig andere verschachtelte Funktion aufrufen oder für sie via Name ein Closure erstellen kann.</p>
<p>Jedes Mal, wenn ein Funktionsname in ein Closure aufgelöst wird, wird ein <em>neues</em> Closure erstellt, selbst wenn ein Closure bereits mit dem gleichen Satz freier Variablen erstellt wurde. Übergeben Sie ein Closure nicht via Name an <a href="commands/SetTimer.htm">SetTimer</a>, <a href="commands/OnClipboardChange.htm">OnClipboardChange</a>, <a href="commands/OnExit.htm">OnExit</a>, <a href="commands/OnMessage.htm">OnMessage</a> oder <a href="objects/GuiOnEvent.htm">Gui.OnEvent</a>, wenn dieses Closure später entfernt werden muss, da dies die Rückgabe des gleichen Objekts erfordert. Zum Beispiel:</p>
<pre>
timertest() {
    x := "tack!"
    tick() {
        MsgBox x           <em>; x macht dies zu einem Closure.</em>
        <em>;SetTimer t, 0     ; Dies würde ein Zirkelbezug bewirken.</em>
    }
    SetTimer "tick", 1000  <em>; Erstellt einen Timer.</em>
    SetTimer "tick", 0     <em>; Scheitert daran, den Timer zu löschen.</em>
    t := Func("tick")
    SetTimer t, 1000       <em>; Erstellt einen zweiten Timer.</em>
    SetTimer t, 0          <em>; Löscht den zweiten Timer.</em>
}
timertest()
</pre>
<p id="circular-closure">Es ist ratsam, eine Referenz zu einem Closure nicht in eine der freien Variablen des Closure zu speichern, da dies einen <a href="Objects.htm#Circular_References">Zirkelbezug</a> erzeugt, der unterbrochen werden muss, bevor das Closure freigegeben werden kann, z. B. indem man die Variable leert.</p>

<h2 id="remarks">Return, Exit und allgemeine Bemerkungen</h2>
<p>Wenn der Ausführungsablauf die geschweifte Endklammer der Funktion vor einem <a href="commands/Return.htm">Return</a> erreicht hat, endet die Funktion und gibt eine leere Zeichenkette zurück. Es wird auch ein leerer Wert zurückgegeben, wenn die Funktion den Parameter von <a href="commands/Return.htm">Return</a> explizit weglässt.</p>
<p>Wenn eine Funktion ein <a href="commands/Exit.htm">Exit</a> zum Beenden des <a href="misc/Threads.htm">aktuellen Threads</a> verwendet, erhält ihr Aufrufer überhaupt keinen Rückgabewert. Das <code>Var</code> in <code>Var := Addieren(2, 3)</code> bliebe beispielsweise unverändert, wenn <code>Addieren()</code> via Exit beendet wird. Das gleiche passiert, wenn eine Funktion einen Laufzeitfehler verursacht, wie z. B. das <a href="commands/Run.htm">Ausführen</a> einer nicht-existierenden Datei (sofern dieser Fehler nicht von einer <a href="commands/Try.htm">Try</a>/<a href="commands/Catch.htm">Catch</a>-Anweisung abgefangen wurde).</p>
<p>Um eine Funktion mit einem oder mehreren leeren Werten (leeren Zeichenketten) aufzurufen, verwenden Sie zwei aufeinanderfolgende Anführungszeichen. Zum Beispiel: <code>FindeFarbe(FarbeName, "")</code>.</p>
<p>Da das Aufrufen einer Funktion keinen neuen <a href="misc/Threads.htm">Thread</a> startet, werden Änderungen an Einstellungen wie <a href="commands/SendMode.htm">SendMode</a> und <a href="commands/SetTitleMatchMode.htm">SetTitleMatchMode</a> auch für den Aufrufer wirksam.</p>
<p>Der Aufrufer kann nicht-existierende Variablen oder <a href="misc/Arrays.htm">Array</a>-Elemente an eine Funktion übergeben. Dies ist nützlich, wenn die Funktion den entsprechenden Parameter als <a href="#ByRef">ByRef</a> erwartet. Ruft man beispielsweise <code>ErmittleNächsteZeile(LeeresArray%i%)</code> auf, wird die Variable <code>LeeresArray%i%</code> automatisch als <a href="#Local">lokale</a> oder globale Variable erstellt (abhängig davon, ob der Aufrufer sich in einer Funktion befindet und ob der <a href="#AssumeGlobal">Assume-Global-Modus</a> wirksam ist).</p>
<p><a href="commands/ListVars.htm">ListVars</a> kann, wenn es in einer Funktion verwendet wird, die Namen und Inhalte von <a href="#Local">lokalen Variablen</a> anzeigen. Solche Informationen können helfen, ein Skript zu debuggen (Fehler zu finden und zu beseitigen).</p>
<h2>Stil- und Namenskonventionen</h2>
<p>Bei komplexen Funktionen kann es hilfreich sein, die speziellen Variablen mit eindeutigen Präfixen zu versehen, um die Übersichtlichkeit und Wartbarkeit des Skripts zu erhöhen. Die Namen der Parameter einer Funktion können beispielsweise mit "p" oder "p_" beginnen, damit die Parameter auf den ersten Blick leicht zu erkennen sind, besonders um die Übersicht zu bewahren, wenn eine Funktion mehrere Dutzend <a href="#Local">lokale Variablen</a> enthält. Ebenso kann das Präfix "r" oder "r_" für <a href="#ByRef">ByRef-Parameter</a> und "s" oder "s_" für <a href="#static">statische Variablen</a> verwendet werden.</p>
<p>Der <a href="commands/Block.htm#otb">One True Brace Style</a> (OTB) kann je nach Bedarf angewendet werden, um Funktionen zu definieren. Zum Beispiel:</p>
<pre>Addieren(x, y) {
    return x + y
}</pre>

<h2 id="include">Skripte mittels #Include auf die gleichen Funktionen zugreifen lassen</h2>
<p>Die <a href="commands/_Include.htm">#Include</a>-Direktive kann verwendet werden, um Funktionen aus einer externen Datei zu laden.</p>

<h2 id="lib">Funktionsbibliotheken: Standard- und Benutzerbibliothek</h2>
<p>Ein Skript kann eine Funktion in einer externen Datei aufrufen, ohne <a href="commands/_Include.htm">#Include</a> verwenden zu müssen. Damit dies funktioniert, muss eine Datei, die den gleichen Namen hat wie die Funktion, in einem der folgenden Bibliotheksverzeichnisse vorkommen:</p>
<pre><a href="Variables.htm#ScriptDir">A_ScriptDir</a> "\Lib\"  <em>; Lokale Bibliothek.</em>
<a href="Variables.htm#MyDocuments">A_MyDocuments</a> "\AutoHotkey\Lib\"  <em>; Benutzerbibliothek.</em>
"Verzeichnis-der-aktuell-laufenden-AutoHotkey.exe\Lib\"  <em>; Standardbibliothek.</em></pre>
<p>Wenn ein Skript beispielsweise die nicht-existierende Funktion <code>MeineFunk()</code> aufruft, durchsucht das Programm die Benutzerbibliothek nach einer Datei namens "MeineFunk.ahk". Wenn sie dort nicht ist, wird die Standardbibliothek durchsucht. Wenn sie dort auch nicht gefunden wurde und enthält der Funktionsname einen Unterstrich (z. B. <code>MeinPräfix_MeineFunk</code>), durchsucht das Programm beide Bibliotheken nach einer Datei namens <code>MeinPräfix.ahk</code> und lädt sie, falls sie existiert. Wenn <code>MeinPräfix.ahk</code> geladen wurde, sind sowohl die Funktion <code>MeinPräfix_MeineFunk</code> als auch andere verwandte Funktionen, deren Namen mit <code>MeinPräfix_</code> beginnen, zugänglich.</p>
<p>Die lokale Bibliothek wird durchsucht, bevor die Benutzerbibliothek und Standardbibliothek durchsucht werden.</p>
<p>Nur ein direkter Funktionsaufruf wie <code>MeineFunk()</code> bewirkt, dass eine Bibliothek automatisch eingebunden wird. Wenn die Funktion nur dynamisch oder indirekt aufgerufen wird, z. B. via Timer oder GUI-Ereignis, muss die Bibliothek explizit in das Skript eingebunden werden. Zum Beispiel: <code><a href="commands/_Include.htm">#Include</a> &lt;MeineFunk&gt;</code></p>
<p>Obwohl eine Bibliotheksdatei in der Regel nur eine einzelne Funktion mit demselben Namen wie die Datei enthält, kann sie auch private Funktionen und Subroutinen enthalten, die nur von ihr aufgerufen werden. Allerdings sollten solche Funktionen eindeutige Namen haben, weil sie im globalen Namensraum sind; das heißt, dass sie von überall im Skript aufgerufen werden können.</p>
<p>Wenn eine Bibliotheksdatei <a href="commands/_Include.htm">#Include</a> ausführt, verwendet #Include als Arbeitsverzeichnis das Verzeichnis der Bibliotheksdatei. Dies kann genutzt werden, um eine Weiterleitung zu einer größeren Bibliotheksdatei zu erschaffen, die diese Funktion und andere damit verbundene Funktionen enthält.</p>
<p>Der <a href="Scripts.htm#ahk2exe">Skript-Compiler (ahk2exe)</a> unterstützt auch Bibliotheksfunktionen. Der Compiler setzt aber voraus, dass eine Kopie von AutoHotkey.exe im übergeordneten Verzeichnis des Compiler-Verzeichnisses vorhanden ist (was normalerweise der Fall ist). Wenn der Compiler dort keine AutoHotkey.exe findet, funktioniert er immer noch, aber die Bibliotheksfunktionen werden nicht mehr automatisch eingebunden.</p>
<p>Funktionen, die aus einer Bibliothek eingebunden werden, sind genauso leistungsfähig wie normale Funktionen, weil sie geladen werden, bevor das Skript seine Ausführung beginnt.</p>
<h2 id="BuiltIn">Interne Funktionen</h2>
<p>Alle optionalen Parameter am Ende der Parameterliste einer internen Funktion können komplett weggelassen werden. <code>WinExist("Unbenannt - Editor")</code> ist zum Beispiel gültig, weil die anderen drei Parameter als leere Werte behandelt werden.</p>
<p>Eine interne Funktion gilt als überschrieben, wenn im Skript eine Funktion mit demselben Namen definiert ist. Zum Beispiel könnte man anstelle der normalen WinExist-Funktion eine selbstdefinierte Funktion verwenden. Allerdings kann danach die originale Funktion nicht mehr aufgerufen werden.</p>
<p>Externe Funktionen, die sich in DLL-Dateien befinden, können via <a href="commands/DllCall.htm">DllCall</a> aufgerufen werden.</p>
<p>Eine Liste aller internen Funktionen finden Sie unter <a href="commands/index.htm">Alphabetischer Funktionsindex</a>.</p>
</body>
</html>
