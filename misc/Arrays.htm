<!DOCTYPE HTML>
<html lang="de">
<head>
<title>Arrays - Definition &amp; Verwendung | AutoHotkey v2</title>
<meta name="description" content="Arrays sind entweder Datenstrukturen, die aus einer Sammlung von Werten bestehen, die jeweils durch einen Key identifiziert werden, oder eine Sammlung von sequentiell nummerierten Variablen." />
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="robots" content="noindex, nofollow">
<link href="../static/theme.css" rel="stylesheet" type="text/css" />
<script src="../static/content.js" type="text/javascript"></script>
<script src="../static/ga.js" type="text/javascript"></script>
</head>

<body>
<h1>Arrays</h1>
<p>In AutoHotkey gibt es zwei verschiedene Typen von Dingen, die etwas mit Arrays zu tun haben:</p>
<ul>
  <li><a href="#object-based">Objekt-basierende Arrays</a></li>
  <li><a href="#pseudo">Pseudo-Arrays</a> (nicht zur Verwendung empfohlen)</li>
</ul>
<p class="note"><strong>Hinweis</strong>: Die folgenden Code-Beispiele zeigen verschiedene Ansätze, die zum gleichen Endergebnis führen.</p>

<h2 id="object-based">Objekt-basierende Arrays</h2>
<p>Solche Arrays können <a href="../Objects.htm#Usage_Associative_Arrays">assoziative Arrays</a> oder <a href="../Objects.htm#Usage_Simple_Arrays">einfache Arrays</a> sein. Assoziative Arrays werden mit der Map-Funktion erstellt, während einfache Arrays mit der Array-Funktion oder mit eckigen Klammern erstellt werden. Weitere Informationen finden Sie unter <a href="../Tutorial.htm#s7">AutoHotkey Anfänger-Tutorial</a> oder <a href="../Objects.htm">Objekte</a>.</p>

<p>Das folgende Beispiel zeigt die Verwendung eines einfachen Arrays:</p>
<pre><em>; Erstellt ein Array, das zunächst leer ist:</em>
MeinArray := [] <em>; oder MeinArray := Array()</em>

<em>; Schreibt in das Array:</em>
Loop Read A_WinDir "\system.ini" <em>; Diese Schleife ruft jede Zeile der Datei einzeln ab.</em>
{
    MeinArray.Push(A_LoopReadLine) <em>; Fügt diese Zeile ans Array an.</em>
}

<em>; Liest vom Array:
; Loop MeinArray.Length   ; Traditionellerer Ansatz.</em>
for index, element in MeinArray <em>; Enumeration ist in den meisten Fällen empfohlen.</em>
{
    <em>; Beim Verwenden von "Loop" müssen die Indexe fortlaufende Nummern von 1 bis zur Anzahl
    ; der Elemente im Array sein (oder sie müssen innerhalb der Schleife berechnet werden).
    ; MsgBox "Elementnummer " . A_Index . " ist " . MeinArray[A_Index]

    ; Beim Verwenden von "for" werden sowohl der Index (oder "Key") als auch dessen Wert
    ; bereitgestellt, wobei der Index ein *beliebiger* Wert sein kann.</em>
    MsgBox "Elementnummer " . index . " ist " . element
}</pre>
<p>Dies zeigt nur ein kleiner Teil der <a href="../objects/Array.htm">Funktionalität</a> von einfachen Arrays (oder die <a href="../objects/Map.htm">Funktionalität</a> von assoziativen Arrays, auch bekannt als Map-Objekte). Elemente können gesetzt, abgerufen, eingefügt, entfernt und enumeriert werden. Neben Zahlen können auch Zeichenketten und Objekte beliebigen Typs als Keys verwendet werden. Objekte können als Werte in andere Objekte gespeichert und als Funktionsparameter oder Rückgabewerte übergeben werden. Zudem können Objekte mit neuer Funktionalität <a href="../Objects.htm#Custom_Objects">erweitert</a> werden.</p>
<p>Obwohl Push() und Enumeratoren ihren Nutzen haben, finden es einige Benutzer einfacher, den traditionelleren Ansatz zu verwenden (die auskommentierten Zeilen sind die entsprechenden Counterparts, die die unten beschriebenen <a href="#pseudo">Pseudo-Arrays</a> verwenden):</p>
<pre>
<em>; Jedes Array muss vorher initialisiert werden:</em>
MeinMap := Map()

<em>; MeinMap%j% := A_LoopField</em>
MeinMap[j] := A_LoopField

<em>; MeinMap%j%_%k% := A_LoopReadLine</em>
MeinMap[j] := Map()
MeinMap[j][k] := A_LoopReadLine

MeinMapLänge := 0
Loop Read A_WinDir "\system.ini"
{
    MeinMapLänge += 1
    <em>; MeinMap%MeinMapLänge% := A_LoopReadLine</em>
    MeinMap[MeinMapLänge] := A_LoopReadLine
}

Loop MeinMapLänge
{
    <em>; Element := MeinMap%A_Index%</em>
    Element := MeinMap[A_Index]
    <em>; MsgBox "Elementnummer " . A_Index . " ist " . MeinMap%A_Index%</em>
    MsgBox "Elementnummer " . A_Index . " ist " . MeinMap[A_Index]
}
</pre>
<p><i>MeinMapLänge</i> bleibt aus Bequemlichkeit eine Variable, die aber mit <code>MeinMap.Length := <i>n</i></code> in das Array selbst gespeichert oder mit <code>MeinMap.<a href="../objects/Map.htm#Count">Count</a></code> ersetzt werden kann.</p>

<h2 id="pseudo">Pseudo-Arrays</h2>
  <p class="note"><strong>Hinweis</strong>: Verwenden Sie nach Möglichkeit immer das oben erwähnte Objekt-basierende Array. Es ist einem Pseudo-Array in fast allen Aspekten überlegen: Es ist platzsparend, flexibler, übersichtlicher und ähnelt vielen anderen Programmiersprachen.</p>
<p>Pseudo-Arrays sind meistens konzeptionell: Jedes Array ist eigentlich nur eine Sammlung von durchnummerierten <a href="../Variables.htm">Variablen</a> oder <a href="../Functions.htm">Funktionen</a>, die als <em>Elemente</em> des Arrays wahrgenommen werden. In AutoHotkey werden diese Elemente in keiner Weise miteinander verknüpft.</p>
<p>Jede Funktion, die eine Ausgabevariable akzeptiert oder einen Wert in eine Variable speichert, kann genutzt werden, um ein Array zu erstellen. Das einfachste Beispiel dafür ist der <a href="../commands/SetExpression.htm">Zuweisungsoperator (:=)</a>, wie unten dargestellt:</p>
<pre>Array%j% := A_LoopField</pre>
<p>Außerdem sind auch mehrdimensionale Arrays möglich, indem ein beliebiges Trennzeichen zwischen den Indexen verwendet wird. Zum Beispiel:</p>
<pre>Array%j%_%k% := A_LoopReadLine</pre>
<p>Das folgende Beispiel verdeutlicht, wie ein Array erstellt und auf ihm zugegriffen werden kann. In diesem Fall werden mehrere Namen aus einer Textdatei abgerufen:</p>
<pre><em><strong>; Schreibt in das Array:</strong></em>
ArrayAnzahl := 0
Loop Read A_WinDir "\system.ini"   <em>; Diese Schleife ruft jede Zeile der Datei einzeln ab.</em>
{
    ArrayAnzahl += 1  <em>; Behält im Blick, wie viele Elemente im Array sind.</em>
    Array%ArrayAnzahl% := A_LoopReadLine  <em>; Speichert diese Zeile ins nächste Array-Element.</em>
}

<em><strong>; Liest vom Array:</strong></em>
Loop ArrayAnzahl
{
    <em>; Die folgende Zeile verwendet den ":="- Operator, um ein Array-Element abzurufen:</em>
    Element := Array%A_Index%  <em>; <a href="../Variables.htm#Index">A_Index</a> ist eine interne Variable.</em>
    <em>; Alternativ können Sie auch Folgendes tun, da alle Funktionen standardmäßig <a href="../Variables.htm#Expressions">Ausdrücke</a> akzeptieren:</em>
    MsgBox "Elementnummer" . A_Index . " ist " . Array%A_Index%
}</pre>
<p>Ein ähnliches Konzept wird mit <a href="../commands/NumPut.htm">NumPut</a> und <a href="../commands/NumGet.htm">NumGet</a> erreicht, mit denen mehrere Zahlen im Binärformat gespeichert oder abgerufen werden können. Das ist besonders hilfreich, falls die Performance und/oder Speicherauslastung von entscheidender Bedeutung sind.</p>

</body>
</html>
