<!DOCTYPE HTML>
<html>
<head>
<title>DllCall</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="robots" content="noindex, nofollow">
<link href="../static/theme.css" rel="stylesheet" type="text/css" />
<script src="../static/content.js" type="text/javascript"></script>
<script src="../static/ga.js" type="text/javascript"></script>
</head>
<body>

<h1>DllCall</h1>

<p>Ruft eine Funktion innerhalb einer DLL-Datei auf, wie z. B. eine API-Funktion von Windows.</p>

<pre class="Syntax">Ergebnis := <span class="func">DllCall</span>("<span class="optional">DllDatei\</span>Funktion" <span class="optional">, Typ1, Arg1, Typ2, Arg2, "Cdecl Rückgabetyp"</span>)</pre>
<h3>Parameter</h3>
<dl>

  <dt>Ergebnis</dt>
  <dd><p>DllCall gibt den aktuellen Rückgabewert der Funktion zurück. Unterstützt die Funktion keinen Rückgabewert, übergibt sie einen undefinierten Integer-Wert. Wenn die Funktion durch einen <a href="#error">Fehler</a> nicht aufgerufen werden kann, ist der Rückgabewert leer (eine leere Zeichenkette).</p></dd>

  <dt>[DllDatei\]Funktion</dt>
  <dd><p>Der Name einer DLL- oder EXE-Datei, gefolgt von einem umgekehrten Schrägstrich und dem Funktionsnamen. Zum Beispiel: <code>"MeineDLL\MeineFunktion"</code> (die Dateierweiterung ".dll" kann standardmäßig weggelassen werden). Solange kein absoluter Pfad angegeben ist, befindet sich die <em>DllDatei</em> im System- oder <a href="../Variables.htm#WorkingDir">A_WorkingDir</a>-Pfad.</p>
      <p id="std"><em>DllDatei</em> kann weggelassen werden, wenn eine Funktion in User32.dll, Kernel32.dll, ComCtl32.dll oder Gdi32.dll aufgerufen wird. Zum Beispiel würde <code>"User32\IsWindowVisible"</code> das gleiche Ergebnis liefern wie <code>"IsWindowVisible"</code>.</p>
      <p>Wenn eine Funktion nicht über den angegebenen Namen gefunden werden kann, wird automatisch ein W (Unicode) angefügt. Zum Beispiel wäre <code>"MessageBox"</code>  das gleiche wie <code>"MessageBoxW"</code>.</p>
      <p>Bei <em>wiederholenden</em> Aufrufen einer DLL-Datei kann die Performance erheblich verbessert werden, indem man sie <a href="#load">im Voraus lädt</a>.</p>
      <p>Dieser Parameter kann auch ein reiner Integer sein, um die Adresse einer Funktion anzugeben, die aufgerufen werden soll. Quellen für solche Adressen sind <a href="#COM">COM</a> und <a href="RegisterCallback.htm">RegisterCallBack</a>.</p></dd>

  <dt>Typ1, Arg1</dt>
  <dd><p>Jedes dieser Paare repräsentiert einen einzelnen Parameter, der an die Funktion übergeben werden soll. Die Anzahl an möglichen Paaren ist unbegrenzt. Bei <em>Typ</em> kann ein Typ aus der unteren <a href="#types">Typentabelle</a> angegeben werden. Bei <em>Arg</em> kann der Wert angegeben werden, der an die Funktion übergeben werden soll.</p></dd>

  <dt>Cdecl Rückgabetyp</dt>
  <dd><p id="cdecl">Das Wort <em>Cdecl</em> wird normalerweise weggelassen, weil die meisten Funktionen die Standard-Aufrufkonvention verwenden, statt die C-Aufrufkonvention (Funktionen wie wsprintf, die eine unterschiedliche Anzahl an Argumenten akzeptieren, bilden solch eine Ausnahme). Beachte, dass die meisten objektorientierten C++-Funktionen die <i>thiscall</i>-Konvention verwenden, die in AutoHotkey nicht unterstützt wird.</p>
      <p>Das Wort <em>Cdecl</em> sollte vor dem Rückgabetyp (falls vorhanden) stehen. Dabei muss jedes Wort mit einem Leer- oder Tabulatorzeichen getrennt werden. Zum Beispiel: <code>"Cdecl Str"</code>.</p>
      <p>In den 64-Bit-Builds von AutoHotkey hat <i>Cdecl</i> keine Wirkung, weil es keine seperate C-Aufrufkonvention im 64-Bit-Code gibt.</p>
      <p><em>Rückgabetyp</em>: Wenn die Funktion einen vorzeichenbehafteten 32-Bit-Integer (Int), BOOL oder nichts zurückgibt, kann <em>Rückgabetyp</em> weggelassen werden. Ansonsten kann ein Argumenttyp aus der <a href="#types">Typentabelle</a> verwendet werden. Das <a href="#asterisk">Sternchen-Suffix</a> wird ebenfalls unterstützt.</p></dd>

</dl>

<h3 id="types">Argumenttypen und Rückgabewerte</h3>
<table class="info">
<tr id="str">
<td>Str</td>
<td><p>Eine Zeichenkette wie "Blau" oder MeineVar. Wenn die aufgerufene Funktion die Zeichenkette ändert und das Argument eine reine Variable ist, wird deren Inhalt aktualisiert. Zum Beispiel würde der folgende Aufruf den Inhalt von <em>MeineVar</em> in Großbuchstaben umwandeln: <code>DllCall("CharUpper", "Str", <i>MeineVar</i>)</code>.</p>
  <p>Wenn die Funktion allerdings in der Lage ist, eine Zeichenkette größer als die aktuelle Variablenkapazität zu speichern, muss sichergestellt werden, dass die Variable vor dem Funktionsaufruf groß genug ist. Verwende dazu <code><a href="VarSetCapacity.htm">VarSetCapacity(MeineVar, 123)</a></code> - 123 wäre die Länge, die <em>MeineVar</em> haben soll.</p>
  <p>Ein <em>Str</em>-Argument darf kein <a href="../Variables.htm#Expressions">Ausdruck</a> sein, der eine Zahl errechnet (z. B. i+1). In diesem Fall wird die Funktion nicht aufgerufen und ErrorLevel auf -2 gesetzt.</p>
  <p>Die <a href="#asterisk">Sternchenvariable</a> "Str*" wird unterstützt, aber nur selten verwendet. Sie kann bei Funktionen nützlich sein, die so etwas wie "TCHAR **" oder "LPTSTR *" erwarten.</p>
  <p>Hinweis: Bei der Übergabe einer Zeichenkette an eine Funktion muss klar sein, welchen <a href="../Compat.htm#DllCall">Zeichenketten-<i>Typ</i></a> die Funktion erwartet.</p></td>
</tr>
<tr>
  <td><span id="wstr"></span>WStr</td>
  <td>Da AutoHotkey standardmäßig UTF-16 verwendet, ist WStr (Wide Character String) das Äquivalent zu Str.</td>
</tr>
<tr>
  <td><span id="astr"></span>AStr</td>
  <td>
    <p>AStr bewirkt, dass der Eingabewert automatisch in ANSI umgewandelt wird. Da der zum Konvertieren benutzte temporäre Speicher nur Platz für die umgewandelte Eingabezeichenkette gewährleisten kann, wird die Funktion zuvor den aktuellen Speicherinhalt verwerfen. Das folgende Beispiel zeigt, wie eine ANSI-Zeichenkette als Ausgabeparameter empfangen werden kann:</p>
<pre>VarSetCapacity(Puffer, <i>Länge</i>)  <em>; Ordnet temporären Puffer zu.</em>
DllCall("<i>Function</i>", "ptr", &amp;Puffer)  <em>; Übergibt Puffer an Function.</em>
str := StrGet(&amp;Puffer, "cp0")  <em>; Ermittelt ANSI-Zeichenkette vom Puffer.</em>
</pre>
    <p>Unter <a href="../Compat.htm#DllCall">Skript-Kompatibilität</a> findest du gleichwertige Win32-Typen und weitere Details.</p>
  </td>
</tr>
<tr>
  <td>Int64</td>
  <td>Ein 64-Bit-Integer mit einem Bereich von -9223372036854775808 (-0x8000000000000000) bis 9223372036854775807 (0x7FFFFFFFFFFFFFFF).</td>
</tr>
<tr id="Int">
  <td>Int</td>
  <td><p>Ein 32-Bit-Integer (meistgenutzter Integer-Typ) mit einem Bereich von -2147483648 (-0x80000000) bis 2147483647 (0x7FFFFFFF). Int wird manchmal auch als "Long" bezeichnet.</p>
    <p>Int sollte auch verwendet werden, wenn die Funktion ein BOOL-Argument erwartet (ein BOOL-Wert sollte entweder 1 oder 0 sein).</p>
    <p>Ein <a href="#unsigned">vorzeichenloser</a> (unsigned) Integer (UInt) wird auch ziemlich oft genutzt, z. B. für DWORD.</p></td>
</tr>
<tr>
  <td>Short</td>
  <td>Ein 16-Bit-Integer im Bereich von -32768 (-0x8000) bis 32767 (0x7FFF). Ein <a href="#unsigned">vorzeichenloser</a> 16-Bit-Integer (UShort) kann bei Funktionen verwendet werden, die DWORD erwarten.</td>
</tr>
<tr>
  <td>Char</td>
  <td>Ein 8-Bit-Integer mit einem Bereich von -128 (-0x80) bis 127 (0x7F). Ein <a href="#unsigned">vorzeichenloser</a> 8-Bit-Integer (UChar) kann bei Funktionen verwendet werden, die BYTE erwarten.</td>
</tr>
<tr>
  <td>Float</td>
  <td>Eine 32-Bit-Gleitkommazahl mit maximal 6 Stellen nach dem Komma.</td>
</tr>
<tr>
  <td>Double</td>
  <td>Eine 64-Bit-Gleitkommazahl mit maximal 15 Stellen nach dem Komma.</td>
</tr>
<tr id="ptr">
  <td>Ptr</td>
  <td><p>Ein <a href="../Variables.htm#PtrSize">pointer-großer</a> Integer, der Int oder Int64 entspricht, abhängig davon, ob die skript-ausführende EXE-Datei 32- oder 64-Bit ist. <i>Ptr</i> sollte für Pointer verwendet werden, die auf Arrays oder Strukturen (wie RECT* oder LPPOINT) verweisen, und für fast alle Handles (wie HWND, HBRUSH oder HBITMAP). Wenn der Parameter ein Pointer ist, der auf einen einzelnen numerischen Wert wie LPDWORD oder int* verweist, ist der *- oder P-Suffix besser geeignet als "Ptr".</p>
  <p><i>Ptr</i> kann auch den *- oder P-Suffix haben; es sollte nur bei Funktionen verwendet werden, die einen Pointer per LPVOID* oder Ähnliches zurückgeben.</p>
  <p><i>UPtr</i> ist auch gültig, aber nur in einem 32-Bit-Build, da AutoHotkey keine vorzeichenlose 64-Bit-Integer unterstützt.</p>
  <p>Wenn die Kompatibilität mit älteren Versionen von AutoHotkey erforderlich ist, kann ein Variablentyp wie folgt verwendet werden:</p>
  <pre>Ptr := A_PtrSize ? "Ptr" : "UInt" <em>; Wenn A_PtrSize nicht definiert ist, gilt stattdessen UInt.</em>
DllCall("DeleteFile", Ptr, &amp;Dateiname) <em>; Lass die Anführungszeichen bei Ptr weg.</em></pre>
  <p>Hinweis: Zum Übergeben eines <strong>NULL</strong>-Handles oder -Pointers muss der Integer 0 verwendet werden.</p></td>
</tr>
<tr id="asterisk">
  <td>* oder P<br>
    (Suffix)</td>
  <td><p>Füge ein Sternchen (optional mit einem Leerzeichen davor) an einen der oben genannten Typen davor an, wenn nicht der Wert selbst, sondern die Adresse des Arguments übergeben werden soll (die aufgerufene Funktion muss so konstruiert sein, dass sie so etwas akzeptieren kann). Der Wert von so einem Argument könnte durch die Funktion geändert werden - wann immer man eine reine Variable als Argument übergibt, wird der Inhalt dieser Variable aktualisiert. Zum Beispiel würde der folgende Aufruf den Inhalt von MeineVar per Adresse an MeineFunktion übergeben, und auch MeineVar aktualisieren, um Änderung an ihr durch MeineFunktion widerzuspiegeln: <code>DllCall("MeineDLL\MeineFunktion", "Int*", MeineVar)</code>.</p>
    <p>In der Regel wird ein Sternchen verwendet, wann immer eine Funktion ein Argumenttyp oder Rückgabetyp hat, der mit "LP" beginnt. Das bekannteste Beispiel dafür ist LPDWORD - ein Pointer, der auf ein DWORD verweist. Da DWORD ein vorzeichenloser 32-Bit-Integer ist, sollte für LPDWORD stattdessen "UInt*" oder "UintP" verwendet werden. Das Sternchen sollte nicht bei Zeichenkettentypen wie LPTSTR, auf Strukturen verweisende Pointer wie LPRECT, oder Arrays verwendet werden; für sie ist <a href="#str">"Str"</a> oder "Ptr" besser geeignet, abhängig davon, ob du eine Variable oder deren Adresse übergeben willst.</p>
    <p>Hinweis: "Char*" ist nicht das gleiche wie <a href="#str">"Str"</a>, weil "Char*" die Adresse einer 8-Bit-Zahl übergibt, während <a href="#str">"Str"</a> die Adresse einer Reihe von Zeichen übergibt, die je nach AutoHotkey-Version 16-Bit (Unicode) oder 8-Bit (für "AStr") groß sind. Ebenso übergibt "UInt*" die Adresse einer 32-Bit-Zahl. Es sollte nicht verwendet werden, wenn die Funktion ein Array mit Werten oder eine Struktur größer als 32 Bit erwartet.</p>
    <p>Da die Variablen in AutoHotkey keinen festen Typ haben, verweist die Adresse, die an die Funktion übergeben wurde, auf einen temporären Speicher, anstatt auf die Variable selbst. Es ist nicht notwendig, <a href="VarSetCapacity.htm">VarSetCapacity</a> auf die Variable anzuwenden, weil DllCall sie nach dem Durchführen der Funktion korrekt aktualisieren wird.</p>
    </td>
</tr>
<tr id="unsigned">
  <td>U (Präfix)</td>
  <td><p>Füge den Buchstaben U an einen der oben genannten Integer-Typen dahinter an, wenn der Typ als vorzeichenloser Integer (UInt64, Uint, UShort und UChar) interpretiert werden soll. Streng genommen ist das nur für Rückgabewerte und <a href="#asterisk">Sternchenvariablen</a> notwendig, da es keine Rolle spielt, ob ein Argument, der als Wert übergeben wurde, vorzeichenbehaftet oder vorzeichenlos ist (außer für Int64).</p>
    <p>Wenn ein negativer Integer bei einem vorzeichenlosen Argument angegeben wurde, wechselt der Integer in den vorzeichenlosen Bereich. Wenn -1 beispielsweise als UInt gesendet wurde, wäre es 0xFFFFFFFF.</p>
    <p>Von Funktionen erzeugte <em>vorzeichenlose</em> 64-Bit-Integer werden nicht unterstützt. Zahlen größer gleich 0x8000000000000000 können daher nur verwendet werden, wenn man das U-Präfix weglässt und jeden negativen Wert, der von der Funktion empfangen wurde, als großen Integer interpretiert. Zum Beispiel würde eine Funktion, die -1 als Int64 zurückgibt, eigentlich 0xFFFFFFFFFFFFFFFF zurückgeben, wenn sie ein UInt64 überhaupt zurückgeben kann.</p></td>
</tr>
</TABLE>
<p><strong>Hinweis</strong>: Wenn man ein Argument- oder Rückgabetyp ohne Leerzeichen oder Sternchen angibt, können die Anführungszeichen weggelassen werden. Zum Beispiel könnte <code>Str</code> anstelle von <code>"Str"</code> und <code>CDecl</code> anstelle von <code>"CDecl"</code> verwendet werden. Darüber hinaus könnte der Buchstabe P anstelle des Sternchens verwendet werden, so dass auch dort die Anführungszeichen weggelassen werden können. Zum Beispiel: <code>UIntP</code>.</p>

<h3 id="error">Fehlerbehandlung</h3>
<p>DllCall löst eine <a href="Catch.htm#RuntimeErrors">Ausnahme</a> unter folgenden Bedingungen aus:</p>
<ul>
  <li>Der <em>[DllDatei\]Funktion</em>-Parameter ist eine Gleitkommazahl. Es wird eine Zeichenkette oder ein positiver Integer benötigt.</li>
  <li>Der <a href="#types">Rückgabetyp</a> oder einer der angegebenen <a href="#types">Argumenttypen</a> ist ungültig. Dieser Fehler kann auch auftreten, wenn ein <a href="../Variables.htm#Expressions">Ausdruck</a>, der eine Zahl errechnet, an ein Zeichenkettenargument (<a href="#str">Str</a>) übergeben wird.</li>
  <li>Die angegebene <em>DllDatei</em> war weder zugreifbar noch konnte sie geladen werden. Wenn ein expliziter Pfad bei <em>DllDatei</em> fehlt, muss sich die Datei auf einen der Pfade aus der PATH-Umgebungsvariable oder <a href="../Variables.htm#WorkingDir">A_WorkingDir</a> befinden. Dieser Fehler kann auch auftreten, wenn dem Benutzer die nötigen Zugriffsrechte für die Datei fehlen, oder wenn AutoHotkey im 32-Bit-Format und die DLL im 64-Bit-Format ist (oder umgekehrt).</li>
  <li>Die angegebene Funktion konnte innerhalb der DLL nicht gefunden werden.</li>
  <li>Eine fatale Ausnahme führte zum Abbruch der Funktion trotz erfolgreichen Aufrufs. <code>Exception.Extra</code> enthält den Ausnahmecode. 0xC0000005 wäre beispielsweise "Zugriffsverletzung". Ausnahmen dieser Art brechen den Thread ab (wenn <a href="Try.htm">try</a> nicht verwendet wird), aber aktualisieren noch die <a href="#asterisk">Sternchenvariablen</a>.uch cases, the thread is aborted Eine fatale Ausnahme wäre beispielsweise die Dereferenzierung eines ungültigen Pointers, wie z. B. NULL. Da eine <a href="#cdecl">Cdecl</a>-Funktion nie den im nächsten Abschnitt erwähnten Fehler erzeugen kann, könnte sie eine Ausnahme generieren, wenn zu wenig Argumente an diese Funktion übergeben werden.</li>
  <li>Der Aufruf der Funktion war erfolgreich, allerdings wurden zu viele oder zu wenig Argumente übergeben. <code>Exception.Extra</code> enthält die Anzahl an Bytes, die in der Argumentenliste zuviel sind oder noch fehlen. Wenn dieser Wert positiv ist, wurden zu viele Argumente (oder zu lange Argumente) übergeben, oder der Aufruf erfordert <a href="#cdecl">CDecl</a>. Wenn dieser Wert negativ ist, wurden zu wenig Argumente übergeben. Dieses Problem sollte behoben werden, um eine zuverlässige Operation der Funktion zu gewährleisten. So ein Fehler könnte auch darauf hindeuten, dass eine Ausnahme aufgetreten ist. Beachte, dass 64-Bit-Builds diesen Fehler aufgrund der x64-Aufrufkonvention nie auslösen können.</li>
</ul>

<h3 id="except">Ausnahmen und A_LastError</h3>
<p>Trotz Built-in-Ausnahmebehandlung ist es möglich, dass ein Skript mit DllCall abstürzt. Dieses Problem kann auftreten, wenn eine Funktion nicht direkt eine Ausnahme erzeugt, sondern etwas Unangebrachtes zurückgibt, wie z. B. ein schlechter Pointer oder eine nicht-terminierte Zeichenkette. Die Funktion ist nicht unbedingt daran Schuld, wenn das Skript ihr einen ungeeigneten Wert übergibt, wie z. B. einen schlechten Pointer oder ein <a href="#str">"Str"</a> mit unzureichender Kapazität. Ein Skript kann auch abstürzen, wenn es einen ungeeigneten Argument- oder Rückgabetyp spezifiziert, z.B. mit der Behauptung, dass ein gewöhnlicher Integer, der von einer Funktion zurückgegeben wurde, eine <a href="#asterisk">Sternchenvariable</a> oder <a href="#str">Str</a> ist.</p>
<p id="LastError">Die Built-in-Variable <strong>A_LastError</strong> enthält den Rückgabewert der Systemfunktion GetLastError(), die sofort nach einem Funktionsaufruf aufgerufen wird (hat keine messbaren Auswirkungen auf die Performance). A_LastError ist eine Nummer zwischen 0 und 4294967295. Wie <a href="../misc/ErrorLevel.htm">ErrorLevel</a> auch, ist A_LastError eine Pro-Thread-Einstellung; das heißt, dass Unterbrechungen durch andere <a href="../misc/Threads.htm">Threads</a> den Wert nicht ändern können. Allerdings wird A_LastError auch von <a href="Run.htm#LastError">Run/RunWait</a> und ein paar anderen internen Funktionen gesetzt.</p>

<h3 id="load">Performance</h3>
<p>Bei wiederholenden Aufrufen einer DLL-Datei kann die Performance erheblich verbessert werden, indem man sie explizit lädt (<em>unnötig bei einer <a href="#std">Standard-DLL</a> wie User32, weil sie dauerhaft im Arbeitsspeicher vorhanden ist</em>). Diese Methode verhindert, dass für DllCall jedesmal LoadLibrary und FreeLibrary intern aufgerufen werden muss. Zum Beispiel:</p>
<pre>hModule := DllCall("<strong>LoadLibrary</strong>", "Str", "MeineFunktionen.dll", "Ptr")  <em>; Verhindert, dass DllCall() die Library in der Schleife laden muss.</em>
Loop Files, "C:\Meine Dokumente\*.*", "R"
    Ergebnis := DllCall("MeineFunktionen\BackupFile", "Str", A_LoopFilePath)
DllCall("<strong>FreeLibrary</strong>", "Ptr", hModule)  <em>; Zum Freigeben des Speichers kann die DLL nach ihrer Verwendung entladen werden.</em></pre>
<p>Man kann eine noch schnellere Performance erreichen, wenn man im Voraus die Adresse der Funktion nachschlägt. Zum Beispiel:</p>
<pre><em>; Das folgende Beispiel zeigt, wie man LoadLibrary anstelle von GetModuleHandle verwenden kann, wenn die DLL noch nicht geladen ist.</em>
<strong>MulDivProc</strong> := DllCall("GetProcAddress", Ptr, DllCall("GetModuleHandle", Str, "<strong>kernel32</strong>", "Ptr"), AStr, "<strong>MulDiv</strong>", "Ptr")
Loop 500
    DllCall(<strong>MulDivProc</strong>, Int, 3, Int, 4, Int, 3)</pre>
<p>Wenn der erste Parameter von DllCall eine direkt geschriebene Zeichenkette wie <code>"MulDiv"</code> ist und die DLL mit der Funktion normal vor dem Skriptstart geladen wurde, wird die Zeichenkette automatisch in eine Funktionsadresse aufgelöst. Diese Built-in-Optimierung ist effektiver als das oben gezeigte Beispiel.</p>
<p>Beim Übergeben einer Zeichenkettenvariable an eine Funktion, die die Länge der Zeichenkette unverändert lässt, kann die Performance verbessert werden, wenn man die Variable <a href="../Variables.htm#amp">per Adresse</a> (z. B. &amp;MeineVar) übergibt und nicht als "<a href="#str">str</a>" (besonders bei einer sehr langen Zeichenkette). Das folgende Beispiel wandelt eine Zeichenkette in Großbuchstaben um: <code>DllCall("CharUpper", <strong>Ptr</strong>, <strong>&amp;</strong>MeineVar, Ptr)</code>.</p>

<h3 id="struct">Strukturen und Arrays</h3>
<p>Eine Struktur ist eine Sammlung von <em>Elementen</em> (Feldern), die nebeneinander im Speicher abgelegt sind. Die meisten Elemente sind für gewöhnlich Integer.</p>
<p>Funktionen, die die Adresse einer Struktur (oder eines Speicher-Block-Arrays) akzeptieren, können aufgerufen werden, wenn man die binären Rohdaten der Struktur in eine normale Variable speichert. Die folgenden Schritte werden in der Regel durchgeführt:</p>
<p>1) Rufe <code><a href="VarSetCapacity.htm">VarSetCapacity</a>(MeineStruktur, 123, 0)</code> auf, um sicherzustellen, dass der Speicherumfang der Zielvariable groß genug für die Struktur ist. Ersetze 123 mit einer Zahl, die mindestens so groß ist wie die Strukturgröße. Die Null im letzten Parameter ist optional; sie initialisiert jedes Element mit einer binären Null, um einen häufigen Aufruf von NumPut im nächsten Schritt zu verhindern.</p>
<p>2) Wenn die Zielfunktion die Werte anfangs in der Struktur verwendet, muss <code><a href="NumPut.htm">NumPut</a>(123, MeineStruktur, 4, "UInt")</code> aufgerufen werden, um jedes Element zu initialisieren, das ungleich 0 sein soll. Ersetze 123 mit dem Integer, der in das Zielelement eingefügt werden soll (oder verwende <code>&amp;Var</code>, um die <a href="../Variables.htm#amp">Adresse</a> einer Variable zu speichern). Ersetze 4 mit dem Offset des Zielelements (siehe Schritt #4, was ein "Offset" ist). Ersetze "UInt" mit dem geeigneten Typ oder lass es weg, falls das Element ein Pointer oder Handle ist.</p>
<p>3) Rufe die Zielfunktion auf, indem man die <a href="../Variables.htm#amp">Adresse</a> von MeineStruktur als UInt- oder Ptr-Argument übergibt. Zum Beispiel: <code>DllCall("MeineDLL\MeineFunktion", Ptr, <strong>&amp;</strong>MeineStruktur)</code>. Die Funktion wird einige Elemente untersuchen und/oder ändern.</p>
<p>4) Verwende <code>MeinInteger := <a href="NumGet.htm">NumGet</a>(MeineStruktur, 4, "UInt")</code>, um beliebige Integer von der Struktur abzurufen. Ersetze 4 mit dem Offset des Zielelements in der Struktur. Das erste Element ist immer bei Offset 0. Das zweite Element ist bei Offset 0 plus die Größe des ersten Elements (in der Regel 4). Elemente nach dem zweiten sind bei dem Offset des vorherigen Feldes plus die Größe des vorherigen Feldes. Die meisten Elemente wie DWORD, INT und <a href="#Int">andere Typen von 32-Bit-Integer</a> haben eine Größe von 4 Bytes. Ersetze "UInt" mit dem geeigneten Typ oder lass es weg, falls das Element ein Pointer oder Handle ist.</p>
<p>Siehe <a href="#ExStruct">Strukturbeispiele</a> für weitere Verwendungsmöglichkeiten.</p>
<h3 id="limits">Bekannte Einschränkungen</h3>
<p>Wenn die <a href="../Variables.htm#amp">Adresse einer Variable</a> (z. B. <code>&amp;MeineVar</code>) an eine Funktion übergeben wird und die Funktion die Länge des Variableninhalts ändert, verhält sich die Variable bei nachfolgender Verwendung nicht mehr korrekt. Dieses Problem kann nur behoben werden, wenn einer der folgenden Punkte durchgeführt wird: 1) Übergebe MeineVar nicht als Ptr/Adresse, sondern als <a href="#str">"Str"</a>-Argument; 2) Rufe <code><a href="VarSetCapacity.htm#neg1">VarSetCapacity(MeineVar, -1)</a></code> auf, um die intern gespeicherte Länge der Variable zu aktualisieren, nachdem DllCall aufgerufen wurde.</p>
<p>Jede binäre Null, die per Funktion in eine Variable gespeichert wurde, versteckt alle Daten, die rechts neben der Null vorkommen; das heißt, dass solche Daten weder zugreifbar sind noch von den meisten internen Funktionen geändert werden können. Allerdings können solche Daten per <a href="../Variables.htm#amp">Adressoperatoren</a>, <a href="NumPut.htm">NumPut</a>/<a href="NumGet.htm">NumGet</a> und DllCall selbst manipuliert werden.</p>
<p>Eine Funktion, die die Adresse von einer der übergebenen Zeichenketten zurückgibt, könnte eine gleiche Zeichenkette zurückgeben, aber auf einer anderen Speicheradresse als erwartet. Zum Beispiel würde der Aufruf von <code>CharLower(CharUpper(MeineVar))</code> in einer Programmiersprache dazu führen, dass der Inhalt von <em>MeineVar</em> in Kleinbuchstaben umgewandelt wird. Macht man aber das gleiche mit DllCall, würde <em>MeineVar</em> nach folgendem Aufruf großgeschrieben sein, weil CharLower eine andere/temporäre Zeichenkette bearbeitet hat, dessen Inhalt identisch zu <em>MeineVar</em> war:</p>
<pre>MeineVar := "ABC"
Ergebnis := DllCall("CharLower", <strong><u>str</u></strong>, DllCall("CharUpper", Str, MeineVar, <strong><u>Str</u></strong>), Str)</pre>
<p>Um dieses Problem zu umgehen, müssen die zwei unterstrichenen "Str"-Werte oben mit Ptr ersetzt werden. Dadurch wird der Rückgabewert von CharUpper als reine Adresse interpretiert, der dann als Integer an CharLower übergeben wird.</p>
<p>Bestimmte Einschränkungen können auftreten, wenn es um Zeichenketten geht. Für weitere Informationen, siehe <a href="../Compat.htm#DllCall">Skript-Kompatibilität</a>.</p>
<h3 id="COM">Component Object Model (COM)</h3>
<p>COM-Objekte, die per VBScript und ähnliche Sprachen zugreifbar sind, kann man üblicherweise auch über AutoHotkey via <a href="ComObjCreate.htm">ComObjCreate</a>, <a href="ComObjGet.htm">ComObjGet</a>, <a href="ComObjActive.htm">ComObjActive</a> und built-interner <a href="../Objects.htm#Usage_Objects">Objekt-Syntax</a> zugreifen.</p>
<p>COM-Objekte, die <a href="https://msdn.microsoft.com/de-de/library/ms221608.aspx">IDispatch</a> nicht unterstützen, können mit DllCall verwendet werden, wenn man die Adresse einer Funktion von der virtuellen Funktionstabelle des Objekt-Interfaces ermittelt. Für weitere Details, siehe <a href="#ExTaskbar">das Beispiel</a> weiter unten.</p>
<p>Der größte Teil von .NET-Framework ist auch über COM und DllCall zugreifbar. Siehe <a href="http://www.autohotkey.com/forum/topic26191.html">http://www.autohotkey.com/forum/topic26191.html</a>.
</p>

<h3>Siehe auch</h3>
<p><a href="../Compat.htm#DllCall">Skript-Kompatibilität</a>, <a href="PostMessage.htm">PostMessage</a>, <a href="OnMessage.htm">OnMessage</a>, <a href="RegisterCallback.htm">RegisterCallback</a>, <a href="Run.htm">Run</a>, <a href="VarSetCapacity.htm">VarSetCapacity</a>, <a href="../Functions.htm">Funktionen</a>, <a href="SysGet.htm">SysGet</a>, <a href="https://msdn.microsoft.com/de-de/library/">MSDN Library</a></p>
<h3>Beispiele</h3>
<pre class="NoIndent"><em>; Beispiel: Ruft die Windows-API-Funktion "MessageBox" auf und meldet, welchen Button der Benutzer gedrückt hat.</em>

WelcherButton := DllCall("MessageBox", "Int", "0", "Str", "Ja oder Nein drücken", "Str", "Titel der Box", "Int", 4)
MsgBox "Du hast den Button #" WelcherButton " gedrückt."</pre>

<pre class="NoIndent"><em>; Beispiel: Ersetzt das Desktop-Hintergrundbild mit der angegebenen Bitmap-Datei (.bmp).</em>

DllCall("SystemParametersInfo", UInt, 0x14, UInt, 0, Str, <i>A_WinDir <strong>.</strong> "\winnt.bmp"</i>, UInt, 2)</pre>

<pre class="NoIndent"><em>; Beispiel: Ruft die API-Funktion "IsWindowVisible" auf, um herauszufinden, ob ein Editor-Fenster sichtbar ist.</em>

DetectHiddenWindows True
if not DllCall("IsWindowVisible", "Ptr", WinExist("Unbenannt - Editor"))  <em>; WinExist gibt HWND zurück.</em>
    MsgBox "Das Fenster ist nicht sichtbar."</pre>

<pre class="NoIndent"><em>; Beispiel: Ruft die API-Funktion wsprintf() auf, um die Zahl 432 bis zu 10 Zeichen mit führenden Nullen zu erweitern (0000000432).</em>

VarSetCapacity(ErweiterteZahl, 20)  <em>; Stellt sicher, dass die Variable groß genug für die neue Zeichenkette ist.</em>
DllCall("wsprintf", "Str", ErweiterteZahl, "Str", "%010d", "Int", 432, "Cdecl")  <em>; Benötigt die Cdecl-Aufrufkonvention.</em>
MsgBox ErweiterteZahl</pre>

<pre class="NoIndent" id="QPC"><em>; Beispiel: Zeigt, wie man mit QueryPerformanceCounter() eine höhere Präzision erreichen kann, als die 10 ms von <a href="../Variables.htm#TickCount">A_TickCount</a>.</em>

DllCall("QueryPerformanceCounter", "Int64*", CounterDavor)
Sleep 1000
DllCall("QueryPerformanceCounter", "Int64*", CounterDanach)
MsgBox "Die Differenz zwischen den Zeiten beträgt " . CounterDanach - CounterDavor</pre>

<pre class="NoIndent"><em>; Beispiel: Ein Hotkey, der vorübergehend die Geschwindigkeit des Mauszeigers verringert, um eine genauere Positionierung zu ermöglichen.
; Halte die F1-Taste, um den Mauszeiger zu verlangsamen. Lass sie los, um die originale Geschwindigkeit wiederherzustellen.</em>

F1::
SPI_GETMOUSESPEED := 0x70
SPI_SETMOUSESPEED := 0x71
<em>; Ermittelt die aktuelle Geschwindigkeit, um sie später wiederherzustellen:</em>
<strong>DllCall</strong>("SystemParametersInfo", UInt, SPI_GETMOUSESPEED, UInt, 0, UIntP, OrigMausTempo, UInt, 0)
<em>; Nun wird die Geschwindigkeit der Maus im vorletzten Parameter verringert (von 1 bis 20, 10 ist Standard):</em>
<strong>DllCall</strong>("SystemParametersInfo", UInt, SPI_SETMOUSESPEED, UInt, 0, Ptr, <strong>3</strong>, UInt, 0)
KeyWait "F1"  <em>; Dies hindert die Auto-Wiederholung der Tastatur daran, DllCall wiederholend aufzurufen.</em>
return

F1 up::<strong>DllCall</strong>("SystemParametersInfo", UInt, 0x71, UInt, 0, Ptr, OrigMausTempo, UInt, 0)  <em>; Stellt die ursprüngliche Geschwindigkeit wieder her.</em></pre>

<pre class="NoIndent"><em>; Beispiel: ; Beispiel: Überwacht das aktive Fenster und zeigt die Position der vertikalen Scrollleiste
; im fokussierten Steuerelement an (in Echzeit).</em>

SetTimer "BeobachteScrollleiste", 100
return

BeobachteScrollleiste:
AktivesFenster := WinExist("A")
if !AktivesFenster  <em>; Kein aktives Fenster.</em>
    return
FokussiertesSteuerelement := ControlGetFocus()  <em>; Alle Parameter weglassen, um das Zuletzt Gefundene Fenster zu benutzen.</em>
if !FokussiertesSteuerelement  <em>; Kein fokussiertes Steuerelement.</em>
    return
<em>; Zeigt die vertikale oder horizontale Position der Scrollleiste in einem ToolTip an:</em>
UnterelementHWND := ControlGetHwnd(FokussiertesSteuerelement)
ToolTip(<strong>DllCall</strong>("GetScrollPos", "Ptr", UnterelementHWND, "Int", 1))  <em>;  Letzter Parameter kann 1 für SB_VERT und 0 für SB_HORZ sein.</em>
return</pre>

<pre class="NoIndent" id="file"><em>; Beispiel: ; Beispiel: Dieses Skript schreibt etwas Text in eine Datei und liest ihn wieder in den Speicher.
; Diese Methode schont die Performance beim Lesen oder Schreiben von mehrere Dateien gleichzeitig.
; Alternativ kann das gleiche mit <a href="FileOpen.htm">FileOpen</a> erreicht werden. Siehe dazu das <a href="FileOpen.htm#writeread">Beispiel</a>.</em>

Dateiname := FileSelect("S16",, "Neue Datei erstellen:")
if Dateiname = ""
    return
GENERIC_WRITE := 0x40000000  <em>; Öffnet eine Datei zum Schreiben.</em>
CREATE_ALWAYS := 2  <em>; Erstellt eine neue Datei (überschreibt eine vorhandene Datei).</em>
hFile := <strong>DllCall</strong>("CreateFile", Str, Dateiname, UInt, GENERIC_WRITE, UInt, 0, Ptr, 0, UInt, CREATE_ALWAYS, UInt, 0, Ptr, 0, Ptr)
if !hFile
{
    MsgBox "Kann '" Dateiname "' nicht zum Schreiben öffnen."
    return
}
TestZeichenkette := "Das ist eine Zeichenkette.`r`n"  <em>; Wenn eine Datei auf diese Weise geschrieben wird, sollte `r`n anstelle von `n verwendet werden, um eine neue Zeile zu beginnen.</em>
<strong>DllCall</strong>("WriteFile", Ptr, hFile, Str, TestZeichenkette, UInt, StrLen(TestZeichenkette), UIntP, AktuellGeschriebeneBytes, Ptr, 0)
<strong>DllCall</strong>("CloseHandle", Ptr, hFile)  <em>; Schließt die Datei.</em>

<em>; Nachdem die Datei geschrieben wurde, soll deren Inhalt zurück in den Speicher gelesen werden.</em>
GENERIC_READ := 0x80000000  <em>; Öffnet die Datei zum Lesen.</em>
OPEN_EXISTING := 3  <em>; Datei muss existieren, bevor sie geöffnet werden kann.</em>
FILE_SHARE_READ := 0x1 <em>; Diese und die nächste Variable bestimmen, ob andere Prozesse die Datei öffnen können.</em>
FILE_SHARE_WRITE := 0x2
hFile := <strong>DllCall</strong>("CreateFile", Str, Dateiname, UInt, GENERIC_READ, UInt, FILE_SHARE_READ|FILE_SHARE_WRITE, Ptr, 0, UInt, OPEN_EXISTING, UInt, 0, Ptr, 0)
if !hFile
{
    MsgBox "Kann '" Dateiname "' nicht zum Lesen öffnen."
    return
}
<em>; Macht die Variable für weitere Testzwecke leer, aber stellt sicher, das genügend Kapazität zur Verfügung steht:</em>
ZuLesendeBytes := VarSetCapacity(TestZeichenkette, StrLen(TestZeichenkette))
<strong>DllCall</strong>("ReadFile", Ptr, hFile, Str, TestZeichenkette, UInt, ZuLesendeBytes, UIntP, AktuellGeleseneBytes, Ptr, 0)
<strong>DllCall</strong>("CloseHandle", Ptr, hFile)  <em>; Schließt die Datei.</em>
MsgBox "Die folgende Zeichenkette wurde aus der Datei gelesen: " TestZeichenkette</pre>

<pre class="NoIndent" id="HideCursor"><em>; Beispiel: Versteckt den Mauszeiger, wenn man WIN+C drückt. Um den Mauszeiger wieder sichtbar zu machen, drücke nochmals WIN+C.</em>

OnExit(Func("SystemCursor").bind("Show"))  <em>; Stellt sicher, dass der Mauszeiger beim Beenden des Skripts wieder sichtbar gemacht wird.</em>

#c::SystemCursor("Toggle")  <em>; WIN+C, um Mauszeiger ein- und auszuschalten.</em>

SystemCursor(cmd)  <em>; cmd = "Show|Hide|Toggle"</em>
{
  static vision := true, c := {}
  static system_cursors := "32512,32513,32514,32515,32516,32642,32643,32644,32645,32646,32648,32649,32650"
  VarSetCapacity(h_cursor, 4444, 1)
  if (cmd = "Reload" or !c.Length())  <em>; Neuladen, wenn benötigt oder erster Aufruf.</em>
  {
    VarSetCapacity(AndMask, 32*4, 0xFF)
    VarSetCapacity(XorMask, 32*4, 0)
    For i, resID in StrSplit(system_cursors, ",")
    {
      h_cursor := DllCall("LoadCursor", Ptr, 0, Ptr, resID)
      <em>; System-Mauszeiger:</em>
      c[i] := {r: resID}
      <em>; Handles von Standardzeigern:</em>
      c[i][1] := DllCall("CopyImage", Ptr, h_cursor, UInt, 2, Int, 0, Int, 0, UInt, 0)
      <em>; Leere Mauszeiger:</em>
      c[i][0] := DllCall("CreateCursor", Ptr, 0, Int, 0, Int, 0, Int, 32, Int, 32, Ptr, &amp;AndMask, Ptr, &amp;XorMask)
    }
  }
  if (cmd = "Show")
    vision := true
  else if (cmd = "Hide")
    vision := false
  else if (cmd = "Toggle")
    vision := !vision
  else
    return
  For i, cursor in c
  {
    h_cursor := DllCall("CopyImage", Ptr, cursor[vision], UInt, 2, Int, 0, Int, 0, UInt, 0)
    DllCall("SetSystemCursor", Ptr, h_cursor, UInt, cursor.r)
  }
}</pre>

<pre class="NoIndent" id="ExStruct"><em>; Struktur-Beispiel: Übergibt die Adresse einer RECT-Struktur an GetWindowRect(), das die
; Strukturelemente auf die Positionen der linken, oberen,
; rechten und unteren Seite des Fensters setzt (bezogen auf dem Bildschirm).</em>

Run "Notepad"
WinWait "Unbenannt - Editor"  <em>; Setzt auch das "<a href="../misc/WinTitle.htm#LastFoundWindow">zuletzt gefundene Fenster</a>" für das untere WinExist.</em>
VarSetCapacity(Rect, 16)  <em>; RECT ist eine Struktur, bestehend aus vier 32-Bit-Integern (also 4 * 4 = 16).</em>
<strong>DllCall</strong>("GetWindowRect", Ptr, WinExist(), Ptr, &amp;Rect)  <em>; WinExist gibt HWND zurück.</em>
L := NumGet(Rect, 0, "Int"), O := NumGet(Rect, 4, "Int")
R := NumGet(Rect, 8, "Int"), U := NumGet(Rect, 12, "Int")
MsgBox Format("Links {1} Oben {2} Rechts {3} Unten {4}", L, O, R, U)</pre>

<pre class="NoIndent"><em>; Struktur-Beispiel: Übergibt die Adresse einer RECT-Struktur an FillRect(), um den
; Bildschirm kurzzeitig rot zu färben.</em>

VarSetCapacity(Rect, 16, 0)  <em>; Setzt die Kapazität zum Speichern von vier 4-Byte-Integern und initialisiert sie alle mit Null.</em>
<a href="NumPut.htm">NumPut</a>(A_ScreenWidth//2, Rect, 8, "Int")  <em>; Der dritte Integer in der Struktur ist "rect.right".</em>
NumPut(A_ScreenHeight//2, Rect, 12, "Int") <em>; Der vierte Integer in der Struktur ist "rect.bottom".</em>
hDC := <strong>DllCall</strong>("GetDC", "Ptr", 0, "Ptr")  <em>; Übergibt 0, um den Gerätekontext vom Desktop zu ermitteln.</em>
hBrush := <strong>DllCall</strong>("CreateSolidBrush", "UInt", 0x0000FF, "Ptr")  <em>; Erstellt einen roten Pinsel (0x0000FF ist im BGR-Format).</em>
<strong>DllCall</strong>("FillRect", "Ptr", hDC, "Ptr", &amp;Rect, "Ptr", hBrush)  <em>; Füllt das angegebene Rechteck mithilfe des oberen Pinsels.</em>
<strong>DllCall</strong>("ReleaseDC", "Ptr", 0, "Ptr", hDC)  <em>; Gibt Speicher frei.</em>
<strong>DllCall</strong>("DeleteObject", "Ptr", hBrush)  <em>; Gibt Speicher frei.</em></pre>

<pre class="NoIndent"><em>; Struktur-Beispiel: Ändert Datum und Zeit der Systemuhr. Aber sei gewarnt:
; Sobald die Uhr auf ein zukünftiges Datum gesetzt wird, kann es passieren, dass geplante Tasks vorzeitig ausgeführt werden!</em>

SetzeSystemzeit("20051008142211")  <em>; <a href="FileSetTime.htm#YYYYMMDD">Zeitstempel</a> übergeben (lokal, nicht UTC).</em>

SetzeSystemzeit(YYYYMMDDHHMISS)
<em>; Setzt die Systemzeit auf das angegebene Datum und Zeit.
; Der Aufrufer muss sicherstellen, dass der eingehende Parameter ein gültiger Zeitstempel ist
; (lokale Zeit, nicht UTC). Bei Erfolg wird eine Zahl ungleich 0 zurückgegeben.</em>
{
    <em>; Konvertiert für SetzeSystemzeit() den Parameter von lokale Zeit in UTC.</em>
    UTC_Delta := DateDiff(A_Now, A_NowUTC, "Seconds")  <em>; Sekunden sind aufgrund des Rundungsproblems genauer.</em>
    UTC_Delta := Round(-UTC_Delta/60)  <em>; Rundet auf die nächste Minute.</em>
    YYYYMMDDHHMISS := DateAdd(YYYYMMDDHHMISS, UTC_Delta, "Minutes")  <em>; Wendet Offset zum Konvertieren auf UTC an.</em>

    VarSetCapacity(Systemzeit, 16, 0)  <em>; Diese Struktur besteht aus 8 UShort-Werte (d. h. 8 * 2 = 16).</em>

    Int := SubStr(YYYYMMDDHHMISS, 1, 4)  <em>; YYYY (Jahr)</em>
    <a href="NumPut.htm">NumPut</a>(Int, Systemzeit, 0, "UShort")
    Int := SubStr(YYYYMMDDHHMISS, 5, 2)  <em>; MM (Monat des Jahres, 1-12)</em>
    NumPut(Int, Systemzeit, 2, "UShort")
    Int := SubStr(YYYYMMDDHHMISS, 7, 2)  <em>; DD (Tag des Monats)</em>
    NumPut(Int, Systemzeit, 6, "UShort")
    Int := SubStr(YYYYMMDDHHMISS, 9, 2)  <em>; HH (Stunden im 24-Stunden-Format)</em>
    NumPut(Int, Systemzeit, 8, "UShort")
    Int := SubStr(YYYYMMDDHHMISS, 11, 2) <em>; MI (Minuten)</em>
    NumPut(Int, Systemzeit, 10, "UShort")
    Int := SubStr(YYYYMMDDHHMISS, 13, 2) <em>; SS (Sekunden)</em>
    NumPut(Int, Systemzeit, 12, "UShort")

    return <strong>DllCall</strong>("SetSystemTime", Ptr, &amp;Systemzeit)
}</pre>

<pre class="NoIndent"><em>/* <strong>Weitere Struktur-Befehle:</strong>

1) Im <a href="../scripts/WinLIRC.htm">WinLIRC-Client-Skript</a> wird gezeigt, wie man mit DllCall eine Netzwerkverbindung zu einem TCP/IP-Server aufbauen und Daten von ihm empfangen kann.

2) Das Betriebssystem besitzt Standard-Fensterdialoge zum Auswählen von Farben, Schriftarten oder Symbole.
Solche Fensterdialoge verwenden Strukturen und werden auf <a href="http://www.autohotkey.com/forum/topic17230.html">www.autohotkey.com/forum/topic17230.html</a> gezeigt.

*/</em></pre>

<pre id="ExTaskbar" class="NoIndent"><em>/*
  Beispiel: Entfernt mithilfe von COM vorübergehend das aktive Fenster aus der Taskleiste.

  Methoden in der VTable der <a href="https://msdn.microsoft.com/de-de/library/bb774652.aspx">ITaskbarList</a>:
    IUnknown:
      0 QueryInterface  -- verwende stattdessen <a href="ComObjQuery.htm">ComObjQuery</a>
      1 AddRef          -- verwende stattdessen <a href="ObjAddRef.htm">ObjAddRef</a>
      2 Release         -- verwende stattdessen <a href="ObjAddRef.htm">ObjRelease</a>
    ITaskbarList:
      3 HrInit
      4 AddTab
      5 DeleteTab
      6 ActivateTab
      7 SetActiveAlt
*/</em>
IID_ITaskbarList  := "{56FDF342-FD6D-11d0-958A-006097C9A090}"
CLSID_TaskbarList := "{56FDF344-FD6D-11d0-958A-006097C9A090}"

<em>; Erstellt ein TaskbarList-Objekt und speichert dessen Adresse in tbl.</em>
tbl := <a href="ComObjCreate.htm">ComObjCreate</a>(CLSID_TaskbarList, IID_ITaskbarList)

activeHwnd := WinExist("A")

DllCall(vtable(tbl,3), "ptr", tbl)                     <em>; tbl.<a href="https://msdn.microsoft.com/de-de/library/bb774650.aspx">HrInit</a>()</em>
DllCall(vtable(tbl,5), "ptr", tbl, "ptr", activeHwnd)  <em>; tbl.<a href="https://msdn.microsoft.com/de-de/library/bb774648.aspx">DeleteTab</a>(activeHwnd)</em>
Sleep 3000
DllCall(vtable(tbl,4), "ptr", tbl, "ptr", activeHwnd)  <em>; tbl.<a href="https://msdn.microsoft.com/de-de/library/bb774646.aspx">AddTab</a>(activeHwnd)</em>

<em>; Nicht-Dispatch-Objekte müssen immer manuell freigegeben werden.</em>
ObjRelease(tbl)

vtable(ptr, n) {
    <em>; NumGet(ptr+0) gibt die Adresse der virtuellen Funktionstabelle
    ; des Objekts zurück (kurz: vtable). Der Rest des Ausdrucks ermittelt
    ; die Adresse der n-ten Funktionsadresse von der vtable.</em>
    return NumGet(NumGet(ptr+0), n*A_PtrSize)
}
</pre>

</body>
</html>
