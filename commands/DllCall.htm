<!DOCTYPE HTML>
<html lang="de">
<head>
<title>DllCall - Syntax &amp; Verwendung | AutoHotkey v2</title>
<meta name="description" content="Die DllCall-Funktion ruft eine Funktion aus einer DLL-Datei auf, wie z. B. eine API-Funktion von Windows." />
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="robots" content="noindex, nofollow">
<link href="../static/theme.css" rel="stylesheet" type="text/css" />
<script src="../static/content.js" type="text/javascript"></script>
<script src="../static/ga.js" type="text/javascript"></script>
</head>
<body>

<h1>DllCall</h1>

<p>Ruft eine Funktion aus einer DLL-Datei auf, wie z. B. eine API-Funktion von Windows.</p>

<pre class="Syntax">Ergebnis := <span class="func">DllCall</span>("<span class="optional">DllDatei\</span>Funktion" <span class="optional">, Typ1, Arg1, Typ2, Arg2, "Cdecl Rückgabetyp"</span>)</pre>
<h2>Parameter</h2>
<dl>

  <dt>[DllDatei\]Funktion</dt>
  <dd><p>Der Name einer DLL- oder EXE-Datei, gefolgt von einem umgekehrten Schrägstrich und dem Namen der Funktion. Zum Beispiel: <code>"MeineDLL\MeineFunktion"</code> (standardmäßig gilt die Dateierweiterung ".dll", wenn sie weggelassen wird). Wenn kein absoluter Pfad angegeben ist, wird <em>DllDatei</em> in einem der Pfade aus der PATH-Umgebungsvariable oder im <a href="../Variables.htm#WorkingDir">A_WorkingDir</a>-Verzeichnis vermutet.</p>
      <p id="std"><em>DllDatei</em> kann weggelassen werden, wenn eine Funktion aus der User32.dll, Kernel32.dll, ComCtl32.dll oder Gdi32.dll aufgerufen wird. Zum Beispiel würde <code>"User32\IsWindowVisible"</code> das gleiche Ergebnis liefern wie <code>"IsWindowVisible"</code>.</p>
      <p>Wenn eine Funktion nicht über den angegebenen Namen gefunden werden kann, wird automatisch ein W (Unicode) angefügt. Zum Beispiel wäre <code>"MessageBox"</code>  das gleiche wie <code>"MessageBoxW"</code>.</p>
      <p>Um die Performance beim <em>wiederholenden</em> Aufrufen einer DLL-Datei drastisch zu verbessern, <a href="#load">lädt man sie im Voraus</a>.</p>
      <p>Dieser Parameter kann auch ein reiner Integer sein, der als Adresse einer Funktion, die aufgerufen werden soll, interpretiert wird. Quellen solcher Adressen sind unter anderem <a href="#COM">COM</a> und <a href="CallbackCreate.htm">CallbackCreate</a>.</p></dd>

  <dt>Typ1, Arg1</dt>
  <dd><p>Jedes dieser Paare repräsentiert einen einzelnen Parameter, der an die Funktion übergeben werden soll. Die Anzahl der Paare ist unbegrenzt. Geben Sie für <em>Typ</em> einen Typ aus der unteren <a href="#types">Typentabelle</a> an. Geben Sie für <em>Arg</em> einen Wert an, der an die Funktion übergeben werden soll.</p></dd>

  <dt>Cdecl Rückgabetyp</dt>
  <dd><p id="cdecl">Das Wort <em>Cdecl</em> wird normalerweise weggelassen, weil die meisten Funktionen auf die Standard-Aufrufkonvention statt C-Aufrufkonvention zurückgreifen (Funktionen wie wsprintf, die eine unterschiedliche Anzahl von Argumenten akzeptieren, sind so eine Ausnahme). Beachten Sie, dass die meisten objektorientierten C++-Funktionen die <i>thiscall</i>-Konvention nutzen, die in AutoHotkey nicht unterstützt wird.</p>
      <p>Das Wort <em>Cdecl</em> sollte vor dem Rückgabetyp (falls vorhanden) stehen. Trennen Sie alle Wörter jeweils mit einem Leer- oder Tabulatorzeichen. Zum Beispiel: <code>"Cdecl Str"</code>.</p>
      <p>In der 64-Bit-Version von AutoHotkey kann <i>Cdecl</i> zwar angegeben werden, aber bleibt wirkungslos, weil 64-Bit-Code keine separate C-Aufrufkonvention hat.</p>
      <p><em>Rückgabetyp</em>: Wenn die Funktion einen vorzeichenfähigen 32-Bit-Integer (Int), BOOL oder nichts zurückgibt, kann <em>Rückgabetyp</em> weggelassen werden. Ansonsten können Sie einen Argumenttyp aus der <a href="#types">Typentabelle</a> angeben. Das <a href="#asterisk">Sternchen-Suffix</a> wird ebenfalls unterstützt.</p></dd>

</dl>

<h2>Rückgabewert</h2>
<p>Typ: <a href="../Concepts.htm#strings">Zeichenkette</a> oder <a href="../Concepts.htm#numbers">Integer</a></p>
<p>DllCall gibt den aktuellen Rückgabewert von <em>Funktion</em> zurück. Wenn <em>Funktion</em> keinen Rückgabewert unterstützt, ist das Ergebnis ein undefinierter Integer.</p>

<h2 id="types">Argumenttypen und Rückgabewerte</h2>
<table class="info">
<tr id="str">
<td>Str</td>
<td><p>Eine Zeichenkette wie "Blau" oder MeineVar. Wenn die aufgerufene Funktion die Zeichenkette ändert und das Argument eine reine Variable ist, wird der Inhalt der Variable aktualisiert. Der folgende Aufruf würde z. B. den Inhalt von <em>MeineVar</em> in Großbuchstaben umwandeln: <code>DllCall("CharUpper", "Str", <i>MeineVar</i>)</code>.</p>
  <p>Wenn die Funktion jedoch darauf ausgelegt ist, eine Zeichenkette zu speichern, die größer als die aktuelle Kapazität einer Variable ist, müssen Sie vor dem Funktionsaufruf sicherstellen, dass die Variable groß genug ist. Um das zu erreichen, ruft man <code><a href="VarSetCapacity.htm">VarSetCapacity</a>(MeineVar, 123)</code> auf, dabei ist 123 die Länge, die <em>MeineVar</em> maximal enthalten soll.</p>
  <p>Ein <em>Str</em>-Argument darf kein <a href="../Variables.htm#Expressions">Ausdruck</a> sein, der eine Zahl ergibt (z. B. <code>i+1</code>). Ist dies der Fall, wird die Funktion nicht aufgerufen und eine <a href="Catch.htm#RuntimeErrors">Ausnahme</a> ausgelöst.</p>
  <p>Die <a href="#asterisk">Sternchenvariable</a> "Str*" wird zwar unterstützt, aber nur selten eingesetzt. Diese Variable kann in Verbindung mit Funktionen genutzt werden, die so etwas wie "TCHAR **" oder "LPTSTR *" erwarten.</p>
  <p class="note"><strong>Hinweis</strong>: Wenn Sie eine Zeichenkette an eine Funktion übergeben, müssen Sie darauf achten, welchen <a href="../Compat.htm#DllCall"><i>Typ</i> von Zeichenkette</a> die Funktion erwartet.</p></td>
</tr>
<tr>
  <td><span id="wstr"></span>WStr</td>
  <td>Da AutoHotkey standardmäßig UTF-16 verwendet, ist WStr (Wide Character String) das Äquivalent zu Str.</td>
</tr>
<tr>
  <td><span id="astr"></span>AStr</td>
  <td>
    <p>AStr bewirkt, dass der Eingabewert automatisch in ANSI umgewandelt wird. Da der zum Konvertieren benutzte temporäre Speicher nur Platz für die umgewandelte Eingabezeichenkette gewährleisten kann, wird die Funktion zuvor den aktuellen Speicherinhalt verwerfen. Das folgende Beispiel zeigt, wie eine ANSI-Zeichenkette als Ausgabeparameter abgerufen werden kann:</p>
<pre>VarSetCapacity(Puffer, <i>Länge</i>)  <em>; Ordnet temporären Puffer zu.</em>
DllCall("<i>Function</i>", "ptr", &amp;Puffer)  <em>; Übergibt Puffer an Function.</em>
str := StrGet(&amp;Puffer, "cp0")  <em>; Ermittelt ANSI-Zeichenkette vom Puffer.</em>
</pre>
    <p>Unter <a href="../Compat.htm#DllCall">Skript-Kompatibilität</a> finden Sie gleichwertige Win32-Typen und weitere Details.</p>
  </td>
</tr>
<tr>
  <td>Int64</td>
  <td>Ein 64-Bit-Integer im Zahlenbereich von -9223372036854775808 (-0x8000000000000000) bis 9223372036854775807 (0x7FFFFFFFFFFFFFFF).</td>
</tr>
<tr id="Int">
  <td>Int</td>
  <td><p>Ein 32-Bit-Integer (meistgenutzter Integer-Typ) im Zahlenbereich von -2147483648 (-0x80000000) bis 2147483647 (0x7FFFFFFF). Ein Int wird manchmal auch als "Long" bezeichnet.</p>
    <p>Ein Int sollte auch genutzt werden, wenn die Funktion ein BOOL-Argument erwartet (ein BOOL-Wert sollte entweder 1 oder 0 sein).</p>
    <p>Ein <a href="#unsigned">vorzeichenloser</a> (unsigned) Integer (UInt) wird auch ziemlich oft genutzt, z. B. für DWORD.</p></td>
</tr>
<tr>
  <td>Short</td>
  <td>Ein 16-Bit-Integer im Zahlenbereich von -32768 (-0x8000) bis 32767 (0x7FFF). Ein <a href="#unsigned">vorzeichenloser</a> 16-Bit-Integer (UShort) kann bei Funktionen verwendet werden, die ein DWORD erwarten.</td>
</tr>
<tr>
  <td>Char</td>
  <td>Ein 8-Bit-Integer im Zahlenbereich von -128 (-0x80) bis 127 (0x7F). Ein <a href="#unsigned">vorzeichenloser</a> 8-Bit-Integer (UChar) kann bei Funktionen verwendet werden, die ein BYTE erwarten.</td>
</tr>
<tr>
  <td>Float</td>
  <td>Eine 32-Bit-Gleitkommazahl mit maximal 6 Stellen nach dem Komma.</td>
</tr>
<tr>
  <td>Double</td>
  <td>Eine 64-Bit-Gleitkommazahl mit maximal 15 Stellen nach dem Komma.</td>
</tr>
<tr id="ptr">
  <td>Ptr</td>
  <td><p>Ein <a href="../Variables.htm#PtrSize">pointer-großer</a> Integer, der je nach Dateiformat der skript-ausführenden EXE-Datei (32- oder 64-Bit) einem Int oder Int64 entspricht. <i>Ptr</i> sollte für Pointer verwendet werden, die auf Arrays oder Strukturen (wie RECT* oder LPPOINT) verweisen, und für fast alle Handles (wie HWND, HBRUSH oder HBITMAP). Handelt es sich bei dem Parameter um einen Pointer, der auf einen einzelnen numerischen Wert wie LPDWORD oder int* verweist, sollte grundsätzlich das Suffix * oder P anstelle von "Ptr" verwendet werden.</p>
  <p><i>Ptr</i> kann auch mit dem Suffix * oder P kombiniert werden; diese Kombination sollte nur bei Funktionen verwendet werden, die einen Pointer über LPVOID* oder Ähnliches zurückgeben.</p>
  <p><i>UPtr</i> ist ebenfalls gültig, aber nur in einem 32-Bit-Build, da AutoHotkey keine vorzeichenlose 64-Bit-Integer unterstützt.</p>
  <p>Wenn Ihr Skript mit älteren Versionen von AutoHotkey kompatibel sein muss, können Sie wie folgt einen Variablentyp nutzen:</p>
  <pre>Ptr := A_PtrSize ? "Ptr" : "UInt" <em>; Wenn A_PtrSize nicht definiert ist, gilt stattdessen UInt.</em>
DllCall("DeleteFile", Ptr, &amp;Dateiname) <em>; Lassen Sie die Anführungszeichen bei Ptr weg.</em></pre>
  <p class="note"><strong>Hinweis</strong>: Um einen <strong>NULL</strong>-Handle oder -Pointer zu übergeben, übergibt man den Integer 0.</p></td>
</tr>
<tr id="asterisk">
  <td>* oder P<br>
    (Suffix)</td>
  <td><p>Fügen Sie vor einem Sternchen (optional mit einem Leerzeichen davor) einen der oben genannten Typen an, wenn nicht der Wert selbst, sondern die Adresse des Arguments übergeben werden soll (die aufgerufene Funktion muss so konstruiert sein, dass sie so etwas akzeptieren kann). Die Funktion kann direkt auf den Wert von so einem Argument zugreifen; wenn man eine reine Variable als Argument übergibt, wird der Inhalt dieser Variable aktualisiert. Der folgende Aufruf würde z. B. den Inhalt von MeineVar via Adresse an MeineFunktion übergeben, aber auch den Inhalt von MeineVar aktualisieren, um alle Änderungen widerzuspiegeln, die MeineFunktion an MeineVar vorgenommen hat: <code>DllCall("MeineDLL\MeineFunktion", "Int*", MeineVar)</code>.</p>
    <p>In der Regel nutzt man ein Sternchen, wenn der Argument- oder Rückgabetyp einer Funktion mit "LP" beginnt. Das bekannteste Beispiel dafür ist LPDWORD - ein Pointer, der auf ein DWORD verweist. DWORD ist ein vorzeichenloser 32-Bit-Integer, demzufolge gibt man "UInt*" oder "UIntP" an, um LPDWORD zu erhalten. Zeichenkettentypen wie LPTSTR, auf Strukturen verweisende Pointer wie LPRECT, oder Arrays sollten nicht mit einem Sternchen versehen werden; für solche Typen ist <a href="#str">"Str"</a> oder "Ptr" besser geeignet, je nachdem, ob Sie eine Variable oder ihre Adresse übergeben wollen.</p>
    <p class="note"><strong>Hinweis</strong>: "Char*" ist nicht das gleiche wie <a href="#str">"Str"</a>. Das ist deshalb so, weil "Char*" die Adresse einer 8-Bit-Zahl übergibt, während <a href="#str">"Str"</a> die Adresse einer Reihe von Zeichen übergibt, die je nach AutoHotkey-Version 16-Bit (Unicode) oder 8-Bit (für "AStr") groß sind. So ähnlich verhält es sich mit "UInt*", das die Adresse einer 32-Bit-Zahl übergibt: Dieser Typ ist nicht für eine Funktion geeinigt, die ein Array mit Werten oder eine Struktur größer als 32 Bit erwartet.</p>
    <p>Da die Variablen in AutoHotkey keinen festen Typ haben, verweist die Adresse, die an die Funktion übergeben wurde, nicht auf die Variable selbst, sondern auf einen temporären Speicher. Es ist nicht notwendig, <a href="VarSetCapacity.htm">VarSetCapacity</a> auf die Variable anzuwenden, weil DllCall sie nach dem Durchführen der Funktion korrekt aktualisieren wird.</p>
    </td>
</tr>
<tr id="unsigned">
  <td>U (Präfix)</td>
  <td><p>Fügen Sie nach dem Buchstaben U einen der oben genannten Integer-Typen an, wenn der Typ als vorzeichenloser Integer (UInt64, Uint, UShort und UChar) interpretiert werden soll. Streng genommen ist das nur für Rückgabewerte und <a href="#asterisk">Sternchenvariablen</a> notwendig, da es keine Rolle spielt, ob ein Argument, der als Wert übergeben wurde, vorzeichenfähig oder vorzeichenlos ist (außer für Int64).</p>
    <p>Wenn Sie für ein vorzeichenloses Argument einen negativen Integer angeben, wechselt der Integer in den vorzeichenlosen Bereich. Wenn Sie beispielsweise vorhaben, -1 als UInt zu senden, würde es zu 0xFFFFFFFF werden.</p>
    <p><em>Vorzeichenlose</em> 64-Bit-Integer, die eine Funktion erzeugt, werden nicht unterstützt. Um daher mit Zahlen zu hantieren, die größer gleich 0x8000000000000000 sind, lässt man das U-Präfix weg und interpretiert jeden negativen Wert, den die Funktion zurückgibt, als großen Integer. Zum Beispiel würde eine Funktion, die -1 als Int64 zurückgibt, eigentlich 0xFFFFFFFFFFFFFFFF zurückgeben, wenn sie ein UInt64 überhaupt zurückgeben kann.</p></td>
</tr>
</table>
<p class="note"><strong>Hinweis</strong>: Wenn man ein Argument- oder Rückgabetyp ohne Leerzeichen oder Sternchen angibt, können die Anführungszeichen weggelassen werden. Zum Beispiel kann <code>Str</code> anstelle von <code>"Str"</code> und <code>CDecl</code> anstelle von <code>"CDecl"</code> verwendet werden. Wenn der Buchstabe P anstelle des Sternchens verwendet wird, können die Anführungszeichen auch weggelassen werden. Zum Beispiel: <code>UIntP</code>.</p>

<h2 id="error">Fehler</h2>
<p>DllCall löst eine <a href="Catch.htm#RuntimeErrors">Ausnahme</a> unter folgenden Bedingungen aus:</p>
<ul>
  <li>Der <em>[DllDatei\]Funktion</em>-Parameter ist eine Gleitkommazahl. Es wird eine Zeichenkette oder ein positiver Integer benötigt.</li>
  <li>Der <a href="#types">Rückgabetyp</a> oder einer der angegebenen <a href="#types">Argumenttypen</a> ist ungültig. Dieser Fehler kann auch auftreten, wenn ein <a href="../Variables.htm#Expressions">Ausdruck</a>, der eine Zahl ergibt, an ein Argument übergeben wird, das als Zeichenkette (<a href="#str">Str</a>) typisiert ist.</li>
  <li>Die angegebene <em>DllDatei</em> konnte weder zugegriffen noch geladen werden. Wenn kein expliziter Pfad für <em>DllDatei</em> angegeben wurde, muss die Datei in einem der Pfade aus der PATH-Umgebungsvariable oder im <a href="../Variables.htm#WorkingDir">A_WorkingDir</a>-Verzeichnis vorhanden sein. Dieser Fehler kann auch auftreten, wenn der Benutzer keine Zugriffsrechte für die Datei hat, oder wenn AutoHotkey im 32-Bit-Format und die DLL im 64-Bit-Format ist (oder umgekehrt).</li>
  <li>Die angegebene Funktion konnte innerhalb der DLL nicht gefunden werden.</li>
  <li>Eine fatale Ausnahme führte zum Abbruch der Funktion trotz erfolgreichen Aufrufs. <code>Exception.Extra</code> enthält den Ausnahmecode. 0xC0000005 wäre beispielsweise "Zugriffsverletzung". In solchen Fällen wird der Thread unterbrochen (wenn <a href="Try.htm">try</a> nicht verwendet wird), allerdings wird jede <a href="#asterisk">Sternchenvariablen</a> immer noch aktualisiert. Eine fatale Ausnahme wäre beispielsweise die Dereferenzierung eines ungültigen Pointers wie NULL (0). Aufgrund der Tatsache, dass eine <a href="#cdecl">Cdecl</a>-Funktion nie den im nächsten Abschnitt erwähnten Fehler erzeugen kann, löst sie stattdessen eine Ausnahme aus, wenn ihr zu wenig Argumente übergeben wurde.</li>
  <li>Der Aufruf der Funktion war erfolgreich, allerdings wurden zu viele oder zu wenig Argumente übergeben. <code>Exception.Extra</code> enthält die Anzahl, um wie viel Bytes die Argumentenliste falsch war. Wenn dieser Wert positiv ist, wurden zu viele Argumente (oder zu lange Argumente) übergeben, oder der Aufruf erfordert <a href="#cdecl">CDecl</a>. Wenn dieser Wert negativ ist, wurden zu wenig Argumente übergeben. Um eine zuverlässige Operation der Funktion zu gewährleisten, muss dieses Problem behoben werden. So ein Fehler könnte auch darauf hindeuten, dass eine Ausnahme aufgetreten ist. Beachten Sie, dass 64-Bit-Builds diesen Fehler aufgrund der x64-Aufrufkonvention nie auslösen können.</li>
</ul>

<h2 id="except">Ausnahmen und A_LastError</h2>
<p>Trotz der internen Ausnahmebehandlung ist es immer noch möglich, dass DllCall ein Skript zum Absturz bringen kann. Dieses Problem kann auftreten, wenn eine Funktion etwas Unangebrachtes zurückgibt, wie z. B. einen fehlerhaften Pointer oder eine nicht-terminierte Zeichenkette, statt eine Ausnahme auszulösen. Die Ursache dafür muss nicht immer die Funktion selbst sein. Auch das Skript könnte ihr einen ungeeigneten Wert (z. B. einen fehlerhaften Pointer oder ein <a href="#str">"Str"</a> mit unzureichender Kapazität) übergeben. Ein Skript kann auch abstürzen, wenn man einen ungeeigneten Argument- oder Rückgabetyp angegeben hat, z. B. wenn man einen gewöhnlichen Integer, den eine Funktion zurückgibt, als <a href="#asterisk">Sternchenvariable</a> oder <a href="#str">Str</a> typisiert.</p>
<p>Die interne Variable <a href="../Variables.htm#LastError">A_LastError</a> enthält das Ergebnis der Systemfunktion GetLastError().</p>

<h2 id="load">Performance</h2>
<p>Um die Performance beim wiederholenden Aufrufen einer DLL-Datei drastisch zu verbessern, kann man sie im Voraus laden (<em>das ist für eine <a href="#std">Standard-DLL</a> wie User32 nicht notwendig, da sie immer im Speicher vorhanden ist</em>). Diese Vorgehensweise verhindert, dass DllCall jedes Mal intern LoadLibrary und FreeLibrary aufrufen muss. Zum Beispiel:</p>
<pre>hModule := DllCall("<strong>LoadLibrary</strong>", "Str", "MeineFunktionen.dll", "Ptr")  <em>; Verhindert, dass DllCall die Bibliothek in der Schleife laden muss.</em>
Loop Files, "C:\Meine Dokumente\*.*", "R"
    Ergebnis := DllCall("MeineFunktionen\BackupFile", "Str", A_LoopFilePath)
DllCall("<strong>FreeLibrary</strong>", "Ptr", hModule)  <em>; Um Speicherplatz zu sparen, kann die DLL nach der Benutzung entladen werden.</em></pre>
<p>Es kann eine noch schnellere Performance erreicht werden, wenn man im Voraus die Adresse der Funktion abfragt. Zum Beispiel:</p>
<pre><em>; Das folgende Beispiel zeigt, wie man LoadLibrary statt GetModuleHandle verwenden kann, wenn die DLL noch nicht geladen ist.</em>
<strong>MulDivProc</strong> := DllCall("GetProcAddress", Ptr, DllCall("GetModuleHandle", Str, "<strong>kernel32</strong>", "Ptr"), AStr, "<strong>MulDiv</strong>", "Ptr")
Loop 500
    DllCall(<strong>MulDivProc</strong>, Int, 3, Int, 4, Int, 3)</pre>
<p>Wenn der erste Parameter von DllCall eine direkt geschriebene Zeichenkette wie <code>"MulDiv"</code> ist und die Funktion-enthaltene DLL normal vor dem Start des Skripts geladen ist, wird die Zeichenkette automatisch in eine Funktionsadresse aufgelöst. Diese interne Optimierung ist effektiver als das oben gezeigte Beispiel.</p>
<p>Um die Performance bei der Übergabe einer Zeichenkette-enthaltenen Variable an eine Funktion, die die Länge der Zeichenkette nicht verändert, zu verbessern, übergibt man die Variable <a href="../Variables.htm#amp">via Adresse</a> (z. B. &amp;MeineVar) und nicht als "<a href="#str">str</a>" (besonders wenn die Zeichenkette sehr lang ist). Das folgende Beispiel wandelt eine Zeichenkette in Großbuchstaben um: <code>DllCall("CharUpper", <strong>Ptr</strong>, <strong>&amp;</strong>MeineVar, Ptr)</code>.</p>

<h2 id="struct">Strukturen und Arrays</h2>
<p>Eine Struktur ist eine Sammlung von <em>Elementen</em> (Feldern), die nebeneinander im Speicher abgelegt sind. Die meisten Elemente sind für gewöhnlich Integer.</p>
<p>Um Funktionen, die die Adresse einer Struktur (oder eines Speicherblock-Arrays) akzeptieren, aufzurufen, speichert man die binären Rohdaten der Struktur in eine normale Variable. Die folgenden Schritte werden in der Regel angewendet:</p>
<p>1) Rufen Sie <code><a href="VarSetCapacity.htm">VarSetCapacity</a>(MeineStruktur, 123, 0)</code> auf, um sicherzustellen, dass der Speicherumfang der Zielvariable groß genug für die Struktur ist. Ersetzen Sie 123 mit einer Zahl, die mindestens so groß ist wie die Größe der Struktur. Die Null im letzten Parameter ist optional; sie initialisiert jedes Element mit einer binären Null, um einen häufigen Aufruf von NumPut im nächsten Schritt zu verhindern.</p>
<p>2) Wenn die Zielfunktion die Werte anfänglich in der Struktur verwendet, muss <code><a href="NumPut.htm">NumPut</a>(123, MeineStruktur, 4, "UInt")</code> aufgerufen werden, um jedes Element zu initialisieren, das ungleich 0 sein soll. Ersetzen Sie <code>123</code> mit dem Integer, der in das Zielelement eingefügt werden soll (oder nutzen Sie <code>&amp;Var</code>, um die <a href="../Variables.htm#amp">Adresse</a> einer Variable zu speichern). Ersetzen Sie <code>4</code> mit dem Offset des Zielelements (siehe Schritt #4, was ein "Offset" ist). Ersetzen Sie <code>"UInt"</code> mit dem entsprechenden Typ oder lassen Sie ihn weg, falls das Element ein Pointer oder Handle ist.</p>
<p>3) Rufen Sie die Zielfunktion auf und übergeben Sie die <a href="../Variables.htm#amp">Adresse</a> von <em>MeineStruktur</em> als UInt- oder Ptr-Argument. Zum Beispiel: <code>DllCall("MeineDLL\MeineFunktion", Ptr, <strong>&amp;</strong>MeineStruktur)</code>. Die Funktion wird einige der Elemente prüfen und/oder ändern.</p>
<p>4) Verwenden Sie <code>MeinInteger := <a href="NumGet.htm">NumGet</a>(MeineStruktur, 4, "UInt")</code>, um beliebige Integer aus der Struktur abzurufen. Ersetzen Sie <code>4</code> mit dem Offset des Zielelements in der Struktur. Das erste Element liegt immer auf Offset 0. Das zweite Element liegt auf Offset 0 plus der Größe des ersten Elements (in der Regel 4). Jedes Element, das danach erfolgt, liegt auf dem Offset des vorherigen Elements plus der Größe des vorherigen Elements. Die meisten Elemente -- wie z. B. DWORD, Int und <a href="#Int">andere Typen von 32-Bit-Integern</a> -- haben eine Größe von 4 Bytes. Ersetzen Sie <code>"UInt"</code> mit dem entsprechenden Typ oder lassen Sie ihn weg, falls das Element ein Pointer oder Handle ist.</p>
<p>In den <a href="#ExStruct">Strukturbeispielen</a> weiter unten wurden diese Schritte angewandt.</p>
<h2 id="limits">Bekannte Einschränkungen</h2>
<p>Wenn die <a href="../Variables.htm#amp">Adresse einer Variable</a> (z. B. <code>&amp;MeineVar</code>) an eine Funktion übergeben wird und diese Funktion die Länge des Variableninhalts ändert, kann der nachfolgende Gebrauch dieser Variable eventuell zu fehlerhaftem Verhalten führen. Um dieses Problem zu beheben, gibt es folgende Lösungen: 1) Übergeben Sie MeineVar nicht als Ptr/Adresse, sondern als <a href="#str">"Str"</a>-Argument; 2) Rufen Sie <code><a href="VarSetCapacity.htm#neg1">VarSetCapacity</a>(MeineVar, -1)</code> auf, um die intern gespeicherte Länge der Variable nach dem Aufruf von DllCall zu aktualisieren.</p>
<p>Jede binäre Null, die via Funktion in eine Variable gespeichert wurde, versteckt alle Daten auf der rechten Seite der Null; das heißt, dass die meisten internen Funktionen solche Daten weder abrufen noch ändern können. Solche Daten können jedoch via <a href="../Variables.htm#amp">Adressoperator</a>, <a href="NumPut.htm">NumPut</a>/<a href="NumGet.htm">NumGet</a> und DllCall selbst manipuliert werden.</p>
<p>Eine Funktion, die die Adresse von einer der Zeichenketten zurückgibt, die an sie übergeben wurde, gibt dieselbe Zeichenkette eventuell auf einer anderen Speicheradresse als erwartet zurück. Zum Beispiel würde der Aufruf von <code>CharLower(CharUpper(MeineVar))</code> in einer anderen Programmiersprache normalerweise bewirken, dass der Inhalt von <em>MeineVar</em> in Kleinbuchstaben umgewandelt wird. Macht man aber das gleiche mit DllCall, wäre <em>MeineVar</em> im Endeffekt groß geschrieben, weil CharLower eine andere/temporäre Zeichenkette bearbeitet hätte, dessen Inhalt identisch zu <em>MeineVar</em> war:</p>
<pre>MeineVar := "ABC"
Ergebnis := DllCall("CharLower", <strong><u>str</u></strong>, DllCall("CharUpper", Str, MeineVar, <strong><u>Str</u></strong>), Str)</pre>
<p>Um dieses Problem zu umgehen, ersetzt man die zwei oben unterstrichenen "Str"-Werte mit Ptr. Dadurch wird der Rückgabewert von CharUpper als reine Adresse interpretiert, der dann als Integer an CharLower übergeben wird.</p>
<p>Bestimmte Einschränkungen können auftreten, wenn es um Zeichenketten geht. Weitere Informationen finden Sie unter <a href="../Compat.htm#DllCall">Skript-Kompatibilität</a>.</p>
<h2 id="COM">Component Object Model (COM)</h2>
<p>COM-Objekte, die für VBScript und ähnliche Sprachen zugänglich sind, kann AutoHotkey auch via <a href="ComObjCreate.htm">ComObjCreate</a>, <a href="ComObjGet.htm">ComObjGet</a>, <a href="ComObjActive.htm">ComObjActive</a> und interner <a href="../Objects.htm#Usage_Objects">Objektsyntax</a> ansteuern.</p>
<p>Um COM-Objekte, die kein <a href="https://msdn.microsoft.com/de-de/library/ms221608.aspx">IDispatch</a> unterstützen, in Verbindung mit DllCall nutzen zu können, ruft man die Adresse einer Funktion aus der virtuellen Funktionstabelle des Objekt-Interfaces ab. Weitere Informationen finden Sie <a href="#ExTaskbar">im Beispiel</a> weiter unten.</p>
<p>Der Großteil von .NET-Framework ist auch via COM und DllCall zugänglich. Siehe <a href="http://www.autohotkey.com/forum/topic26191.html">.NET Framework Interop</a> (englisch).
</p>

<h2>Siehe auch</h2>
<p><a href="../Compat.htm#DllCall">Skript-Kompatibilität</a>, <a href="PostMessage.htm">PostMessage</a>, <a href="OnMessage.htm">OnMessage</a>, <a href="CallbackCreate.htm">CallbackCreate</a>, <a href="Run.htm">Run</a>, <a href="VarSetCapacity.htm">VarSetCapacity</a>, <a href="../Functions.htm">Funktionen</a>, <a href="SysGet.htm">SysGet</a>, <a href="https://msdn.microsoft.com/de-de/library/">MSDN Library</a></p>
<h2>Beispiele</h2>
<pre class="NoIndent"><em>; Beispiel: Ruft die Windows-API-Funktion "MessageBox" auf und meldet, welchen Button der Benutzer gedrückt hat.</em>

WelcherButton := DllCall("MessageBox", "Int", "0", "Str", "Ja oder Nein drücken", "Str", "Titel der Box", "Int", 4)
MsgBox "Sie haben den Button #" WelcherButton " gedrückt."</pre>

<pre class="NoIndent"><em>; Beispiel: Ersetzt das Desktop-Hintergrundbild mit der angegebenen Bitmap-Datei (.bmp).</em>

DllCall("SystemParametersInfo", UInt, 0x14, UInt, 0, Str, <i>A_WinDir <strong>.</strong> "\winnt.bmp"</i>, UInt, 2)</pre>

<pre class="NoIndent"><em>; Beispiel: Ruft die API-Funktion "IsWindowVisible" auf, um herauszufinden, ob ein Fenster des Texteditors sichtbar ist.</em>

DetectHiddenWindows True
if not DllCall("IsWindowVisible", "Ptr", WinExist("Unbenannt - Editor"))  <em>; WinExist gibt ein HWND zurück.</em>
    MsgBox "Das Fenster ist nicht sichtbar."</pre>

<pre class="NoIndent"><em>; Beispiel: Ruft die API-Funktion wsprintf() auf, um die Zahl 432 mit führenden Nullen aufzufüllen, bis sie eine Breite von 10 Zeichen hat (0000000432).</em>

VarSetCapacity(AufgefüllteZahl, 20)  <em>; Stellt sicher, dass die Variable groß genug für die neue Zeichenkette ist.</em>
DllCall("wsprintf", "Str", AufgefüllteZahl, "Str", "%010d", "Int", 432, "Cdecl")  <em>; Benötigt die Cdecl-Aufrufkonvention.</em>
MsgBox AufgefüllteZahl

<em>; Alternativ können Sie die <a href="Format.htm">Format</a>-Funktion in Verbindung mit dem Null-Flag nutzen:</em>
MsgBox Format("{:010}", 432)
</pre>

<pre class="NoIndent" id="QPC"><em>; Beispiel: Zeigt, wie man mit QueryPerformanceCounter() eine höhere Präzision als die 10 ms von <a href="../Variables.htm#TickCount">A_TickCount</a> erreichen kann.</em>

DllCall("QueryPerformanceCounter", "Int64*", CounterDavor)
Sleep 1000
DllCall("QueryPerformanceCounter", "Int64*", CounterDanach)
MsgBox "Die Differenz zwischen den Zeiten beträgt " . CounterDanach - CounterDavor</pre>

<pre class="NoIndent"><em>; Beispiel: Ein Hotkey, der vorübergehend die Geschwindigkeit des Mauszeigers verringert, um eine genauere Positionierung zu ermöglichen.
; Halten Sie die F1-Taste gedrückt, um den Mauszeiger zu verlangsamen. Lassen Sie sie los, um die originale Geschwindigkeit wiederherzustellen.</em>

F1::
SPI_GETMOUSESPEED := 0x70
SPI_SETMOUSESPEED := 0x71
<em>; Ermittelt die aktuelle Geschwindigkeit, um sie später wiederherzustellen:</em>
<strong>DllCall</strong>("SystemParametersInfo", UInt, SPI_GETMOUSESPEED, UInt, 0, UIntP, OrigMausTempo, UInt, 0)
<em>; Verringert nun die Geschwindigkeit des Mauszeigers im vorletzten Parameter (im Bereich von 1 bis 20, 10 ist Standard):</em>
<strong>DllCall</strong>("SystemParametersInfo", UInt, SPI_SETMOUSESPEED, UInt, 0, Ptr, <strong>3</strong>, UInt, 0)
KeyWait "F1"  <em>; Verhindert, dass das Auto-Wiederholungs-Feature der Tastatur DllCall wiederholt aufruft.</em>
return

F1 up::<strong>DllCall</strong>("SystemParametersInfo", UInt, 0x71, UInt, 0, Ptr, OrigMausTempo, UInt, 0)  <em>; Stellt die ursprüngliche Geschwindigkeit wieder her.</em></pre>

<pre class="NoIndent"><em>; Beispiel: Überwacht das aktive Fenster und zeigt die Position der vertikalen Scrollleiste
; im seinem fokussierten Steuerelement an (in Echzeit).</em>

SetTimer "BeobachteScrollleiste", 100

BeobachteScrollleiste()
{
    AktivesFenster := WinExist("A")
    if !AktivesFenster  <em>; Kein aktives Fenster.</em>
        return
    FokussiertesSteuerelement := ControlGetFocus()  <em>; Alle Parameter weglassen, um das Zuletzt Gefundene Fenster zu benutzen.</em>
    if !FokussiertesSteuerelement  <em>; Kein fokussiertes Steuerelement.</em>
        return
    <em>; Zeigt die vertikale oder horizontale Position der Scrollleiste in einem ToolTip an:</em>
    UnterelementHWND := ControlGetHwnd(FokussiertesSteuerelement)
    ToolTip(<strong>DllCall</strong>("GetScrollPos", "Ptr", UnterelementHWND, "Int", 1))  <em>;  Letzter Parameter kann 1 für SB_VERT und 0 für SB_HORZ sein.</em>
}</pre>

<pre class="NoIndent" id="file"><em>; Beispiel: Dieses Skript schreibt etwas Text in eine Datei und liest ihn zurück in den Speicher.
; Diese Methode kann genutzt werden, um die Performance beim gleichzeitigen Lesen oder Schreiben mehrerer Dateien zu verbessern.
; Alternativ kann das gleiche mit <a href="FileOpen.htm">FileOpen</a> erreicht werden. Siehe dazu das <a href="FileOpen.htm#writeread">Beispiel</a>.</em>

Dateiname := FileSelect("S16",, "Neue Datei erstellen:")
if Dateiname = ""
    return
GENERIC_WRITE := 0x40000000  <em>; Öffnet eine Datei zum Schreiben.</em>
CREATE_ALWAYS := 2  <em>; Erstellt eine neue Datei (überschreibt eine vorhandene Datei).</em>
hFile := <strong>DllCall</strong>("CreateFile", Str, Dateiname, UInt, GENERIC_WRITE, UInt, 0, Ptr, 0, UInt, CREATE_ALWAYS, UInt, 0, Ptr, 0, Ptr)
if !hFile
{
    MsgBox "Kann '" Dateiname "' nicht zum Schreiben öffnen."
    return
}
TestZeichenkette := "Das ist eine Zeichenkette.`r`n"  <em>; Wenn eine Datei auf diese Weise geschrieben wird, sollte `r`n anstelle von `n verwendet werden, um eine neue Zeile zu beginnen.</em>
<strong>DllCall</strong>("WriteFile", Ptr, hFile, Str, TestZeichenkette, UInt, StrLen(TestZeichenkette), UIntP, AktuellGeschriebeneBytes, Ptr, 0)
<strong>DllCall</strong>("CloseHandle", Ptr, hFile)  <em>; Schließt die Datei.</em>

<em>; Liest den Inhalt der Datei, nachdem sie geschrieben wurde, zurück in den Speicher.</em>
GENERIC_READ := 0x80000000  <em>; Öffnet die Datei zum Lesen.</em>
OPEN_EXISTING := 3  <em>; Dieser Modus bewirkt, dass die zu öffnende Datei bereits existieren muss.</em>
FILE_SHARE_READ := 0x1 <em>; Dieser und der nächste Modus bestimmen, ob andere Prozesse die bereits geöffnete Datei öffnen können.</em>
FILE_SHARE_WRITE := 0x2
hFile := <strong>DllCall</strong>("CreateFile", Str, Dateiname, UInt, GENERIC_READ, UInt, FILE_SHARE_READ|FILE_SHARE_WRITE, Ptr, 0, UInt, OPEN_EXISTING, UInt, 0, Ptr, 0)
if !hFile
{
    MsgBox "Kann '" Dateiname "' nicht zum Lesen öffnen."
    return
}
<em>; Macht die Variable aus Testgründen leer, aber stellt sicher, das sie genügend Kapazität zur Verfügung hat:</em>
ZuLesendeBytes := VarSetCapacity(TestZeichenkette, StrLen(TestZeichenkette))
<strong>DllCall</strong>("ReadFile", Ptr, hFile, Str, TestZeichenkette, UInt, ZuLesendeBytes, UIntP, AktuellGeleseneBytes, Ptr, 0)
<strong>DllCall</strong>("CloseHandle", Ptr, hFile)  <em>; Schließt die Datei.</em>
MsgBox "Die folgende Zeichenkette wurde aus der Datei gelesen: " TestZeichenkette</pre>

<pre class="NoIndent" id="HideCursor"><em>; Beispiel: Versteckt den Mauszeiger, wenn man WIN+C drückt. Um den Mauszeiger wieder sichtbar zu machen, drückt man nochmals WIN+C.</em>

OnExit () =&gt; SystemCursor("Show")  <em>; Stellt sicher, dass der Mauszeiger beim Beenden des Skripts wieder sichtbar gemacht wird.</em>

#c::SystemCursor("Toggle")  <em>; Drückt man WIN+C, wird der Mauszeiger jeweils ein- oder ausgeschaltet.</em>

SystemCursor(cmd)  <em>; cmd = "Show|Hide|Toggle"</em>
{
    static vision := true, c := {}
    static system_cursors := "32512,32513,32514,32515,32516,32642,32643,32644,32645,32646,32648,32649,32650"
    VarSetCapacity(h_cursor, 4444, 1)
    if (cmd = "Reload" or !c.Length())  <em>; Neuladen bei Bedarf oder beim ersten Aufruf.</em>
    {
        VarSetCapacity(AndMask, 32*4, 0xFF)
        VarSetCapacity(XorMask, 32*4, 0)
        For i, resID in StrSplit(system_cursors, ",")
        {
            h_cursor := DllCall("LoadCursor", Ptr, 0, Ptr, resID)
            <em>; System-Mauszeiger:</em>
            c[i] := {r: resID}
            <em>; Handles von Standardzeigern:</em>
            c[i][1] := DllCall("CopyImage", Ptr, h_cursor, UInt, 2, Int, 0, Int, 0, UInt, 0)
            <em>; Leere Mauszeiger:</em>
            c[i][0] := DllCall("CreateCursor", Ptr, 0, Int, 0, Int, 0, Int, 32, Int, 32, Ptr, &amp;AndMask, Ptr, &amp;XorMask)
        }
    }
    if (cmd = "Show")
        vision := true
    else if (cmd = "Hide")
        vision := false
    else if (cmd = "Toggle")
        vision := !vision
    else
        return
    For i, cursor in c
    {
        h_cursor := DllCall("CopyImage", Ptr, cursor[vision], UInt, 2, Int, 0, Int, 0, UInt, 0)
        DllCall("SetSystemCursor", Ptr, h_cursor, UInt, cursor.r)
    }
}</pre>

<pre class="NoIndent" id="ExStruct"><em>; Struktur-Beispiel: Übergibt die Adresse einer RECT-Struktur an die GetWindowRect-Funktion, die die
; Strukturelemente auf die Positionen der linken, oberen, rechten und unteren Seite des Fensters setzt (relativ zum Bildschirm).</em>

Run "Notepad"
WinWait "Unbenannt - Editor"  <em>; Setzt auch das "<a href="../misc/WinTitle.htm#LastFoundWindow">zuletzt gefundene Fenster</a>" für das untere WinExist.</em>
VarSetCapacity(Rect, 16)  <em>; RECT ist eine Struktur, die aus vier 32-Bit-Integern besteht (also 4*4=16).</em>
<strong>DllCall</strong>("GetWindowRect", Ptr, WinExist(), Ptr, &amp;Rect)  <em>; WinExist gibt ein HWND zurück.</em>
L := NumGet(Rect, 0, "Int"), O := NumGet(Rect, 4, "Int")
R := NumGet(Rect, 8, "Int"), U := NumGet(Rect, 12, "Int")
MsgBox Format("Links {1} Oben {2} Rechts {3} Unten {4}", L, O, R, U)</pre>

<pre class="NoIndent"><em>; Struktur-Beispiel: Übergibt an die FillRect-Funktion die Adresse einer RECT-Struktur, die einen Bereich des
; Bildschirms kennzeichnet, der kurzzeitig rot gefärbt werden soll.</em>

VarSetCapacity(Rect, 16, 0)  <em>; Setzt die Kapazität zum Speichern von vier 4-Byte-Integern und initialisiert sie alle mit Null.</em>
<a href="NumPut.htm">NumPut</a>(A_ScreenWidth//2, Rect, 8, "Int")  <em>; Der dritte Integer in der Struktur ist "rect.right".</em>
NumPut(A_ScreenHeight//2, Rect, 12, "Int") <em>; Der vierte Integer in der Struktur ist "rect.bottom".</em>
hDC := <strong>DllCall</strong>("GetDC", "Ptr", 0, "Ptr")  <em>; Übergibt Null, um den Gerätekontext des Desktops abzurufen.</em>
hBrush := <strong>DllCall</strong>("CreateSolidBrush", "UInt", 0x0000FF, "Ptr")  <em>; Erstellt einen roten Pinsel (0x0000FF ist im BGR-Format).</em>
<strong>DllCall</strong>("FillRect", "Ptr", hDC, "Ptr", &amp;Rect, "Ptr", hBrush)  <em>; Füllt das angegebene Rechteck mit dem Pinsel von oben.</em>
<strong>DllCall</strong>("ReleaseDC", "Ptr", 0, "Ptr", hDC)  <em>; Gibt Speicher frei.</em>
<strong>DllCall</strong>("DeleteObject", "Ptr", hBrush)  <em>; Gibt Speicher frei.</em></pre>

<pre class="NoIndent"><em>; Struktur-Beispiel: Setzen Sie die Systemuhr auf den angegebenen Datums- und Zeitwert. Seien Sie vorsichtig,
; wenn Sie ein zukünftiges Datum setzen, denn dies kann dazu führen, dass geplante Tasks vorzeitig ausgeführt werden!</em>

SetzeSystemzeit("20051008142211")  <em>; Übergeben Sie einen <a href="FileSetTime.htm#YYYYMMDD">Zeitstempel</a> (lokal, nicht UTC).</em>

SetzeSystemzeit(YYYYMMDDHHMISS)
<em>; Setzt die Systemzeit den angegebenen Datums- und Zeitwert.
; Der Aufrufer muss sicherstellen, dass der eingehende Parameter ein gültiger Zeitstempel ist
; (lokale Zeit, nicht UTC). Übergibt bei Erfolg ungleich 0 zurück.</em>
{
    <em>; Konvertiert die im Parameter angegebene lokale Zeit in UTC, damit sie in Verbindung mit SetSystemTime() genutzt werden kann.</em>
    UTC_Delta := DateDiff(A_Now, A_NowUTC, "Seconds")  <em>; Sekunden sind genauer, um Rundungsfehler zu umgehen.</em>
    UTC_Delta := Round(-UTC_Delta/60)  <em>; Rundet auf die nächste Minute, um Genauigkeit zu gewährleisten.</em>
    YYYYMMDDHHMISS := DateAdd(YYYYMMDDHHMISS, UTC_Delta, "Minutes")  <em>; Wendet den Offset für die Konvertierung zu UTC an.</em>

    VarSetCapacity(Systemzeit, 16, 0)  <em>; Diese Struktur besteht aus 8 UShort-Werten (also 8*2=16).</em>

    Int := SubStr(YYYYMMDDHHMISS, 1, 4)  <em>; YYYY (Jahr)</em>
    <a href="NumPut.htm">NumPut</a>(Int, Systemzeit, 0, "UShort")
    Int := SubStr(YYYYMMDDHHMISS, 5, 2)  <em>; MM (Monat des Jahres, 1-12)</em>
    NumPut(Int, Systemzeit, 2, "UShort")
    Int := SubStr(YYYYMMDDHHMISS, 7, 2)  <em>; DD (Tag des Monats)</em>
    NumPut(Int, Systemzeit, 6, "UShort")
    Int := SubStr(YYYYMMDDHHMISS, 9, 2)  <em>; HH (Stunden im 24-Stunden-Format)</em>
    NumPut(Int, Systemzeit, 8, "UShort")
    Int := SubStr(YYYYMMDDHHMISS, 11, 2) <em>; MI (Minuten)</em>
    NumPut(Int, Systemzeit, 10, "UShort")
    Int := SubStr(YYYYMMDDHHMISS, 13, 2) <em>; SS (Sekunden)</em>
    NumPut(Int, Systemzeit, 12, "UShort")

    return <strong>DllCall</strong>("SetSystemTime", Ptr, &amp;Systemzeit)
}</pre>

<pre class="NoIndent"><em>/* <strong>Weitere Struktur-Beispiele:</strong>

1) Im <a href="../scripts/WinLIRC.htm">WinLIRC-Client-Skript</a> wird gezeigt, wie man mit DllCall eine Netzwerkverbindung zu einem TCP/IP-Server aufbauen
und Daten von ihm empfangen kann.

2) Das Betriebssystem bietet vorgefertigte Dialogfenster an, die der Benutzer zum Auswählen einer Farbe, einer Schriftart oder eines Symbols verwenden kann.
Solche Dialogfenster nutzen Strukturen und werden auf <a href="http://www.autohotkey.com/forum/topic17230.html">www.autohotkey.com/forum/topic17230.html</a> vorgestellt.

*/</em></pre>

<pre id="ExTaskbar" class="NoIndent"><em>/*
  Beispiel: Entfernt mithilfe von COM vorübergehend das aktive Fenster aus der Taskleiste.

  Methoden in der <a href="https://msdn.microsoft.com/de-de/library/bb774652.aspx">ITaskbarList</a>-VTable:
    IUnknown:
      0 QueryInterface  -- nutze stattdessen <a href="ComObjQuery.htm">ComObjQuery</a>
      1 AddRef          -- nutze stattdessen <a href="ObjAddRef.htm">ObjAddRef</a>
      2 Release         -- nutze stattdessen <a href="ObjAddRef.htm">ObjRelease</a>
    ITaskbarList:
      3 HrInit
      4 AddTab
      5 DeleteTab
      6 ActivateTab
      7 SetActiveAlt
*/</em>
IID_ITaskbarList  := "{56FDF342-FD6D-11d0-958A-006097C9A090}"
CLSID_TaskbarList := "{56FDF344-FD6D-11d0-958A-006097C9A090}"

<em>; Erstellt ein TaskbarList-Objekt und speichert seine Adresse in tbl.</em>
tbl := <a href="ComObjCreate.htm">ComObjCreate</a>(CLSID_TaskbarList, IID_ITaskbarList)

activeHwnd := WinExist("A")

DllCall(vtable(tbl,3), "ptr", tbl)                     <em>; tbl.<a href="https://msdn.microsoft.com/de-de/library/bb774650.aspx">HrInit</a>()</em>
DllCall(vtable(tbl,5), "ptr", tbl, "ptr", activeHwnd)  <em>; tbl.<a href="https://msdn.microsoft.com/de-de/library/bb774648.aspx">DeleteTab</a>(activeHwnd)</em>
Sleep 3000
DllCall(vtable(tbl,4), "ptr", tbl, "ptr", activeHwnd)  <em>; tbl.<a href="https://msdn.microsoft.com/de-de/library/bb774646.aspx">AddTab</a>(activeHwnd)</em>

<em>; Nicht-Dispatch-Objekte müssen immer manuell freigegeben werden.</em>
ObjRelease(tbl)

vtable(ptr, n) {
    <em>; NumGet(ptr+0) gibt die Adresse der virtuellen Funktionstabelle
    ; des Objekts (kurz: vtable) zurück. Der Rest des Ausdrucks ruft
    ; die Adresse der n-ten Funktionsadresse aus der vtable ab.</em>
    return NumGet(NumGet(ptr+0), n*A_PtrSize)
}
</pre>

</body>
</html>
