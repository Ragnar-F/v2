<!DOCTYPE HTML>
<html lang="de">
<head>
<title>Send - Syntax &amp; Verwendung | AutoHotkey v2</title>
<meta name="description" content="Die Funktionen Send, SendRaw, SendInput, SendPlay und SendEvent senden simulierte Tastendrücke und Mausklicks an das aktive Fenster." />
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="robots" content="noindex, nofollow">
<link href="../static/theme.css" rel="stylesheet" type="text/css" />
<script src="../static/content.js" type="text/javascript"></script>
<script src="../static/ga.js" type="text/javascript"></script>
<style type="text/css">
.red {color: #FF0000; font-weight: bold;}
</style>
</head>
<body>

<h1>Send[Text|Input|Play|Event] </h1>

<p>Sendet simulierte Tastendrücke und Mausklicks an das <a href="WinActivate.htm">aktive</a> Fenster.</p>

<pre class="Syntax"><span class="func">Send</span> Tasten
<span class="func">SendText</span> Tasten
<span class="func">SendInput</span> Tasten
<span class="func">SendPlay</span> Tasten
<span class="func">SendEvent</span> Tasten</pre>
<h2>Parameter</h2>
<dl>

  <dt>Tasten</dt>
  <dd>
    <p>Typ: <a href="../Concepts.htm#strings">Zeichenkette</a></p>
    <p>Eine Reihe von Tasten, die gesendet werden soll.</p>
  </dd>

</dl>

<p id="SendRaw"><strong>Raw-Modus</strong> - <a href="#Raw">{Raw}</a>: Die Zeichen <code>^+!#{}</code> werden als direkt geschriebener Text interpretiert, anstatt z. B. <code>{Enter}</code> in <kbd>Enter</kbd>, <code>^c</code> in <kbd>Strg</kbd>+<kbd>C</kbd> usw. zu übersetzen. Um den Raw-Modus bei SendInput, SendPlay, SendEvent oder ControlSend zu verwenden, gibt man <a href="#Raw">{Raw}</a> als erstes Element in der Zeichenkette an; zum Beispiel: <code>SendInput "{Raw}abc"</code>.</p>
<p>Der <em>Raw-Modus</em> hat keinen Einfluss auf die Interpretation von <a href="../misc/EscapeChar.htm">Escapesequenzen</a> und <a href="../Variables.htm#Expressions">Ausdrücken</a>. Zum Beispiel würde <code>Send "{Raw}``100`%"</code> die Zeichenkette <code>`100%</code> senden.</p>
<p id="SendText"><strong>Text-Modus</strong> - <em>SendText</em> oder <a href="#Text">{Text}</a>: Ähnlich wie der Raw-Modus, nur dass kein Versuch unternommen wird, Zeichen (außer <code>`r</code>, <code>`n</code>, <code>`t</code> und <code>`b</code>) in Tastencodes umzuwandeln; stattdessen wird für alle übrigen Zeichen die <a href="#fallback">Fallback</a>-Methode angewandt. Dieser Modus verbessert die Zuverlässigkeit von SendEvent, SendInput und ControlSend, da die Zeichen wesentlich weniger vom korrekten Modifikatorstatus abhängig sind. Der Text-Modus kann mit dem Blind-Modus kombiniert werden, um das Loslassen von Modifikatortasten zu vermeiden: <code>Send "{Blind}{Text}Ihr Text"</code>. In einigen Anwendungen müssen die Modifikatortasten jedoch losgelassen werden.</p>
<p><code>`n</code>, <code>`r</code> und <code>`r`n</code> werden in einen einzelnen <kbd>Enter</kbd>-Tastendruck umgewandelt, im Gegensatz zum Normal- und Raw-Modus, die <code>`r`n</code> in zwei <kbd>Enter</kbd>-Tastendrücke umwandeln. <code>`t</code> wird in <kbd>Tab</kbd> und <code>`b</code> in <kbd>Backspace</kbd> umgewandelt, alle anderen Zeichen werden ohne Umwandlung gesendet.</p>
<p>Der Text-Modus ignoriert wie der Blind-Modus <a href="SetStoreCapsLockMode.htm">SetStoreCapsLockMode</a> (das heißt, dass der Status der <kbd>Feststell</kbd>-Taste nicht geändert wird) und wartet nicht <a href="../Hotkeys.htm#win-l">auf das Loslassen der <kbd>Win</kbd>-Taste</a>. Grund dafür ist, dass der Text-Modus in der Regel nicht vom Status der <kbd>Feststell</kbd>-Taste abhängig ist und nicht den system-internen <kbd>Win</kbd>+<kbd>L</kbd>-Hotkey auslösen kann. Dies gilt jedoch nur, wenn <em>Tasten</em> mit <code>{Text}</code> oder <code>{Blind}{Text}</code> beginnt.</p>
<p id="specialchars"><strong>Normal-Modus</strong>: Wenn der Raw- oder Text-Modus nicht aktiv ist, haben folgende Symbole eine besondere Bedeutung: <code>!+^#{}</code></p>
<p>Die Modifikatoren <code>!+^#</code> beeinflussen nur die direkt darauffolgende Taste. Um die entsprechende Modifikatortaste separat zu senden, umschließt man den Tastennamen mit geschweiften Klammern. Um eine Taste einfach nur zu drücken (gedrückt halten) oder loszulassen, muss nach dem Tastennamen das Wort "down" oder "up" erfolgen, wie unten gezeigt.</p>
<style>
#modifierkeys td:not(:last-child) { white-space: nowrap; text-align: center }
</style>
<table id="modifierkeys" class="info">
  <tr>
    <th>Symbol</th>
    <th>Taste</th>
    <th>Drücken</th>
    <th>Loslassen</th>
    <th>Beispiele</th>
  </tr>
  <tr>
    <td>!</td>
    <td>{Alt}</td>
    <td>{Alt down}</td>
    <td>{Alt up}</td>
    <td><code>Send "!a"</code> drückt <kbd>Alt</kbd>+<kbd>A</kbd></td>
  </tr>
  <tr>
    <td>+</td>
    <td>{Shift}</td>
    <td>{Shift down}</td>
    <td>{Shift up}</td>
    <td><code>Send "+abC"</code> sendet den Text "AbC"<br>
    <code>Send "!+a"</code> drückt <kbd>Alt</kbd>+<kbd>Umschalt</kbd>+<kbd>A</kbd></td>
  </tr>
  <tr>
    <td>^</td>
    <td>{Ctrl}</td>
    <td>{Ctrl down}</td>
    <td>{Ctrl up}</td>
    <td><code>Send "^{Home}"</code> drückt <kbd>Strg</kbd>+<kbd>Pos1</kbd></td>
  </tr>
  <tr>
    <td>#</td>
    <td>{LWin}<br>{RWin}</td>
    <td>{LWin down}<br>{RWin down}</td>
    <td>{LWin up}<br>{RWin up}</td>
    <td><code>Send "#e"</code> hält die <kbd>Win</kbd>-Taste gedrückt und drückt dann die <kbd>E</kbd>-Taste</td>
  </tr>
  <tr>
    <th>Symbol</th>
    <th colspan="4">Bedeutung</th>
  </tr>
  <tr>
    <td>{ }</td>
    <td colspan="4" style="white-space: normal; text-align: left"><p>Mit geschweiften Klammern werden <a href="#keynames">Tastennamen und andere Optionen</a> umschlossen, um spezielle Zeichen als direkt geschriebener Text zu senden. Zum Beispiel wäre <code>{Tab}</code> die <kbd>Tab</kbd>-Taste und <code>{!}</code> ein direkt geschriebenes Ausrufezeichen.</p>
    <p>Umschließt man einen reinen ASCII-Buchstaben (a-z oder A-Z) mit geschweiften Klammern, wird stattdessen sein entsprechender virtueller Tastencode gesendet, auch wenn das Zeichen im aktuellen Tastaturlayout nicht vorhanden ist. Das heißt, dass <code>Send "a"</code> den Buchstaben "a" erzeugen würde, während <code>Send "{a}"</code> je nach Tastaturlayout ein "a" erzeugt oder nicht. Einzelheiten finden Sie unter <a href="#AZ">Bemerkungen</a>.</p></td>
  </tr>
</table>
<p class="note"><strong>Hinweis</strong>: Großbuchstaben werden durch Senden der <kbd>Umschalt</kbd>-Taste erzeugt, daher würde z. B. <code>A</code> in einigen Programmen eine andere Wirkung als <code>a</code> erzielen. Zum Beispiel würde <code>!A</code> <kbd>Alt</kbd>+<kbd>Umschalt</kbd>+<kbd>A</kbd> und <code>!a</code> <kbd>Alt</kbd>+<kbd>A</kbd> drücken. Im Zweifelsfall sollte man immer Kleinbuchstaben verwenden.</p>
<p id="blind"><strong>Blind-Modus</strong> - <code>{Blind}</code>: Der Blind-Modus gibt dem Skript mehr Kontrolle, indem er eine Reihe von Dingen deaktiviert, die normalerweise automatisch ausgeführt werden, damit die Dinge wie erwartet funktionieren. <code>{Blind}</code> muss das erste Element in der Zeichenkette sein, um den Blind-Modus zu aktivieren. Er hat folgende Auswirkungen:</p>
<ul>
  <li>Der Blind-Modus verhindert das Loslassen von <kbd>Alt</kbd>/<kbd>Strg</kbd>/<kbd>Umschalt</kbd>/<kbd>Win</kbd>, wenn sie zu Beginn im gedrückten Zustand waren, es sei denn, der Modifikator ist <a href="#blind-exclude">ausgeschlossen</a>. Zum Beispiel würde der Hotkey <code>+s::Send "{Blind}abc"</code> ABC statt abc senden, weil der Benutzer die <kbd>Umschalt</kbd>-Taste gedrückt hält.</li>
  <li>Modifikatortasten werden unterschiedlich wiederhergestellt, damit ein Send die Modifikatoren eines Hotkeys ausschalten kann, auch dann, wenn der Benutzer sie immer noch physisch gedrückt hält. <code>^space::Send "{Ctrl up}"</code> beispielsweise drückt die <kbd>Strg</kbd>-Taste wieder nach unten, wenn der Benutzer die <kbd>Strg</kbd>-Taste immer noch physisch gedrückt hält, während <code>^space::Send "{Blind}{Ctrl up}"</code> der <kbd>Strg</kbd>-Taste erlaubt, logisch oben zu sein, obwohl sie physisch nach unten gedrückt ist.</li>
  <li><a href="SetStoreCapsLockMode.htm">SetStoreCapslockMode</a> wird ignoriert; das heißt, dass der Status der <kbd>Feststell</kbd>-Taste nicht geändert wird.</li>
  <li><a href="_MenuMaskKey.htm">Menü-Maskierung</a> ist deaktiviert. Das heißt, dass Send die zusätzlichen Tastendrücke weglässt, die sonst gesendet würden, um Folgendes zu verhindern: 1) Öffnen des Startmenüs bei <kbd>Win</kbd>-Tastendrücke (LWin/RWin); 2) Aktivierung der Menüleiste bei <kbd>Alt</kbd>-Tastendrücke. Der Blind-Modus verhindert jedoch nicht die Maskierung, die vom Tastatur-Hook nach Aktivierung einer Hook-Taste durchgeführt wird.</li>
  <li>Send wartet nicht auf das Loslassen der <kbd>Win</kbd>-Taste, auch wenn der Text einen <kbd>L</kbd>-Tastendruck enthält. Dies geschieht normalerweise, um zu verhindern, dass Send den System-Hotkey "Arbeitsplatz sperren" (<kbd>Win</kbd>+<kbd>L</kbd>) auslöst. Weitere Informationen finden Sie unter <a href="../Hotkeys.htm#win-l">Hotkeys</a>.</li>
</ul>
<p id="blind-exclude">Nach dem Wort "Blind" können ein oder mehrere Modifikator-Symbole (<code>!#^+</code>) erfolgen, um diese Modifikatoren bei Bedarf automatisch loszulassen. <code>*^a::Send "{Blind^}b"</code> beispielsweise würde <kbd>Umschalt</kbd>+<kbd>B</kbd> statt <kbd>Strg</kbd>+<kbd>Umschalt</kbd>+<kbd>B</kbd> senden, wenn <kbd>Strg</kbd>+<kbd>Umschalt</kbd>+<kbd>A</kbd> gedrückt wurde. Mit <code>{Blind!#^+}</code> können alle Modifikatoren bei Bedarf losgelassen werden, aber aktiviert auch die anderen Effekte des Blind-Modus.</p>
<p>Der Blind-Modus wird beim <a href="../misc/Remap.htm">Neubelegen einer Taste</a> automatisch verwendet. Zum Beispiel würde die Neubelegung <code>a::b</code> Folgendes erzeugen: 1) "b" wenn man "a" eingibt; 2) großes "B" wenn man ein großes "A" eingibt; und 3) <kbd>Strg</kbd>+<kbd>B</kbd> wenn man <kbd>Strg</kbd>+<kbd>A</kbd> eingibt. Wenn irgendwelche Modifikatoren bei der Originaltaste angegeben sind (einschließlich <kbd>Umschalt</kbd>, wenn die Originaltaste ein Großbuchstabe ist), werden diese wie oben beschrieben ausgeschlossen. Zum Beispiel würde <code>^a::b</code> ein normales <kbd>B</kbd> erzeugen, nicht <kbd>Strg</kbd>+<kbd>B</kbd>.</p>
<p>SendText oder <a href="ControlSend.htm">ControlSendText</a> unterstützen kein <code>{Blind}</code>; verwenden Sie stattdessen <code>{Blind}{Text}</code>.</p>
<p>Desweiteren unterstützt <a href="#SendPlayDetail">SendPlay</a> den Blind-Modus nur unvollständig, besonders im Umgang mit Modifikatortasten (<kbd>Strg</kbd>, <kbd>Alt</kbd>, <kbd>Umschalt</kbd> und <kbd>Win</kbd>).</p>
<p><br>
<strong id="SendInput">SendInput</strong> und <strong id="SendPlay">SendPlay</strong>: SendInput und SendPlay verwenden die gleiche Syntax wie Send, allerdings sind sie in der Regel schneller und zuverlässiger. Darüber hinaus puffern diese Modi alle physischen Aktivitäten via Tastatur oder Maus während des Sendens, um zu verhindern, dass die Tastendrücke des Benutzers mit solchen, die gesendet werden, vermischt werden. Standardmäßig ist <em>Send</em> das Synonym für <em>SendEvent</em>; allerdings kann es via <a href="SendMode.htm">SendMode</a> zum Synonym für SendEvent oder <a href="#SendPlayDetail">SendPlay</a> gemacht werden. Um mehr Details über jeden Modus zu erfahren, siehe <a href="#SendInputDetail">SendInput</a> und <a href="#SendPlayDetail">SendPlay</a>.</p>
<p id="SendEvent"><strong>SendEvent</strong>: SendEvent verwenden zum Senden von Tastendrücken die keybd_event-Funktion von Windows (siehe MSDN für Details). Die Sendegeschwindigkeit von Tastendrücken wird mit <a href="SetKeyDelay.htm">SetKeyDelay</a> bestimmt. Verwenden Sie <a href="SendMode.htm">SendMode</a>, um Send zum Synonym für SendInput oder SendPlay zu machen.</p>
<p id="keynames"><strong>Tastennamen</strong>: Die folgende Tabelle listet alle speziellen Tasten auf, die gesendet werden können (jeder Tastenname muss mit geschweiften Klammern umschlossen werden):</p>
<table class="info">
  <tr>
    <th>&nbsp;</th>
    <th>&nbsp;</th>
  </tr>
  <tr>
    <td>{F1} - {F24}</td>
    <td>Funktionstasten. Zum Beispiel: {F12} ist die <kbd>F12</kbd>-Taste.</td>
  </tr>
  <tr>
    <td>{!}</td>
    <td>!</td>
  </tr>
  <tr>
    <td>{#}</td>
    <td>#</td>
  </tr>
  <tr>
    <td>{+}</td>
    <td>+</td>
  </tr>
  <tr>
    <td>{^}</td>
    <td>^</td>
  </tr>
  <tr>
    <td>{{}</td>
    <td>{</td>
  </tr>
  <tr>
    <td>{}}</td>
    <td>}</td>
  </tr>
  <tr>
    <td>{Enter}</td>
    <td><kbd>Enter</kbd>-Taste im Hauptblock</td>
  </tr>
  <tr>
    <td>{Escape} oder {Esc}</td>
    <td><kbd>Esc</kbd></td>
  </tr>
  <tr>
    <td>{Space}</td>
    <td><kbd>Leer</kbd> (nur für Leerzeichen notwendig, die am Anfang oder Ende der Zeichenkette vorkommen - Leerzeichen in der Mitte können direkt geschrieben sein)</td>
  </tr>
  <tr>
    <td>{Tab}</td>
    <td><kbd>Tab</kbd></td>
  </tr>
  <tr>
    <td>{Backspace} oder {BS}</td>
    <td><kbd>Backspace</kbd></td>
  </tr>
  <tr>
    <td>{Delete} oder {Del}</td>
    <td><kbd>Entf</kbd></td>
  </tr>
  <tr>
    <td>{Insert} oder {Ins}</td>
    <td><kbd>Einfg</kbd></td>
  </tr>
  <tr>
    <td>{Up}</td>
    <td><kbd>↑</kbd> (Nach-Oben-Taste) im Hauptblock</td>
  </tr>
  <tr>
    <td>{Down}</td>
    <td><kbd>↓</kbd> (Nach-Unten-Taste) im Hauptblock</td>
  </tr>
  <tr>
    <td>{Left}</td>
    <td><kbd>←</kbd> (Nach-Links-Taste) im Hauptblock</td>
  </tr>
  <tr>
    <td>{Right}</td>
    <td><kbd>→</kbd> (Nach-Rechts-Taste) im Hauptblock</td>
  </tr>
  <tr>
    <td>{Home}</td>
    <td><kbd>Pos1</kbd> im Cursorblock</td>
  </tr>
  <tr>
    <td>{End}</td>
    <td><kbd>Ende</kbd> im Cursorblock</td>
  </tr>
  <tr>
    <td>{PgUp}</td>
    <td><kbd>Bild↑</kbd> im Cursorblock</td>
  </tr>
  <tr>
    <td>{PgDn}</td>
    <td><kbd>Bild↓</kbd> im Cursorblock</td>
  </tr>
  <tr>
    <th>&nbsp;</th>
    <th>&nbsp;</th>
  </tr>
  <tr>
    <td>{CapsLock}</td>
    <td><kbd>Feststell</kbd> (in Win 2k/XP ist <a href="SetNumScrollCapsLockState.htm">SetCapsLockState</a> zuverlässiger). Das Senden von {CapsLock} benötigt möglicherweise vorher <code><a href="SetStoreCapsLockMode.htm">SetStoreCapsLockMode</a> "Off"</code>.</td>
  </tr>
  <tr>
    <td>{ScrollLock}</td>
    <td><kbd>Rollen</kbd> (siehe auch: <a href="SetNumScrollCapsLockState.htm">SetScrollLockState</a>)</td>
  </tr>
  <tr>
    <td>{NumLock}</td>
    <td><kbd>Num</kbd> (siehe auch: <a href="SetNumScrollCapsLockState.htm">SetNumLockState</a>)</td>
  </tr>
  <tr>
    <th>&nbsp;</th>
    <th>&nbsp;</th>
  </tr>
  <tr>
    <td>{Control} oder {Ctrl}</td>
    <td><kbd>Strg</kbd> (technische Info: sendet die neutrale virtuelle Taste, aber den linken Scancode)</td>
  </tr>
  <tr>
    <td>{LControl} oder {LCtrl}</td>
    <td>Linke <kbd>Strg</kbd>-Taste (technische Info: sendet nicht die neutrale, sondern die linke virtuelle Taste)</td>
  </tr>
  <tr>
    <td>{RControl} oder {RCtrl}</td>
    <td>Rechte <kbd>Strg</kbd>-Taste</td>
  </tr>
  <tr>
    <td>{Control down} oder {Ctrl down}</td>
    <td>Hält die <kbd>Strg</kbd>-Taste gedrückt, bis {Ctrl up} gesendet wird. Um stattdessen die linke oder rechte Taste gedrückt zu halten, nutzt man {RCtrl down} und {RCtrl up}.</td>
  </tr>
  <tr>
    <th>&nbsp;</th>
    <th>&nbsp;</th>
  </tr>
  <tr>
    <td>{Alt}</td>
    <td><kbd>Alt</kbd> (technische Info: sendet die neutrale virtuelle Taste, aber den linken Scancode)</td>
  </tr>
  <tr>
    <td>{LAlt}</td>
    <td>Linke <kbd>Alt</kbd>-Taste (technische Info: sendet nicht die neutrale, sondern die linke virtuelle Taste)</td>
  </tr>
  <tr>
    <td>{RAlt}</td>
    <td>Rechte <kbd>Alt</kbd>-Taste (oder <kbd>AltGr</kbd>, abhängig von der Tastaturbelegung)</td>
  </tr>
  <tr>
    <td>{Alt down}</td>
    <td>Hält die <kbd>Alt</kbd>-Taste gedrückt, bis {Alt up} gesendet wird. Um stattdessen die linke oder rechte Taste gedrückt zu halten, nutzt man {RAlt down} und {RAlt up}.</td>
  </tr>
  <tr>
    <th>&nbsp;</th>
    <th>&nbsp;</th>
  </tr>
  <tr>
    <td>{Shift}</td>
    <td><kbd>Umschalt</kbd> (technische Info: sendet die neutrale virtuelle Taste, aber den linken Scancode)</td>
  </tr>
  <tr>
    <td>{LShift}</td>
    <td>Linke <kbd>Umschalt</kbd>-Taste (technische Info: sendet nicht die neutrale, sondern die linke virtuelle Taste)</td>
  </tr>
  <tr>
    <td>{RShift}</td>
    <td>Rechte <kbd>Umschalt</kbd>-Taste</td>
  </tr>
  <tr>
    <td>{Shift down}</td>
    <td>Hält die <kbd>Umschalt</kbd>-Taste gedrückt, bis {Shift up} gesendet wird. Um stattdessen die linke oder rechte Taste gedrückt zu halten, nutzt man {RShift down} und {RShift up}.</td>
  </tr>
  <tr>
    <th>&nbsp;</th>
    <th>&nbsp;</th>
  </tr>
  <tr>
    <td>{LWin}</td>
    <td>Linke <kbd>Win</kbd>-Taste</td>
  </tr>
  <tr>
    <td>{RWin}</td>
    <td>Rechte <kbd>Win</kbd>-Taste</td>
  </tr>
  <tr>
    <td>{LWin down}</td>
    <td>Hält die linke <kbd>Win</kbd>-Taste gedrückt, bis {LWin up} gesendet wird</td>
  </tr>
  <tr>
    <td>{RWin down}</td>
    <td>Hält die rechte <kbd>Win</kbd>-Taste gedrückt, bis {RWin up} gesendet wird</td>
  </tr>
  <tr>
    <th>&nbsp;</th>
    <th>&nbsp;</th>
  </tr>
  <tr>
    <td>{AppsKey}</td>
    <td><kbd>Menü</kbd>-Taste (öffnet das Rechtsklick- oder Kontextmenü)</td>
  </tr>
  <tr>
    <td>{Sleep}</td>
    <td><kbd>Sleep</kbd>-Taste.</td>
  </tr>
  <tr id="asc">
    <td>{ASC nnnnn}</td>
    <td><p>Sendet eine <kbd>Alt</kbd>+nnnnn-Tastenkombination per Ziffernblock, um Sonderzeichen zu erzeugen, die auf der Tastatur normalerweise nicht vorhanden sind. Um ASCII-Zeichen zu generieren, gibt man eine Nummer zwischen 1 und 255 an. Um ANSI-Zeichen zu generieren (Standard in den meisten Sprachen), gibt man zuerst eine 0 an und danach eine Nummer zwischen 128 und 255, zum Beispiel {Asc 0133}.</p>
    <p>Um Unicode-Zeichen zu generieren, gibt man eine Nummer zwischen 256 und 65535 an (ohne 0 davor). Allerdings wird das nicht von jeder Anwendung unterstützt. Alternativen dazu finden Sie im nächsten Abschnitt.</p></td>
  </tr>
  <tr id="Unicode">
    <td>{U+nnnn}</td>
    <td><p id="sendu">Sendet ein Unicode-Zeichen - <em>nnnn</em> ist der hexadezimale Wert des Zeichens ohne 0x-Präfix. Diese Methode ist üblicherweise nicht notwendig, weil Send und ControlSend automatisch Unicode-Text unterstützt.</p>
    <p><a href="https://msdn.microsoft.com/de-de/library/ms646310">SendInput()</a> oder <a href="https://msdn.microsoft.com/de-de/library/ms646276">WM_CHAR</a> wird zum Senden des Zeichens verwendet, außerdem wird der aktuelle Send-Modus ignoriert. Zeichen, die auf diese Weise gesendet werden, lösen in der Regel keine Tastenkürzel oder Hotkeys aus.</p></td>
  </tr>
  <tr id="vk">
    <td><p>{vkXX}<br>
      
      {scYYY}<br>
    
    {vkXXscYYY}</p></td>
    <td><p>Sendet einen Tastendruck, der die virtuelle Taste XX und den Scancode YYY hat. Zum Beispiel: <code>Send "{vkFFsc159}"</code>. Lässt man den sc- oder vk-Bereich weg, wird der am besten geeignete Wert an seiner Stelle gesendet.</p>
      <p>Die Werte für XX und YYY sind hexadezimal und können üblicherweise über den Menüpunkt <a href="KeyHistory.htm">View-&gt; Key history</a> im Hauptfenster abgerufen werden. Siehe auch: <a href="../KeyList.htm#SpecialKeys">Sondertasten</a></p>
      <p class="warning"><strong>Warnung:</strong> Eine solche Kombination von vk und sc ist nur mit Send gültig.</p></td>
  </tr>
  <tr>
    <th>&nbsp;</th>
    <th>&nbsp;</th>
  </tr>
  <tr>
    <td>{Numpad0} - {Numpad9}</td>
    <td>Ziffernblocktasten (wenn <kbd>Num</kbd> eingeschaltet ist). Zum Beispiel: {Numpad5} ist <kbd>5</kbd>.</td>
  </tr>
  <tr>
    <td>{NumpadDot}</td>
    <td><kbd>,</kbd> (Komma-Taste im Ziffernblock) (wenn <kbd>Num</kbd> eingeschaltet ist)</td>
  </tr>
  <tr>
    <td>{NumpadEnter}</td>
    <td><kbd>Enter</kbd>-Taste im Ziffernblock</td>
  </tr>
  <tr>
    <td>{NumpadMult}</td>
    <td><kbd>*</kbd> (Multiplikationstaste im Ziffernblock)</td>
  </tr>
  <tr>
    <td>{NumpadDiv}</td>
    <td><kbd>/</kbd> (Divisionstaste im Ziffernblock)</td>
  </tr>
  <tr>
    <td>{NumpadAdd}</td>
    <td><kbd>+</kbd> (Additionstaste im Ziffernblock)</td>
  </tr>
  <tr>
    <td>{NumpadSub}</td>
    <td><kbd>-</kbd> (Subtraktionstaste im Ziffernblock)</td>
  </tr>
  <tr>
    <th>&nbsp;</th>
    <th>&nbsp;</th>
  </tr>
  <tr>
    <td>{NumpadDel}</td>
    <td><kbd>Entf</kbd>-Taste im Ziffernblock (diese und die nachfolgenden Ziffernblocktasten sind nur verwendbar, wenn <kbd>Num</kbd> ausgeschaltet ist)</td>
  </tr>
  <tr>
    <td>{NumpadIns}</td>
    <td><kbd>Einfg</kbd>-Taste im Ziffernblock</td>
  </tr>
  <tr>
    <td>{NumpadClear}</td>
    <td>Funktionslose Taste im Ziffernblock (üblicherweise die Taste '5', wenn <kbd>Num</kbd> ausgeschaltet ist).</td>
  </tr>
  <tr>
    <td>{NumpadUp}</td>
    <td><kbd>↑</kbd> (Nach-Oben-Taste) im Ziffernblock</td>
  </tr>
  <tr>
    <td>{NumpadDown}</td>
    <td><kbd>↓</kbd> (Nach-Unten-Taste) im Ziffernblock</td>
  </tr>
  <tr>
    <td>{NumpadLeft}</td>
    <td><kbd>←</kbd> (Nach-Links-Taste) im Ziffernblock</td>
  </tr>
  <tr>
    <td>{NumpadRight}</td>
    <td><kbd>→</kbd> (Nach-Rechts-Taste) im Ziffernblock</td>
  </tr>
  <tr>
    <td>{NumpadHome}</td>
    <td><kbd>Pos1</kbd> im Ziffernblock</td>
  </tr>
  <tr>
    <td>{NumpadEnd}</td>
    <td><kbd>Ende</kbd> im Ziffernblock</td>
  </tr>
  <tr>
    <td>{NumpadPgUp}</td>
    <td><kbd>Bild↑</kbd> im Ziffernblock</td>
  </tr>
  <tr>
    <td>{NumpadPgDn}</td>
    <td><kbd>Bild↓</kbd> im Ziffernblock</td>
  </tr>
  <tr>
    <th>&nbsp;</th>
    <th>&nbsp;</th>
  </tr>
  <tr>
    <td>{Browser_Back}</td>
    <td>Browser "Zurück"</td>
  </tr>
  <tr>
    <td>{Browser_Forward}</td>
    <td>Browser "Vorwärts"</td>
  </tr>
  <tr>
    <td>{Browser_Refresh}</td>
    <td>Browser "Aktualisieren"</td>
  </tr>
  <tr>
    <td>{Browser_Stop}</td>
    <td>Browser "Stopp"</td>
  </tr>
  <tr>
    <td>{Browser_Search}</td>
    <td>Browser "Suchen"</td>
  </tr>
  <tr>
    <td>{Browser_Favorites}</td>
    <td>Browser "Favoriten"</td>
  </tr>
  <tr>
    <td>{Browser_Home}</td>
    <td>Startet den Browser und öffnet die Startseite</td>
  </tr>
  <tr>
    <td>{Volume_Mute}</td>
    <td>Gesamtlautstärke stummschalten bzw. Stummschaltung aufheben. Normalerweise das gleiche wie <code><a href="SoundSet.htm">SoundSet</a> "+1", , "mute"</code>.</td>
  </tr>
  <tr>
    <td>{Volume_Down}</td>
    <td>Gesamtlautstärke leiser machen. Normalerweise das gleiche wie <code><a href="SoundSet.htm">SoundSet</a> "-5"</code>.</td>
  </tr>
  <tr>
    <td>{Volume_Up}</td>
    <td>Gesamtlautstärke lauter machen. Normalerweise das gleiche wie <code><a href="SoundSet.htm">SoundSet</a> "+5"</code>.</td>
  </tr>
  <tr>
    <td>{Media_Next}</td>
    <td>Media Player "Nächster Track"</td>
  </tr>
  <tr>
    <td>{Media_Prev}</td>
    <td>Media Player "Vorheriger Track"</td>
  </tr>
  <tr>
    <td>{Media_Stop}</td>
    <td>Media Player "Stopp"</td>
  </tr>
  <tr>
    <td>{Media_Play_Pause}</td>
    <td>Media Player "Wiedergabe/Anhalten"</td>
  </tr>
  <tr>
    <td>{Launch_Mail}</td>
    <td>E-Mail-Programm öffnen</td>
  </tr>
  <tr>
    <td>{Launch_Media}</td>
    <td>Media Player öffnen</td>
  </tr>
  <tr>
    <td>{Launch_App1}</td>
    <td>Benutzerdefiniertes Programm 1 öffnen</td>
  </tr>
  <tr>
    <td>{Launch_App2}</td>
    <td>Benutzerdefiniertes Programm 2 öffnen</td>
  </tr>
  <tr>
    <th>&nbsp;</th>
    <th>&nbsp;</th>
  </tr>
  <tr>
    <td>{PrintScreen}</td>
    <td><kbd>Druck</kbd></td>
  </tr>
  <tr>
    <td>{CtrlBreak}</td>
    <td><kbd>Strg</kbd>+<kbd>Untbr</kbd></td>
  </tr>
  <tr>
    <td>{Pause}</td>
    <td><kbd>Pause</kbd></td>
  </tr>
  <tr>
    <th>&nbsp;</th>
    <th>&nbsp;</th>
  </tr>
  <tr id="Click">
    <td align="center"><strong>{Click [Optionen]}</strong></td>
    <td>Sendet einen Mausklick, das die gleichen Optionen verwendet wie die von der <a href="Click.htm">Click-Funktion</a>. Zum Beispiel würde <code>Send "{Click}"</code> die linke Maustaste einmal bei der aktuellen Mausposition klicken, und <code>Send "{Click 100, 200}"</code> würde auf den Koordinaten 100, 200 klicken (basierend auf <a href="CoordMode.htm">CoordMode</a>). Um den Mauszeiger ohne Klicken zu verschieben, gibt man nach den Koordinaten eine 0 an; zum Beispiel: <code>Send "{Click 100, 200, 0}"</code>. Die Verzögerung zwischen den Mausklicks wird durch <a href="SetMouseDelay.htm">SetMouseDelay</a> bestimmt (nicht <a href="SetKeyDelay.htm">SetKeyDelay</a>).</td>
  </tr>
  <tr>
    <td>{WheelDown}, {WheelUp}, {WheelLeft}, {WheelRight}, {LButton}, {RButton}, {MButton}, {XButton1}, {XButton2}</td>
    <td>Sendet ein Maustastenereignis auf die aktuelle Mausposition (um die Position und weitere Optionen zu kontrollieren, siehe <a href="Click.htm">{Click}</a>). Die Verzögerung zwischen den Mausklicks wird durch <a href="SetMouseDelay.htm">SetMouseDelay</a> bestimmt. WheelLeft/Right funktionieren nicht in Betriebssystemen älter als Windows Vista.</td>
  </tr>
  <tr>
    <td><strong>{Blind}</strong></td>
    <td>Aktiviert den <a href="#blind">Blind-Modus</a>, der dem Skript mehr Kontrolle gibt, indem er eine Reihe von Dingen deaktiviert, die normalerweise automatisch ausgeführt werden, damit die Dinge wie erwartet funktionieren. Die Zeichenkette <code>{Blind}</code> muss am Anfang der Zeichenkette stehen.</td>
  </tr>
  <tr id="Raw">
    <td><strong>{Raw}</strong></td>
    <td>Aktiviert den <a href="#SendRaw"><em>Raw-Modus</em></a>, wodurch die folgenden Zeichen als direkt geschriebener Text interpretiert werden: <code>^+!#{}</code>. Zwar muss <code>{Raw}</code> nicht am Anfang der Zeichenkette vorkommen, allerdings bleibt es, wenn es einmal angegeben wurde, für den Rest der Zeichenkette aktiv.</td>
  </tr>
  <tr id="Text">
    <td><strong>{Text}</strong></td>
    <td>Aktiviert den <a href="#SendText"><em>Text-Modus</em></a>, um eine Kette von Zeichen statt Tastendrücke zu senden. Der Text-Modus bewirkt wie der Raw-Modus, dass die folgenden Zeichen als direkt geschriebener Text interpretiert werden: <code>^+!#{}</code>. Zwar muss <code>{Text}</code> nicht am Anfang der Zeichenkette vorkommen, allerdings bleibt es, wenn es einmal angegeben wurde, für den Rest der Zeichenkette aktiv.</td>
  </tr>
</table>

<h2>Mehrfaches oder haltendes Drücken einer Taste</h2>
<p id="repeat"><strong>Mehrfaches Drücken</strong>: Umschließen Sie den Namen der Taste und die Anzahl an Wiederholungen mit geschweiften Klammern. Zum Beispiel:</p>
<pre>Send "{DEL 4}"  <em>; Drückt viermal die ENTF-Taste.</em>
Send "{S 30}"   <em>; Sendet 30 große S-Zeichen.</em>
Send "+{TAB 4}"  <em>; Drückt viermal UMSCHALT+TAB.</em></pre>
<p id="Down"><strong>Halten oder Loslassen</strong>: Umschließen Sie den Namen der Taste und das Wort <strong>Down</strong> oder <strong>Up</strong> mit geschweiften Klammern. Zum Beispiel:</p>
<pre>Send "{b down}{b up}"
Send "{TAB down}{TAB up}"
Send "{Up down}"  <em>; Drückt die NACH-OBEN-Taste nach unten.</em>
Sleep 1000  <em>; Hält sie eine Sekunde lang gedrückt.</em>
Send "{Up up}"  <em>; Lässt die NACH-OBEN-Taste los.</em></pre>
<p>Wenn eine Taste mit der Methode oben gedrückt gehalten wird, erfolgt keine Auto-Wiederholung, wie es beim physischen Gedrückthalten geschehen würde (Auto-Wiederholung ist nämlich ein Treiber/Hardware-Feature). Allerdings kann mit einer <a href="Loop.htm">Schleife</a> das Auto-Wiederholen künstlich erzeugt werden. Das folgende Beispiel sendet 20 Tabulator-Tastendrücke:</p>
<pre>Loop 20
{
    Send "{Tab down}"  <em>; Auto-Wiederholen besteht aus fortlaufenden Down-Ereignissen (ohne Up-Ereignisse).</em>
    Sleep 30  <em>; Die Anzahl der Millisekunden zwischen den Tastendrücken (oder alternativ <a href="SetKeyDelay.htm">SetKeyDelay</a>).</em>
}
Send "{Tab up}"  <em>; Lässt die Taste los.</em></pre>
<p>Standardmäßig lässt Send eine Modifikatortaste (<kbd>Strg</kbd>/<kbd>Umschalt</kbd>/<kbd>Alt</kbd>/<kbd>Win</kbd>) nicht automatisch los, wenn diese Modifikatortaste via Send "nach unten gedrückt" wurde. <code>Send a</code> beispielsweise verhält sich eventuell ähnlich wie <code>Send "<a href="#blind">{Blind}</a>{Ctrl up}a{Ctrl down}"</code>, wenn der Benutzer <kbd>Strg</kbd> physisch gedrückt hält, während <code>Send "{Ctrl Down}"</code> gefolgt von <code>Send "a"</code> einen <kbd>Strg</kbd>+<kbd>A</kbd>-Tastendruck erzeugen würde. <em>DownTemp</em> und <em>DownR</em> können genutzt werden, um dieses Verhalten zu überschreiben. <em>DownTemp</em> und <em>DownR</em> haben die gleiche Wirkung wie <em>Down</em>, mit Ausnahme der Modifikatortasten (<kbd>Strg</kbd>/<kbd>Umschalt</kbd>/<kbd>Alt</kbd>/<kbd>Win</kbd>).</p>
<p id="DownTemp"><strong>DownTemp</strong> benachrichtigt nachfolgende Send-Befehle, dass die Taste nicht permanent im gedrückten Zustand sein muss und jederzeit losgelassen werden könnte, wenn ein Tastendruck dies erfordert. <code>Send "{Control DownTemp}"</code>, später gefolgt von <code>Send "a"</code>, würde zum Beispiel einen normalen <kbd>A</kbd>-Tastendruck erzeugen, nicht einen <kbd>Strg</kbd>+<kbd>A</kbd>-Tastendruck. Jede Verwendung von Send kann dazu führen, dass der Modifikator permanent losgelassen wird, daher ist <em>DownTemp</em> nicht gerade die ideale Wahl, um Modifikatortasten <a href="../misc/Remap.htm">neuzubelegen</a>.</p>
<p id="DownR"><strong>DownR</strong> (das "R" bedeutet <a href="../misc/Remap.htm">Remapping</a> bzw. Neubelegen, was dessen Hauptzweck darstellt) teilt nachfolgenden Sendevorgängen mit, dass die Taste, wenn sie automatisch losgelassen wird, nach Beendigung des Sendevorgangs erneut gedrückt werden sollte. Zum Beispiel würde <code>Send "{Control DownR}"</code> und dann <code>Send "a"</code> einen normalen <kbd>A</kbd>-Tastendruck erzeugen, nicht einen <kbd>Strg</kbd>+<kbd>A</kbd>-Tastendruck, aber die <kbd>Strg</kbd>-Taste im gedrückten Zustand lassen, um sie für Tastaturkürzel zu verwenden. Mit anderen Worten hat <em>DownR</em> denselben Effekt wie, als würde man die Taste physisch drücken.</p>
<p>Wenn ein Zeichen nicht zu einer virtuellen Taste im aktuellen Tastaturlayout gehört, kann es nicht "gedrückt" oder "losgelassen" werden. <code>Send "{µ up}"</code> beispielsweise hat keinen Einfluss auf die meisten Layouts, während <code>Send "{µ down}"</code> das gleiche wie <code>Send "µ"</code> ist.</p>

<h2 id="Remarks">Allgemeine Bemerkungen</h2>
<p id="characters"><strong>Zeichen vs. Tasten</strong>: Standardmäßig werden Zeichen, die gesendet werden sollen, zuerst in Tastendrücke umgewandelt. Wenn diese Umwandlung nicht möglich ist (also wenn das aktuelle Tastaturlayout keine Taste oder Tastenkombination enthält, die dieses Zeichen erzeugen würde), wird das Zeichen mittels einer der folgenden Fallback-Methoden gesendet:</p>
<ul id="fallback">
  <li>SendEvent und SendInput nutzen <a href="http://msdn.microsoft.com/de-de/library/ms646310">SendInput()</a> mit dem <a href="https://msdn.microsoft.com/de-de/library/ms646271#keyeventf_unicode">KEYEVENTF_UNICODE-Flag</a>.</li>
  <li>SendPlay nutzt die <a href="#asc">Alt+nnnnn</a>-Methode, die nur Unicode erzeugt, wenn es von der Zielanwendung unterstützt wird.</li>
  <li>Controlsend sendet eine <a href="https://msdn.microsoft.com/de-de/library/ms646276">WM_CHAR</a>-Meldung.</li>
</ul>
<p class="warning"><strong>Hinweis:</strong> Zeichen, die mit einer der oben genannten Methoden gesendet werden, lösen in der Regel keine Tastenkürzel oder Hotkeys aus.</p>
<p id="AZ">Jedes Zeichen im Bereich von <strong>a-z</strong> oder <strong>A-Z</strong> (reine ASCII-Buchstaben), das im aktuellen Tastaturlayout nicht vorhanden ist, kann eventuell als Zeichen oder als entsprechender virtueller Tastencode (vk41-vk5A) gesendet werden:</p>
<ul>
  <li>Wenn ein reiner Buchstabe (also ohne Modifikatoren oder geschweifte Klammern) gesendet wird, oder wenn der <a href="#Raw">Raw-Modus</a> aktiv ist, wird er als Zeichen gesendet. <code>Send "{Raw}Regards"</code> beispielsweise sendet den erwarteten Text, obwohl das Drücken der <kbd>R</kbd>-Taste (vk52) ein anderes Zeichen erzeugen könnte (z. B. <kbd>К</kbd> im russischen Layout). <code>{Raw}</code> kann in diesem Fall weggelassen werden, es sei denn, eine Modifikatortaste wurde durch ein vorheriges Send aktiviert.</li>
  <li>Wenn eine oder mehrere Modifikatortasten durch die Send-Funktion aktiviert wurden, oder wenn der Buchstabe in geschweiften Klammern gesetzt ist, werden sie als Tastencode gesendet (mit <kbd>Umschalt</kbd> modifiziert, wenn der Buchstabe großgeschrieben ist). Dadurch kann das Skript auf einfache Weise die vordefinierten Tastenkürzel aktivieren. <code>^c</code> und <code>{Ctrl down}c{Ctrl up}</code> beispielsweise aktivieren das Standard-Tastenkürzel  <kbd>Strg</kbd>+<kbd>C</kbd>, während <code>{c}</code> das gleiche wie <code>{vk43}</code> ist.</li>
</ul>
<p>Wenn der Buchstabe im aktuellen Tastaturlayout vorhanden ist, wird er immer als Tastencode gesendet, den das Layout mit diesem Buchstaben assoziiert (es sei denn, der <a href="#SendText">Text-Modus</a> wird genutzt, dann wird das Zeichen auf andere Weise gesendet). Das heißt, dass der obige Abschnitt nur für nicht-lateinische Layouts wie z. B. Russisch relevant ist.</p>
<p id="mask"><strong>Modifikatorstatus</strong>: Wenn mit Send der Status von <kbd>Win</kbd>- oder <kbd>Alt</kbd>-Modifikatortasten geändert werden muss (z. B. wenn der Benutzer eine dieser Tasten gedrückt hält), werden eventuell zusätzliche Tastendrücke (standardmäßig <kbd>Strg</kbd>) hinzugefügt, um zu verhindern, dass das Startmenü oder das Fenstermenü angezeigt wird. Weitere Informationen finden Sie unter <a href="_MenuMaskKey.htm">#MenuMaskKey</a>.</p>
<p><strong>BlockInput im Vergleich zu SendInput/SendPlay</strong>: Obwohl die <a href="BlockInput.htm">BlockInput</a>-Funktion genutzt werden kann, um zu verhindern, dass physische Eingaben des Benutzers die Ausführung der simulierten Tastendrücke stören, ist es oft besser, <a href="#SendInputDetail">SendInput</a> oder <a href="#SendPlayDetail">SendPlay</a> zu nutzen, damit Tastendrücke und Mausklicks nicht mehr unterbrochen werden können. SendInput/Play verhindert im Gegensatz zu BlockInput, dass die Eingaben des Benutzers während des Sendens verworfen werden; stattdessen werden solche Tastendrücke gepuffert und später gesendet.</p>
<p>Beim Senden vieler Tastendrücke kann ein <a href="../Scripts.htm#continuation">Fortsetzungsbereich</a> hilfreich sein, um die Übersichtlichkeit und Wartbarkeit des Skripts zu erhöhen.</p>
<p>Da das Betriebssystem das Simulieren von <kbd>Strg</kbd>+<kbd>Alt</kbd>+<kbd>Entf</kbd> nicht erlaubt, kann so etwas wie <code>Send "^!{Delete}"</code> nicht funktionieren.</p>
<p><b>Send könnte nicht funktionieren</b> in Windows Vista oder höher, wenn das aktive Fenster mit administrativen Rechten läuft, und das Skript nicht. Das hängt mit dem Sicherheitsmechanismus "User Interface Privilege Isolation" (UIPI) zusammen.</p>

<h2 id="SendInputDetail">SendInput</h2>
<p>SendInput ist in der Regel die bevorzugte Methode, um Tastendrücke und Mausklicks zu senden, weil sie im Gegensatz zu den anderen Methoden bedeutend schneller und zuverlässiger ist. In den meisten Fällen wird eine Zeichenkette via SendInput nahezu verzögerungsfrei gesendet, sogar wenn es sich um sehr lange Zeichenketten handelt. Aufgrund dieser Schnelligkeit ist SendInput auch zuverlässiger, weil die Chance geringer ist, dass ein anderes Fenster unerwartet erscheint und die Tastendrücke abfängt. Die Zuverlässigkeit erhöht sich nochmals durch die Tatsache, dass die Eingaben des Benutzers während eines SendInput-Vorgangs bis zum Schluss zwischengespeichert werden.</p>
<p>Im Gegensatz zu den anderen Sendmethoden ist SendInput auf ca. 5000 Zeichen begrenzt (dieser Grenzwert variiert je nach Version des Betriebssystems und Performance-Einstellungen). Zeichen und Ereignisse oberhalb des Limits werden nicht gesendet.</p>
<p><strong>Hinweis</strong>: SendInput ignoriert SetKeyDelay, weil das Betriebssystem keine Verzögerung in diesem Modus unterstützt. Wenn SendInput allerdings aufgrund der unten genannten Bedingungen auf <a href="#SendEvent">SendEvent</a> zurückgreift, wird <code><a href="SetKeyDelay.htm">SetKeyDelay</a> -1, 0</code> verwendet (es sei denn, die Tastenverzögerung von SendEvent ist <code>-1, -1</code>, dann wird <code>-1, -1</code> verwendet). Wenn SendInput auf <a href="#SendPlayDetail">SendPlay</a> zurückgreift, wird die Tastenverzögerung von SendPlay verwendet.</p>
<p id="SendInputUnavail">Wenn ein Skript - <em>außer</em> das Skript, das SendInput ausführt - einen <a href="_InstallKeybdHook.htm">systemnahen Tastatur-Hook</a> installiert hat, wird SendInput automatisch auf <a href="#SendEvent">SendEvent</a> zurückgreifen (oder auf <a href="#SendPlayDetail">SendPlay</a>, wenn <code><a href="SendMode.htm">SendMode</a> "InputThenPlay"</code> wirksam ist). Dieses Verhalten ist notwendig, weil das Vorhandensein eines externen Hooks alle Vorteile von SendInput zunichtemachen würde, so dass es sowohl SendPlay als auch SendEvent unterlegen wäre. Da SendInput jedoch einen systemnahen Hook in Programmen außer v1.0.43+ nicht erkennen kann, wird es in solchen Fällen nicht auf einen anderen Modus zurückgreifen, wodurch es unzuverlässiger als SendPlay/Event werden würde.</p>
<p>Wenn SendInput einen Mausklick mithilfe von z. B. <a href="#Click">{Click}</a> sendet, während <code><a href="CoordMode.htm">CoordMode</a> "Mouse", "Relative"</code> aktiv ist (die Standardeinstellung), wird jeder Klick relativ zum Fenster sein, das vor dem Senden aktiv war. Demzufolge, wenn SendInput absichtlich ein anderes Fenster aktiviert (z. B. mit ALT+TAB), werden die Koordinaten der nachfolgenden Klicks innerhalb der gleichen Funktion falsch sein, weil sie weiterhin relativ zum alten statt zum neuen Fenster sind.</p>

<h2 id="SendPlayDetail">SendPlay</h2>
<p class="warning"><strong>Warnung:</strong> SendPlay funktioniert möglicherweise überhaupt nicht, wenn UAC aktiviert ist, selbst wenn das Skript mit Administratorrechten läuft. Weitere Informationen finden Sie in der <a href="../FAQ.htm#uac">FAQ</a>.</p>
<p>Der größte Vorteil von SendPlay gegenüber den anderen Methoden ist die Fähigkeit, Tastendrücke und Mausklicks bei einer breiteren Auswahl von Videospielen erzeugen zu können. Zum Beispiel könnten <a href="../Hotstrings.htm#SendMode">Hotstrings</a> in einem Videospiel nur funktionieren, wenn sie die <a href="../Hotstrings.htm#SendMode">SendPlay-Option</a> haben.</p>
<p>Von den drei Send-Methoden ist SendPlay die ungewöhnlichste Methode, weil sie selbst keine Tastendrücke und Mausklicks simuliert. Stattdessen erstellt sie eine Reihe von Ereignissen (Meldungen), die direkt in das aktive Fenster einfließen (ähnlich wie <a href="ControlSend.htm">ControlSend</a>, aber auf niedrigerem Niveau). Demzufolge kann SendPlay keine Hotkeys oder Hotstrings auslösen.</p>
<p>Wie bei <a href="#SendInputDetail">SendInput</a> werden die Tastendrücke von SendPlay nicht mit den Eingaben des Benutzers vermischt. Wenn der Benutzer also während SendPlay etwas eingibt, werden solche Tastendrücke bis zum Schluss zwischengespeichert.</p>
<p>Zwar ist SendPlay deutlich langsamer als SendInput, aber schneller als der traditionelle <a href="#SendEvent">SendEvent</a>-Modus (selbst wenn <a href="SetKeyDelay.htm">Tastenverzögerung</a> auf -1 ist).</p>
<p>Die <kbd>Win</kbd>-Tasten (LWin und RWin) werden während SendPlay automatisch blockiert, wenn der <a href="_InstallKeybdHook.htm">Tastatur-Hook</a> installiert ist. Dadurch wird verhindert, dass das Startmenü angezeigt wird, wenn der Benutzer versehentlich eine <kbd>Win</kbd>-Taste während des Sendens drückt. Alle anderen Tasten außer LWin und RWin müssen nicht blockiert werden, weil das Betriebssystem sie automatisch hinauszögert, bis SendPlay durchgeführt wurde (via Pufferung).</p>
<p>SendPlay verwendet nicht die Standardeinstellungen von <a href="SetKeyDelay.htm">SetKeyDelay</a> und <a href="SetMouseDelay.htm">SetMouseDelay</a>. Stattdessen gilt standardmäßig überhaupt keine Verzögerung, die aber wie folgt geändert werden kann:</p>
<pre><a href="SetKeyDelay.htm">SetKeyDelay</a> 0, 10, <strong>"Play"</strong>  <em>; Beachten Sie, dass sowohl 0 als auch -1 das gleiche sind im SendPlay-Modus.</em>
<a href="SetMouseDelay.htm">SetMouseDelay</a> 10, <strong>"Play"</strong></pre>
<p>SendPlay kann <kbd>Feststell</kbd>, <kbd>Num</kbd> oder <kbd>Rollen</kbd> weder ein- noch ausschalten. SendPlay kann zudem den Status einer Taste, wie von <a href="GetKeyState.htm">GetKeyState</a> gesehen, nicht ändern, es sei denn, die Tastendrücke werden an eines der eigenen Fenster des Skripts gesendet. Selbst dann können Änderungen an den linken/rechten Modifikatortasten (z. B. RControl) nur über ihrem neutralen Gegenstück (z. B. Control) erkannt werden. Außerdem gelten für SendPlay noch weitere Einschränkungen, die auf der <a href="SendMode.htm#Play">SendMode-Seite</a> zu finden sind.</p>
<p>Im Gegensatz zu <a href="#SendInputDetail">SendInput</a> und <a href="#SendEvent">SendEvent</a> kann SendPlay von einem Benutzer unterbrochen werden, indem er <kbd>Strg</kbd>+<kbd>Alt</kbd>+<kbd>Entf</kbd> oder <kbd>Strg</kbd>+<kbd>Esc</kbd> drückt. Wenn dies geschieht, werden die restlichen Tastendrücke nicht gesendet, und danach das Skript fortgesetzt, als ob das SendPlay normal abgeschlossen wurde.</p>
<p>Obwohl SendPlay LWin- und RWin-Ereignisse senden kann, werden sie nicht ihre native Funktion durchführen, sondern direkt an das aktive Fenster gesendet. Um das zu umgehen, nutzt man <a href="#SendEvent">SendEvent</a>. Zum Beispiel würde <code>SendEvent "#r"</code> das Ausführen-Dialogfenster des Startmenüs anzeigen.</p>

<h2>Siehe auch</h2>
<p><a href="SendMode.htm">SendMode</a>, <a href="SetKeyDelay.htm">SetKeyDelay</a>, <a href="SetStoreCapsLockMode.htm">SetStoreCapsLockMode</a>, <a href="../misc/EscapeChar.htm">Escapesequenzen (z. B. `n)</a>, <a href="ControlSend.htm">ControlSend</a>, <a href="BlockInput.htm">BlockInput</a>, <a href="../Hotstrings.htm">Hotstrings</a>, <a href="WinActivate.htm">WinActivate</a></p>
<h2>Beispiele</h2>
<div class="ex" id="ExBasic">
<p><a href="#ExBasic">#1</a></p>
<pre>Send "Mit freundlichen Grüßen,{enter}Max Mustermann"  <em>; Schreibt eine zweizeilige Signatur.</em>
Send "!ds" <em>; Öffnet das Dateimenü und wählt Speichern aus (ALT+D, gefolgt von S).</em>
Send "{End}+{Left 4}" <em>; Springt zum Ende des Textes und sendet viermal UMSCHALT+NACH-LINKS.</em>
SendInput "<a href="#Raw">{Raw}</a>Eine lange Reihe von Rohzeichen, die mit der schnellsten Methode (<a href="#SendInputDetail">SendInput</a>) gesendet wurden."</pre>
</div>

</body>
</html>
