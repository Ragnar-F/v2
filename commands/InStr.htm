<!DOCTYPE HTML>
<html>
<head>
<title>InStr()</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="robots" content="noindex, nofollow">
<link href="../static/theme.css" rel="stylesheet" type="text/css" />
<script src="../static/content.js" type="text/javascript"></script>
<script src="../static/ga.js" type="text/javascript"></script>
</head>
<body>

<h1>InStr()</h1>

<p>Sucht eine bestimmte Zeichenkette, beginnend von links oder rechts.</p>

<pre class="Syntax">Fundposition := InStr(Heuhaufen, Nadel [, Zeichengenauigkeit = false, Startposition = 1, Vorkommen = 1])</pre>
<h3>Parameter</h3>
<dl>

  <dt>Heuhaufen</dt>
  <dd><p>Eine Zeichenkette, deren Inhalt durchsucht werden soll.</p></dd>
  
  <dt>Nadel</dt>
  <dd><p>Der zu suchende Text.</p></dd>
  
  <dt>Zeichengenauigkeit</dt>
  <dd><p>Ist der <em>Zeichengenauigkeit</em>-Parameter nicht vorhanden oder "falsch", unterscheidet die Suche nicht zwischen Groß- und Kleinschreibung (die Unterscheidung hängt von <a href="StringCaseSense.htm">StringCaseSense</a> ab); ansonsten muss die Groß- und Kleinschreibung exakt übereinstimmen.</p></dd>

  <dt>Startposition</dt>
  <dd><p>Ist <em>Startposition</em> nicht vorhanden, gilt standardmäßig 1 (der Anfang von <em>Heuhaufen</em>). Ansonsten kann eine 2 angegeben werden, um beim zweiten Zeichen zu beginnen, eine 3, um beim dritten Zeichen zu beginnen, und so weiter.</p>
  <p>Wenn <em>Startposition</em> negativ ist, erfolgt die Suche in umgekehrter Reihenfolge (von rechts nach links), auf der rechten Seite beginnend. Zum Beispiel würde -1 beim letzten Zeichen beginnen. Wenn <em>Startposition</em> eine 0 ist oder die Länge von <em>Heuhaufen</em> überschreitet, wird eine 0 zurückgegeben.</p>
      <p>Egal welchen Wert man als <em>Startposition</em> verwendet - der Rückgabewert ist immer relativ zum ersten <em>Heuhaufen</em>-Zeichen. Zum Beispiel wäre die Position von "abc" in "123abc789" immer 4.</p></dd>

  <dt>Vorkommen</dt>
  <dd><p>Fehlt <em>Vorkommen</em>, gilt standardmäßig die erste Übereinstimmung von <em>Nadel</em> in <em>Heuhaufen</em>. Schreibe eine 2 in <em>Vorkommen</em>, um die Position der zweiten Übereinstimmung zurückzugeben, eine 3 für die dritte Übereinstimmung und so weiter.</p></dd>

  </dl>
  
<h3>Rückgabewert</h3>
<p>Diese Funktion gibt die Position der Zeichenkette <em>Nadel</em> zurück, die in der Zeichenkette <em>Heuhaufen</em> vorkommt. Position 1 ist das erste Zeichen; das liegt daran, dass 0 das Synonym für "falsch" ist, was sich gut als "nicht gefunden" eignet.</p>

<h3>Bemerkungen</h3>
<p><a href="RegExMatch.htm">RegExMatch()</a> ist flexibler als InStr(), wenn es darum geht, ein bestimmtes Muster (regulärer Ausdruck) innerhalb einer Zeichenkette zu suchen. Zum Suchen einer einfachen Zeichenkette ist InStr() besser geeignet.</p>
<p>InStr() stoppt die Suche, sobald eine binäre Null (Null-Terminator) gefunden wird, während RegExMatch() die komplette <a href="../Functions.htm#StrLen">Länge</a> der Zeichenkette durchsucht, egal ob sie binäre Nullen enthält.</p>

<h3>Siehe auch</h3>
<p><a href="RegExMatch.htm">RegExMatch()</a>, <a href="StringCaseSense.htm">StringCaseSense</a>, <a href="is.htm"><em>Wert</em> is <em>Typ</em></a>

<h3>Beispiel</h3>
<pre class="NoIndent"><em>; Beispiel 1</em>
MsgBox % InStr("123abc789","abc") <em>; Gibt 4 zurück</em>

<em>; Beispiel 2</em>
Heuhaufen := "The Quick Brown Fox Jumps Over the Lazy Dog"
Nadel := "Fox"
If InStr(Heuhaufen, Nadel)
  MsgBox, Zeichenkette gefunden.
Else
  MsgBox, Zeichenkette nicht gefunden.

<em>; Beispiel 3</em>
Heuhaufen := "The Quick Brown Fox Jumps Over the Lazy Dog"
Nadel := "the"
MsgBox % InStr(Heuhaufen, Nadel, false, 1, 2) <em>; zeichenungenaue Suche, gibt die Startposition des zweiten Vorkommens zurück</em>
MsgBox % InStr(Haystack, Needle, true) <em>; zeichengenaue Suche, gibt die Startposition des ersten Vorkommens zurück, das gleiche Ergebnis wie oben</em>
</pre>

</body>
</html>
